"// Function to set the repository URL (or path) for the module resolver
bool module_resolver::set_repo(std::string &&r, bool force) {
    // If force is true or the repo is empty, set the repository
    if (force || repo.empty()) {
        repo = std::move(r);  // Move the input string 'r' to the 'repo' variable
        force = true;         // Set force to true, indicating the repository was successfully set
    }
    return force; // Return the value of 'force', indicating if the repository was set
}","The set_repo function is part of the module_resolver class. It sets the repository URL or path (repo) based on the provided string r if certain conditions are met. If the force flag is true or the current repo is empty, the function moves the provided string r into the repo member variable and sets the force flag to true, indicating that the repository has been set successfully. The function then returns the value of force, which is true if the repository was set and false otherwise. This function ensures that the repository is only set if necessary, depending on the force flag or whether the repository is already defined. The use of std::move optimizes the transfer of ownership of the string r to the repo variable without copying."
"// Function to add a module-to-file mapping in the module resolver
bool module_resolver::add_mapping(std::string &&module, std::string &&file, bool force) {
    // Attempt to insert the module-file pair into the map
    auto res = map.emplace(std::move(module), std::move(file)); 

    // If the insertion was successful (module did not exist in the map)
    if (res.second) {
        force = true; // Set 'force' to true, indicating the new mapping was added
    } 
    // If the module already exists in the map and force is true
    else if (force) {
        res.first->second = std::move(file); // Update the existing mapping with the new file
    }

    return force; // Return the value of 'force', indicating if the mapping was added or updated
}","The add_mapping function adds or updates a module-to-file mapping in a map container. The function takes two std::string arguments (module and file) and a boolean force. It attempts to insert the given module and file into a map using the emplace method, which ensures that the module is only added if it does not already exist. If the insertion is successful (i.e., the module was not previously present in the map), it sets the force flag to true. If the module already exists and the force flag is set to true, the function updates the file associated with that module. The function returns the value of force, which is true if the mapping was either added or updated, and false if no changes were made to the map. The use of std::move ensures that the strings are moved into the map, avoiding unnecessary copies."
"// Function to read a tuple file and process its contents
int module_resolver::read_tuple_file(int fd, char const *prefix, bool force) {
    struct stat stat; // Structure to hold information about the file
    // Get file status (e.g., size)
    if (fstat(fd, &stat) < 0)
        return -errno;  // Return error code if fstat fails

    // If the file is empty, return 0 indicating no content to process
    if (!stat.st_size)
        return 0;

    void *buffer = nullptr; // Pointer to hold file data

    // Mapped reading option: use memory mapping to read the file
#if MAPPED_READING
    // Map the entire file into memory (no need for line buffering)
    buffer = mmap(nullptr, stat.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if (buffer == MAP_FAILED)
        return -errno;  // Return error if memory mapping fails

    // Deleter to ensure memory is unmapped when done
    struct Deleter {
        void operator()(void* p) const { munmap(p, size); }
        size_t size;
    };
    // Unique pointer to manage the memory with automatic cleanup
    std::unique_ptr<void, Deleter> guard(buffer, Deleter{(size_t)stat.st_size});
#else
    // If not using memory mapping, allocate memory and read the file into it
    buffer = xmalloc(stat.st_size);
    if (!buffer)
        return -errno;  // Return error if memory allocation fails

    // Deleter to free the allocated memory when done
    struct Deleter { void operator()(void* p) const { free(p); } };
    // Unique pointer to manage the allocated memory
    std::unique_ptr<void, Deleter> guard(buffer);

    // Read the file content into the allocated buffer
    if (read(fd, buffer, stat.st_size) != stat.st_size)
        return -errno;  // Return error if reading the file fails
#endif

    // Determine the length of the prefix (if provided)
    size_t prefix_len = prefix ? strlen(prefix) : 0;
    unsigned lineno = 0;  // Line number for error reporting

    // Iterate through the buffer character by character
    for (char const *begin = reinterpret_cast<char const *>(buffer),
                    *end = begin + stat.st_size, *eol;
         begin != end; begin = eol + 1) {
        lineno++;  // Increment line number
        eol = std::find(begin, end, '\n');  // Find the end of the line
        if (eol == end)  // If no newline is found, skip the last line
            break;

        auto *pos = begin;
        bool pfx_search = prefix_len != 0;  // Flag to check for prefix

    pfx_search:
        // Skip any leading spaces or tabs
        while (*pos == ' ' || *pos == '\t')
            pos++;

        auto *space = pos;
        // Find the next space or tab to identify the module name boundary
        while (*space != '\n' && *space != ' ' && *space != '\t')
            space++;

        if (pos == space)  // If no valid module name found, continue to next line
            continue;

        // If prefix search is enabled, check if the module starts with the prefix
        if (pfx_search) {
            if (size_t(space - pos) == prefix_len && std::equal(pos, space, prefix))
                pfx_search = false;  // Disable prefix search once it's found
            pos = space;
            goto pfx_search;  // Continue searching for the prefix
        }

        // Extract the module name as a string
        std::string module(pos, space);
        // Skip spaces/tabs to reach the file name
        while (*space == ' ' || *space == '\t')
            space++;
        // Extract the file name as a string
        std::string file(space, eol);

        // If the module is a special variable ($root), handle it
        if (module[0] == '$') {
            if (module == ""$root"")
                set_repo(std::move(file));  // Set the repository if $root
            else
                return lineno;  // Return line number on unknown module
        } else {
            // If no file name is provided, generate a default file name
            if (file.empty())
                file = GetCMIName(module);
            // Add the module-to-file mapping to the resolver
            add_mapping(std::move(module), std::move(file), force);
        }
    }

    return 0;  // Return 0 indicating successful processing
}","The read_tuple_file function reads a file (specified by the file descriptor fd) that contains module-to-file mappings and processes its contents. The function first checks the file size using fstat and handles an empty file early. If the file is non-empty, the function either memory-maps the file or reads it into a dynamically allocated buffer based on the MAPPED_READING flag.

After loading the file contents into memory, the function processes each line, extracting the module name and file name. It supports an optional prefix for filtering modules that start with the given prefix. The module names are associated with file names, and if the module is special (like $root), it may set the repository URL using set_repo. The mappings are stored using the add_mapping function, and special handling is included for modules with no associated file name. The function returns 0 upon successful processing or a non-zero error code if any errors occur during file handling."
"// Function to handle a connection request, checking version and identity
module_resolver* module_resolver::ConnectRequest(Cody::Server *s, unsigned version,
                                                std::string &a, std::string &i) {
    // Check if the version is invalid (zero or higher than the supported version)
    if (!version || version > Cody::Version)
        s->ErrorResponse(""version mismatch"");  // Send error response for version mismatch
    else if (a != ""GCC"")  // Check if the request is from a supported client (GCC)
        // Refuse anything but GCC as a valid client
        ErrorResponse(s, std::string(""only GCC supported""));
    else if (!ident.empty() && ident != i)  // Check if the identity matches the expected one
        // Failed identity check: the identity doesn't match
        ErrorResponse(s, std::string(""bad ident""));
    else
        // If all checks pass, send a success response
        s->ConnectResponse(""gcc"");

    // Return the current module_resolver object (this pointer) to indicate success
    return this;
}","The ConnectRequest function processes a connection request from a server (represented by Cody::Server *s). The function first checks if the provided version is valid, i.e., non-zero and less than or equal to the supported version (Cody::Version). If the version is invalid, it sends an error response to the server indicating a ""version mismatch.""

Next, the function checks if the client identifier (a) is ""GCC"". If not, the function sends an error response indicating that only ""GCC"" is supported.

The function then checks whether the identity (i) matches the expected identity stored in the ident member variable. If the identity does not match, it sends an error response indicating a ""bad ident.""

If all checks pass, the server sends a successful connection response (""gcc""). Finally, the function returns the current module_resolver object (this pointer), indicating the request was processed successfully."
"// Function to handle a response for a CMI (Compile Module Interface) request
int module_resolver::cmi_response(Cody::Server *s, std::string &module) {
    // Try to find the module in the map (which maps module names to file paths)
    auto iter = map.find(module);
    
    // If the module is not found in the map
    if (iter == map.end()) {
        // If a default mapping is available, get the default file name for the module
        std::string file = default_map ? GetCMIName(module) : std::string();
        
        // Add the module to the map with the resolved file path (either default or empty)
        auto res = map.emplace(module, file);
        
        // Update the iterator to point to the newly inserted element
        iter = res.first;
    }

    // If the file path associated with the module is empty, send an error response
    if (iter->second.empty()) {
        s->ErrorResponse(""no such module"");  // Send error response if no valid file path is found
    } else {
        // Otherwise, send the resolved file path in the response
        s->PathnameResponse(iter->second);
    }

    // Return 0 indicating successful completion of the function
    return 0;
}","The cmi_response function handles the server's response to a Compile Module Interface (CMI) request for a particular module. The function first searches for the provided module in the map (which maps module names to their associated file paths).

If the module is not found, the function checks whether a default mapping (default_map) is available. If so, it resolves the file path using GetCMIName(module); otherwise, it uses an empty string. The module and its file path (either resolved or empty) are then added to the map.

If the file path associated with the module is empty, indicating that no valid file path was found for the module, the function sends an error response with the message ""no such module."" Otherwise, it sends the file path in the response.

The function returns 0 to indicate that the process has completed, regardless of whether the response was an error or a valid path."
"// Function to handle an include translation request
int module_resolver::IncludeTranslateRequest(Cody::Server *s, Cody::Flags, std::string &include) {
    // Try to find the 'include' in the map (which maps include names to their resolved file paths)
    auto iter = map.find(include);
    
    // If the include is not found and default translation is enabled
    if (iter == map.end() && default_translate) {
        // Try to resolve the file path using GetCMIName, which retrieves the name of the file
        auto file = GetCMIName(include);
        struct stat statbuf;
        bool ok = true;  // Assume that the file is okay until proven otherwise

#if HAVE_FSTATAT
        // If the system supports fstatat, use it to check the file existence in the repository
        int fd_dir = AT_FDCWD;
        
        // If the repository path is not empty, use its file descriptor
        if (!repo.empty()) {
            if (fd_repo == -1) {
                fd_repo = open(repo.c_str(), O_RDONLY | O_CLOEXEC | O_DIRECTORY);
                if (fd_repo < 0) 
                    fd_repo = -2;  // If open fails, set to -2 to indicate failure
            }
            fd_dir = fd_repo;
        }

        // Check if the repository is available and if the file exists and is a regular file
        if (!repo.empty() && fd_repo < 0)
            ok = false;
        else if (fstatat(fd_dir, file.c_str(), &statbuf, 0) < 0 || !S_ISREG(statbuf.st_mode))
            ok = false;
#else
        // If fstatat is not available, check the file existence using stat in the repository path
        auto append = repo;
        append.push_back(DIR_SEPARATOR);
        append.append(file);
        if (stat(append.c_str(), &statbuf) < 0 || !S_ISREG(statbuf.st_mode))
            ok = false;
#endif

        // If the file is not found or not a regular file, mark the file as empty (not present)
        if (!ok)
            file.clear();

        // Add the resolved file (or empty if not found) to the map
        auto res = map.emplace(include, file);
        iter = res.first;  // Update the iterator to point to the newly inserted element
    }

    // If the include was not found or the file path is empty, send a false response
    if (iter == map.end() || iter->second.empty())
        s->BoolResponse(false);
    else
        // Otherwise, send the resolved file path in the response
        s->PathnameResponse(iter->second);

    // Return 0 indicating that the process has completed
    return 0;
}","The IncludeTranslateRequest function handles a request to resolve the file path for a specified include file. It first checks if the requested include is already present in the map (which holds include names mapped to their resolved file paths).

If the include is not found and default translation is enabled (default_translate), the function attempts to resolve the file path using GetCMIName(include). Then, it checks whether the file exists and is a regular file. The file path is validated using either fstatat (if available) or stat. If the file is found, it is added to the map; if not, the file path is marked as empty.

Afterward, the function sends a response back to the client. If the module was not found or the file path is empty, a false boolean response is sent. Otherwise, the resolved file path is sent back in the response.

The function returns 0 to indicate successful completion of the request."
"// Function to check if the current IPv6 address includes the provided address 'a'
// based on the given bit mask (bits).
bool includes(const in6_addr &a) const {
    // Calculate the number of full bytes that need to be compared
    unsigned byte = bits / 8;

    // Iterate through each byte and compare the corresponding bytes in the current address and 'a'
    for (unsigned ix = 0; ix != byte; ix++) {
        // If any byte does not match, return false
        if (addr.s6_addr[ix] != a.s6_addr[ix])
            return false;
    }

    // If there are remaining bits (less than a full byte) to check, apply the mask
    if (bits & 3) {
        // Compare only the relevant bits in the last byte
        // Shift the last byte by the number of remaining bits and check for a mismatch
        if ((addr.s6_addr[byte] ^ a.s6_addr[byte]) >> (8 - (bits & 3)))
            return false;
    }

    // If no mismatches were found, return true indicating that the address is included
    return true;
}","The includes function checks whether the current IPv6 address (represented by addr) includes the provided IPv6 address a, based on a specified bit mask (bits). The mask determines how many bits of the address are considered for comparison."
"// Function to trim the file path by removing the common prefix that matches the current source file
static const char *trim_src_file(const char *file) {
    // Store the current file name (source file) using the __FILE__ macro
    static const char me[] = __FILE__;
    
    // Initialize the position to zero, which will track the common prefix length
    unsigned pos = 0;

    // Compare characters in the file path with the current source file's path
    // and find the point where they diverge
    while (file[pos] == me[pos] && me[pos]) {
        // Increment position until the file path no longer matches the current source file path
        pos++;
    }

    // After finding the divergence point, backtrack to remove any directory separators
    while (pos && !IS_DIR_SEPARATOR(me[pos-1])) {
        // Decrement position to remove the trailing characters until the last directory separator
        pos--;
    }

    // Return the file path starting from the position where the common prefix ends
    return file + pos;
}","The trim_src_file function is designed to return a portion of the given file path, trimming off the common prefix that matches the current source file's path (as determined by the __FILE__ macro). This can be useful for processing or logging relative file paths without including the full source file path."
"void ATTRIBUTE_NORETURN ATTRIBUTE_PRINTF_1 ATTRIBUTE_COLD
internal_error (const char *fmt, ...)
{
  // Print the program name followed by the ""Internal error"" message
  fprintf (stderr, ""%s:Internal error "", progname);
  
  va_list args;  // Declare a variable to hold the list of arguments passed to the function

  // Initialize the argument list, starting from the first argument after fmt
  va_start (args, fmt);

  // Print the formatted error message to stderr using the variable argument list
  vfprintf (stderr, fmt, args);

  // Clean up the argument list after use
  va_end (args);

  // Print a newline after the error message
  fprintf (stderr, ""\n"");

  // Exit the program with a status code of 2 to indicate an internal error
  exit (2);
}","The internal_error function is designed to handle error reporting for unexpected internal errors in a program. It takes a format string (fmt) and a variable number of arguments (thanks to the ellipsis ...) similar to printf. First, it prints the program name and the string ""Internal error"" to standard error (stderr). Then, it uses the provided format string and arguments to print a custom error message. The function finishes by printing a newline and then exits the program with an exit status code of 2, indicating an internal error. The function is marked with attributes such as ATTRIBUTE_NORETURN, which tells the compiler that this function does not return, and ATTRIBUTE_COLD, indicating that this function is less frequently called. The ATTRIBUTE_PRINTF_1 attribute is used to indicate that the function behaves like printf for argument checking."
"static void ATTRIBUTE_NORETURN ATTRIBUTE_COLD ATTRIBUTE_PRINTF_1
error (const char *msg, ...)
{
  // Print the program name followed by the ""error:"" message to stderr
  fprintf (stderr, ""%s:error: "", progname);
  
  va_list args;  // Declare a variable to hold the list of arguments passed to the function

  // Initialize the argument list, starting from the first argument after msg
  va_start (args, msg);

  // Print the formatted error message to stderr using the variable argument list
  vfprintf (stderr, msg, args);

  // Clean up the argument list after use
  va_end (args);

  // Print a newline after the error message
  fprintf (stderr, ""\n"");

  // Exit the program with a status code of 1 to indicate a general error
  exit (1);
}","The error function is used to handle error reporting in the program. It takes a format string (msg) and a variable number of arguments (similar to printf) and reports the error message to the standard error stream (stderr). The function first prints the program name followed by the prefix ""error:"", then it uses the format string and arguments to display the specific error message. After printing the message, it outputs a newline and exits the program with an exit status code of 1, indicating a general error. The function is marked with attributes such as ATTRIBUTE_NORETURN, indicating that it does not return, and ATTRIBUTE_COLD, indicating that the function is rarely called. Additionally, the ATTRIBUTE_PRINTF_1 attribute is used to let the compiler know that this function behaves like printf for argument checking."
"static bool ATTRIBUTE_PRINTF_1 ATTRIBUTE_COLD
noisy (const char *fmt, ...)
{
  // Print the program name followed by a colon to stderr
  fprintf (stderr, ""%s:"", progname);

  va_list args;  // Declare a variable to hold the list of arguments passed to the function

  // Initialize the argument list, starting from the first argument after fmt
  va_start (args, fmt);

  // Print the formatted message to stderr using the variable argument list
  vfprintf (stderr, fmt, args);

  // Clean up the argument list after use
  va_end (args);

  // Print a newline after the message
  fprintf (stderr, ""\n"");

  // Return false to indicate a specific, non-error condition
  return false;
}","The noisy function is designed for printing messages in a similar manner to the printf family of functions, but with the specific purpose of logging information to the standard error stream (stderr). It takes a format string (fmt) and a variable number of arguments, allowing for formatted output. The function first prints the program name followed by a colon, then outputs the formatted message to stderr, and finally prints a newline character. After the message is printed, the function returns false, signaling a non-error condition but typically indicating some form of verbose or debugging output. The ATTRIBUTE_PRINTF_1 attribute signals that the function follows a printf-like format argument behavior, and ATTRIBUTE_COLD indicates that it is rarely called."
"static void ATTRIBUTE_PRINTF_2
fnotice (FILE *file, const char *fmt, ...)
{
  va_list args;  // Declare a variable to hold the list of arguments passed to the function

  // Initialize the argument list, starting from the first argument after fmt
  va_start (args, fmt);

  // Print the formatted message to the specified file stream using the argument list
  vfprintf (file, fmt, args);

  // Clean up the argument list after use
  va_end (args);
}","The fnotice function is used to print formatted output to a specified file stream, such as stdout or stderr. It takes a FILE* (indicating the destination file stream), a format string (fmt), and a variable number of arguments, similar to printf. The function starts by initializing the argument list with va_start and uses vfprintf to print the formatted message to the provided file stream. After printing the message, it cleans up the argument list with va_end. This function is useful for logging or printing messages to different file streams with a similar format to printf. The ATTRIBUTE_PRINTF_2 attribute indicates that this function behaves like printf but with two arguments: the file pointer and the format string."
"static bool
accept_from (char *arg ATTRIBUTE_UNUSED)
{
  bool ok = true;  // Initialize a boolean flag 'ok' to indicate whether the function executes successfully

#if HAVE_AF_INET6  // Check if the platform supports IPv6 (using preprocessor directive)
  unsigned bits = sizeof (in6_addr) * 8;  // Set the default bit count to the size of an IPv6 address in bits
  char *slash = strrchr (arg, '/');  // Find the last occurrence of '/' in the string 'arg'

  if (slash)  // If a '/' is found in the argument
    {
      *slash = 0;  // Terminate the string at the '/' to separate the address and the bits
      if (slash[1])  // If there is something after the '/'
	{
	  char *endp;  // Declare a pointer to store the remaining string after converting the bits
	  bits = strtoul (slash + 1, &endp, 0);  // Convert the string after '/' to an unsigned integer (the bit length)
	}
    }
#endif

  // Returning the boolean flag 'ok', indicating whether the function was successful or not
  return ok;
}","The accept_from function processes an argument string, typically representing an IPv6 address with an optional bit length (CIDR format). The function first initializes a bool flag ok to true, which indicates the success of the function. It then checks if the platform supports IPv6 (HAVE_AF_INET6), and if so, proceeds to parse the argument. It attempts to find a '/' character in the string, which separates the address from the bit length in CIDR notation. If a '/' is found, it modifies the input string by terminating it at the '/' and attempts to parse the bit length (if present) into an integer using strtoul. The default bit length is set to the size of an IPv6 address in bits. Finally, the function returns the ok flag, which remains true throughout the function since no specific failure condition is set. This function may be used in applications where an IPv6 address with a specific bit mask is being processed."
"static int
process_args (int argc, char **argv)
{
  // Define the available long options with their associated short options
  static const struct option options[] =
    {
     { ""accept"", required_argument, NULL, 'a' },  // Option '-a' or '--accept' requires an argument
     { ""help"", no_argument, NULL, 'h' },          // Option '-h' or '--help' requires no argument
     { ""map"", no_argument, NULL, 'm' },           // Option '-m' or '--map' requires no argument
     { ""noisy"", no_argument, NULL, 'n' },         // Option '-n' or '--noisy' requires no argument
     { ""one"", no_argument, NULL, '1' },           // Option '-1' or '--one' requires no argument
     { ""root"", required_argument, NULL, 'r' },    // Option '-r' or '--root' requires an argument
     { ""sequential"", no_argument, NULL, 's' },    // Option '-s' or '--sequential' requires no argument
     { ""translate"", no_argument, NULL, 't' },     // Option '-t' or '--translate' requires no argument
     { ""version"", no_argument, NULL, 'v' },       // Option '-v' or '--version' requires no argument
     { 0, 0, 0, 0 }                              // End of options
    };

  int opt;  // Variable to store the current option being processed
  bool bad_accept = false;  // Flag to track if an invalid 'accept' option was encountered
  const char *opts = ""a:fhmn1r:stv"";  // Short option string corresponding to the long options above

  // Loop through the provided arguments and process each one using getopt_long
  while ((opt = getopt_long (argc, argv, opts, options, NULL)) != -1)
    {
      switch (opt)  // Switch statement to handle each option
	{
	case 'a':  // '-a' or '--accept' option
	  if (!accept_from (optarg))  // Call the accept_from function to validate the argument
	    bad_accept = true;  // If invalid, set the bad_accept flag
	  break;
	case 'h':  // '-h' or '--help' option
	  print_usage (false);  // Call print_usage function to show usage information
	  /* print_usage will exit. */
	case 'f': // Deprecated alias for '-h'
	case 'm':  // '-m' or '--map' option
	  flag_map = true;  // Set flag_map to true
	  break;
	case 'n':  // '-n' or '--noisy' option
	  flag_noisy = true;  // Set flag_noisy to true
	  break;
	case '1':  // '-1' or '--one' option
	  flag_one = true;  // Set flag_one to true
	  break;
	case 'r':  // '-r' or '--root' option
	  flag_root = optarg;  // Store the argument value in flag_root
	  break;
	case 's':  // '-s' or '--sequential' option
	  flag_sequential = true;  // Set flag_sequential to true
	  break;
	case 't':  // '-t' or '--translate' option
	  flag_xlate = true;  // Set flag_xlate to true
	  break;
	case 'v':  // '-v' or '--version' option
	  print_version ();  // Call print_version function to display version info
	  /* print_version will exit. */
	default:  // If an unknown option is encountered
	  print_usage (true);  // Call print_usage function to show error message and usage
	  /* print_usage will exit. */
	}
    }

  // If there were invalid 'accept' addresses, print an error message
  if (bad_accept)
    error (""failed to resolve all accept addresses"");

  return optind;  // Return the index of the next argument to be processed
}","The process_args function processes command-line arguments passed to the program, handling both short and long options using getopt_long. It starts by defining a list of available options and their corresponding short forms, followed by a while loop that iterates through each argument. The function checks each option using a switch statement and performs specific actions for each option (e.g., setting flags or calling other functions). Some options, such as -a or --accept, require arguments, and the function verifies their validity (e.g., by calling the accept_from function). If any invalid options are encountered or if there is an issue resolving an accept address, the function prints an error message using print_usage or error and terminates the program. After all options are processed, the function returns the index of the first non-option argument (using optind), which allows further processing of positional arguments."
"static void
term_signal (int sig)
{
  // Reset the signal handler for the specified signal to 'term_signal' itself
  signal (sig, term_signal);

  // Increment the global 'term' variable, possibly counting the number of signals received
  term = term + 1;

  // If the 'term_pipe' is initialized and the write-end of the pipe is open
  if (term_pipe && term_pipe[1] >= 0)
    {
      // Write the value of the write-end pipe to the pipe, possibly signaling other processes
      write (term_pipe[1], &term_pipe[1], 1);
    }
}","The term_signal function is a signal handler that is invoked when a specified signal (e.g., SIGTERM or SIGINT) is received. It first re-registers itself as the handler for the same signal, ensuring that it will be called again if the signal occurs multiple times. Then, it increments a global variable term, which likely tracks the number of times the signal has been received. If the term_pipe pipe is initialized and the write-end of the pipe is open, it writes the value of the write-end (or a status value) to the pipe. This could be used to communicate with other processes, indicating that the signal has been handled or incrementing a termination count. The function ensures that multiple signal occurrences are handled properly by keeping the signal handler active and maintaining communication with other parts of the program via the pipe."
"static void
kill_signal (int sig)
{
  // Reset the signal handler for the specified signal to the default handler (SIG_DFL)
  signal (sig, SIG_DFL);

  // Retrieve the socket file descriptor to be closed
  int sock_fd = kill_sock_fd;

  // If the socket file descriptor is valid (greater than or equal to 0)
  if (sock_fd >= 0)
    {
      // Close the socket to release resources
      close (sock_fd);
    }

  // Exit the program with an exit code of 2, indicating an abnormal termination
  exit (2);
}","The kill_signal function handles a specified signal (e.g., SIGTERM or SIGINT) by performing cleanup and terminating the program. Upon receiving the signal, it first re-registers the signal handler to the default handler (SIG_DFL), which may result in the signal being handled normally thereafter. Next, the function retrieves the socket file descriptor (kill_sock_fd) and, if it is valid (i.e., not negative), closes the socket to release any resources associated with it. Finally, the function terminates the program using exit(2), signaling an abnormal exit (usually indicating an error or forced termination). This function is useful for cleaning up resources and ensuring proper termination when a kill signal is received."
"bool process_server (Cody::Server *server, unsigned slot, int epoll_fd)
{
  // Switch on the direction of the server (READING or WRITING)
  switch (server->GetDirection ())
    {
    case Cody::Server::READING:
      // Attempt to read data from the server
      if (int err = server->Read ())
        // If an error occurs (not EINTR or EAGAIN), return true to indicate failure
        return !(err == EINTR || err == EAGAIN);

      // Process any requests that were read
      server->ProcessRequests ();

      // Prepare the server to switch to writing data
      server->PrepareToWrite ();
      break;

    case Cody::Server::WRITING:
      // Attempt to write data to the server
      if (int err = server->Write ())
        // If an error occurs (not EINTR or EAGAIN), return true to indicate failure
        return !(err == EINTR || err == EAGAIN);

      // Prepare the server to switch to reading data
      server->PrepareToRead ();
      break;

    default:
      // If the server direction is neither READING nor WRITING, it's an error
      // We should never reach here, so return true to indicate failure
      return true;
    }

  // After changing direction, update the epoll event using my_epoll_ctl
  // Ensure the file descriptor for reading and writing is the same before modifying epoll
  gcc_assert (server->GetFDRead () == server->GetFDWrite ());

  // Modify the epoll event to switch between EPOLLIN (READING) and EPOLLOUT (WRITING)
  my_epoll_ctl (epoll_fd, EPOLL_CTL_MOD,
		server->GetDirection () == Cody::Server::READING
		? EPOLLIN : EPOLLOUT, server->GetFDRead (), slot + 1);

  // Return false indicating that the process was successful
  return false;
}","The process_server function is responsible for handling server communication based on the current direction of data flow (either reading or writing). The function first checks the server's direction using GetDirection(). If the server is in the READING state, it attempts to read data by calling server->Read(). If the read operation encounters an error (except for errors like EINTR or EAGAIN, which are typically transient), the function returns true to indicate failure. Once the data is successfully read, it processes the requests using server->ProcessRequests() and prepares to switch to the WRITING state using server->PrepareToWrite().

If the server is in the WRITING state, the function attempts to write data via server->Write(). Similar to the reading case, it handles errors by returning true if the write fails. After successful writing, the server prepares to switch back to reading mode with server->PrepareToRead().

Once the direction is changed, the function updates the epoll event via my_epoll_ctl, modifying the event to either EPOLLIN for reading or EPOLLOUT for writing, depending on the server's direction. The gcc_assert ensures that the file descriptors for reading and writing are the same before modifying the epoll event.

The function returns false if everything proceeds without error, signaling that the process was successful."
"void close_server (Cody::Server *server, int epoll_fd)
{
  // Remove the server's read file descriptor from the epoll monitoring list
  my_epoll_ctl (epoll_fd, EPOLL_CTL_DEL, EPOLLIN, server->GetFDRead (), 0);

  // Close the server's read file descriptor to release resources
  close (server->GetFDRead ());
  
  // Delete the server object to free allocated memory
  delete server;
}","The close_server function is responsible for cleaning up and closing resources associated with a server instance. It first removes the server's read file descriptor from the epoll monitoring list by calling my_epoll_ctl with the EPOLL_CTL_DEL operation, which deletes the specified file descriptor from the epoll set. After ensuring the server is no longer monitored by epoll, it proceeds to close the read file descriptor (server->GetFDRead()) using the close system call, thereby releasing any resources associated with the file descriptor.

Finally, the function deletes the server object to free the allocated memory, effectively cleaning up the server instance. This function is used to properly shut down the server and release all associated resources when they are no longer needed."
"int open_server (bool ip6, int sock_fd)
{
  // Declare the sockaddr_in6 structure to hold client address information
  sockaddr_in6 addr;
  // Define the size of the sockaddr structure
  socklen_t addr_len = sizeof (addr);

#ifdef HAVE_ACCEPT4
  // Use accept4 to accept a connection, with non-blocking mode if available
  int client_fd = accept4 (sock_fd, ip6 ? (sockaddr *)&addr : nullptr,
			   &addr_len, SOCK_NONBLOCK);
#else
  // Use accept for non-blocking connection if accept4 is not available
  int client_fd = accept (sock_fd, ip6 ? (sockaddr *)&addr : nullptr, &addr_len);
#endif
  // Check if the connection was successfully accepted
  if (client_fd < 0)
    {
      // Log the error message and set the flag indicating failure
      error (""cannot accept: %s"", xstrerror (errno));
      flag_one = true;
    }
  else if (ip6) // If IPv6 is being used
    {
      const char *str = NULL;
#if HAVE_INET_NTOP
      // Convert the IPv6 address to a human-readable string format
      char name[INET6_ADDRSTRLEN];
      str = inet_ntop (addr.sin6_family, &addr.sin6_addr, name, sizeof (name));
#endif
      // If there are predefined allowed addresses, check if the client's address is allowed
      if (!accept_addrs.empty ())
	{
	  netmask_vec_t::iterator e = accept_addrs.end ();
	  for (netmask_vec_t::iterator i = accept_addrs.begin ();
	       i != e; ++i)
	    if (i->includes (addr.sin6_addr))
	      goto present; // If the address is allowed, proceed
	  // Close the connection if the source address is not allowed
	  close (client_fd);
	  client_fd = -1;
	  // Log the rejection of the connection from a disallowed source
	  noisy (""Rejecting connection from disallowed source '%s'"",
		 str ? str : """");
	present:;
	}
      // Log the acceptance of the connection from the allowed source
      if (client_fd >= 0)
	flag_noisy && noisy (""Accepting connection from '%s'"", str ? str : """");
    }

  // Return the file descriptor for the accepted client connection
  return client_fd;
}","The open_server function is responsible for accepting incoming client connections to a server, either over IPv6 or IPv4, depending on the ip6 flag. It first attempts to accept a connection using either the accept4 system call (if available) or the traditional accept call. The function uses sockaddr_in6 to store the client's IPv6 address and checks the success of the connection. If the connection fails, an error is logged, and a flag (flag_one) is set to indicate failure.

If the connection is successful and IPv6 is being used, the function checks if the client's address is among the allowed addresses stored in accept_addrs. If the address is not allowed, the connection is closed, and the client is rejected. The function logs the rejection and proceeds to the next iteration. If the address is allowed, it logs the acceptance of the connection.

The function returns the client file descriptor (client_fd), which can be used for further communication with the client. This function is critical in managing incoming connections to the server, ensuring that only connections from allowed addresses are accepted, and properly handling connection failures."
"static int maybe_parse_socket (std::string &option, module_resolver *r)
{
  // Find the last occurrence of '?' in the option string to check for an identifier
  auto last = option.find_last_of ('?');
  
  // If '?' is found, extract the identifier part and set it using the resolver
  if (last != option.npos)
    {
      r->set_ident (option.c_str () + last + 1); // Set the identifier in the module resolver
      option.erase (last); // Remove the identifier part from the option string
    }

  // Initialize the file descriptor to an invalid value (-2) and error message to nullptr
  int fd = -2;
  char const *errmsg = nullptr;

  // Check if the option starts with '=' indicating it might be a local socket
  if (option[0] == '=')
    {
      // Try to listen on a local socket, skipping the '=' character
#if CODY_NETWORKING
      fd = Cody::ListenLocal (&errmsg, option.c_str () + 1);
#endif
    }
  else
    {
      // Find the last occurrence of ':' to check if it's a hostname:port format
      auto colon = option.find_last_of (':');
      
      // If ':' is found, try parsing it as a hostname:port address
      if (colon != option.npos)
	{
	  // Extract the port part from the string and try to convert it to an unsigned integer
	  char const *cptr = option.c_str () + colon;
	  char *endp;
	  unsigned port = strtoul (cptr + 1, &endp, 10);

	  // If the port is valid (not 0) and the conversion ends correctly, treat it as an IPv6 domain socket
	  if (port && endp != cptr + 1 && !*endp)
	    {
	      // Remove the hostname part (before ':') to leave just the address
	      option.erase (colon);
	      
	      // Try to listen on an IPv6 socket with the specified port and address
#if CODY_NETWORKING
	      fd = Cody::ListenInet6 (&errmsg, option.c_str (), port);
#endif
	    }
	}
    }

  // If there was an error opening the socket, log it and exit
  if (errmsg)
    error (""failed to open socket: %s"", errmsg);

  // Return the file descriptor for the socket (or -2 if there was an error)
  return fd;
}","The maybe_parse_socket function is responsible for parsing a string representing a socket address, which could either be a local socket, an IPv6 domain socket, or a hostname:port address. The function first checks for an optional identifier at the end of the address (after a ? character) and sets it using the module_resolver object if present.

The function then processes the address string. If the string starts with an =, it treats the address as a local socket and attempts to listen on it using the Cody::ListenLocal function. If the string contains a :, the function assumes it could be a hostname and port, and tries to parse the port number. If the port is valid and the address is in the correct format, it treats it as an IPv6 domain socket and attempts to listen on it using Cody::ListenInet6.

If there is an error while opening the socket, the function logs the error message and returns an invalid file descriptor (-2). Otherwise, it returns the valid file descriptor for the socket. This function is part of a larger system that deals with socket management, including local and remote addresses, and it ensures proper handling of different socket types based on the input format.






"
"void real_c_float::from_str (const char *s)
{
  REAL_VALUE_TYPE f; // Declare a variable to hold the floating-point value
  const char *p = s; // Pointer to traverse the input string

  // Check if the string starts with a sign ('-' or '+')
  if (*p == '-' || *p == '+')
    p++; // Skip the sign character

  // Check if the string represents infinity (case insensitive)
  if (strcasecmp(p, ""inf"") == 0)
    {
      real_inf (&f); // Set the value to infinity
      // If the original string had a negative sign, negate the infinity
      if (*s == '-')
        real_arithmetic (&f, NEGATE_EXPR, &f, NULL);
    }
  // Check if the string represents ""nan"" (case insensitive)
  else if (strcasecmp(p, ""nan"") == 0)
    real_nan (&f, """", 1, MODE); // Set the value to NaN (Not a Number)
  else
    real_from_string (&f, s); // Convert the string to a real floating-point value

  // Convert the real value to the target format (e.g., internal representation)
  real_to_target (image, &f, MODE);
}","The from_str function is a method of the real_c_float class that converts a string representation of a floating-point number into a real value, which is then converted to the target format. The function first checks if the input string represents special values like ""inf"" (infinity) or ""nan"" (Not a Number).

If the string starts with a sign ('-' or '+'), it is skipped to handle the number correctly.
If the string matches ""inf"" (case-insensitive), it sets the floating-point value to infinity. If the original string had a negative sign, the infinity value is negated.
If the string matches ""nan"" (case-insensitive), the floating-point value is set to NaN (Not a Number).
For other cases, the function assumes the string represents a regular floating-point number and converts it to a real value using real_from_string.
Finally, the resulting real value is converted to the target format using the real_to_target function, which likely prepares it for further processing or storage."
"void
real_c_float::binop (int code, const real_c_float &b)
{
  // Declare variables to hold the real values of the operands and result.
  REAL_VALUE_TYPE ai, bi, ri;

  // Convert the current object (this->image) into a real value and store it in ai.
  real_from_target (&ai, image, MODE);

  // Convert the operand b's image into a real value and store it in bi.
  real_from_target (&bi, b.image, MODE);

  // Perform the binary operation specified by 'code' on ai and bi, store the result in ri.
  real_arithmetic (&ri, code, &ai, &bi);

  // Convert the result back into the target image (this->image).
  real_to_target (image, &ri, MODE);

  // If verbose output is enabled, print a detailed log of the operation.
  if (verbose)
    {
      // Arrays to hold the hexadecimal representations of the operands and result.
      char ab[64], bb[64], rb[64];

      // Get the real format for the current mode (e.g., QFmode).
      const real_format *fmt = real_format_for_mode[MODE - QFmode];

      // Calculate the number of digits required for hexadecimal representation.
      const int digits = (fmt->p * fmt->log2_b + 3) / 4;

      // Declare a character variable to hold the operator symbol.
      char symbol_for_code;

      // Convert the real value ai to its hexadecimal string representation.
      real_to_hexadecimal (ab, &ai, sizeof(ab), digits, 0);

      // Convert the real value bi to its hexadecimal string representation.
      real_to_hexadecimal (bb, &bi, sizeof(bb), digits, 0);

      // Convert the result (ri) to its hexadecimal string representation.
      real_to_hexadecimal (rb, &ri, sizeof(rb), digits, 0);

      // Determine the operator symbol based on the operation code (PLUS_EXPR, MINUS_EXPR, etc.).
      switch (code)
	{
	case PLUS_EXPR:
	  symbol_for_code = '+';  // Addition
	  break;
	case MINUS_EXPR:
	  symbol_for_code = '-';  // Subtraction
	  break;
	case MULT_EXPR:
	  symbol_for_code = '*';  // Multiplication
	  break;
	case RDIV_EXPR:
	  symbol_for_code = '/';  // Division
	  break;
	default:
	  abort ();  // Abort if an unknown operation code is encountered.
	}

      // Print a detailed log of the operation, showing operands, operator, and result.
      fprintf (stderr, ""%6d: %s %c %s = %s\n"", verbose_index++,
	       ab, symbol_for_code, bb, rb);
    }
}","The real_c_float::binop function performs a binary arithmetic operation (addition, subtraction, multiplication, or division) on the current object (this) and another real_c_float object (b). It converts the real-valued operands from their internal representation (image) into a format suitable for arithmetic computation, performs the specified operation, and then converts the result back into the internal representation of the current object. If verbose output is enabled, the function also logs detailed information about the operation, including the operands in hexadecimal format, the operation performed, and the result. The function uses the real_from_target, real_arithmetic, and real_to_target helper functions to handle the real-number arithmetic and conversion processes. The operator symbol (+, -, *, /) is chosen based on the operation code passed to the function (code)."
"void
real_c_float::unop (int code)
{
  // Declare variables to hold the operand and result values.
  REAL_VALUE_TYPE ai, ri;

  // Convert the current object's image into a real value and store it in ai.
  real_from_target (&ai, image, MODE);

  // Perform the unary operation specified by 'code' on ai, store the result in ri.
  real_arithmetic (&ri, code, &ai, NULL);

  // Convert the result back into the target image (this->image).
  real_to_target (image, &ri, MODE);

  // If verbose output is enabled, print a detailed log of the operation.
  if (verbose)
    {
      // Arrays to hold the hexadecimal representations of the operand and result.
      char ab[64], rb[64];

      // Get the real format for the current mode (e.g., QFmode).
      const real_format *fmt = real_format_for_mode[MODE - QFmode];

      // Calculate the number of digits required for hexadecimal representation.
      const int digits = (fmt->p * fmt->log2_b + 3) / 4;

      // Declare a pointer to hold the operator symbol as a string.
      const char *symbol_for_code;

      // Convert the real value ai to its hexadecimal string representation.
      real_to_hexadecimal (ab, &ai, sizeof(ab), digits, 0);

      // Convert the result (ri) to its hexadecimal string representation.
      real_to_hexadecimal (rb, &ri, sizeof(rb), digits, 0);

      // Determine the operator symbol based on the operation code (NEGATE_EXPR, ABS_EXPR, etc.).
      switch (code)
	{
	case NEGATE_EXPR:
	  symbol_for_code = ""-"";  // Negation
	  break;
	case ABS_EXPR:
	  symbol_for_code = ""abs "";  // Absolute value
	  break;
	default:
	  abort ();  // Abort if an unknown operation code is encountered.
	}

      // Print a detailed log of the operation, showing the operand, operator, and result.
      fprintf (stderr, ""%6d: %s%s = %s\n"", verbose_index++,
	       symbol_for_code, ab, rb);
    }
}
","The real_c_float::unop function performs a unary arithmetic operation (negation or absolute value) on the current object's real value (image). It first converts the internal representation (image) of the current object into a real value and then applies the unary operation specified by the code argument. The result of the operation is stored back in the internal representation of the object. If verbose output is enabled, the function logs detailed information, including the operand in hexadecimal format, the operation performed, and the resulting value. The operator symbol (- for negation, abs for absolute value) is selected based on the operation code. The function uses helper functions such as real_from_target, real_arithmetic, and real_to_target for performing the arithmetic and handling the conversion between formats. If an unrecognized operation code is encountered, the function aborts."
"bool
real_c_float::cmp (int code, const real_c_float &b) const
{
  // Declare variables to hold the operand values for comparison and the result.
  REAL_VALUE_TYPE ai, bi;
  bool ret;

  // Convert the current object's image to a real value and store it in ai.
  real_from_target (&ai, image, MODE);

  // Convert the provided object's image (b.image) to a real value and store it in bi.
  real_from_target (&bi, b.image, MODE);

  // Perform the comparison specified by the code (LT_EXPR, EQ_EXPR, etc.).
  ret = real_compare (code, &ai, &bi);

  // If verbose output is enabled, print detailed information about the comparison.
  if (verbose)
    {
      // Arrays to hold the hexadecimal representations of the operands.
      char ab[64], bb[64];

      // Get the real format for the current mode (e.g., QFmode).
      const real_format *fmt = real_format_for_mode[MODE - QFmode];

      // Calculate the number of digits required for hexadecimal representation.
      const int digits = (fmt->p * fmt->log2_b + 3) / 4;

      // Declare a pointer to hold the comparison operator as a string.
      const char *symbol_for_code;

      // Convert the real values ai and bi to their hexadecimal string representations.
      real_to_hexadecimal (ab, &ai, sizeof(ab), digits, 0);
      real_to_hexadecimal (bb, &bi, sizeof(bb), digits, 0);

      // Determine the comparison operator symbol based on the comparison code.
      switch (code)
	{
	case LT_EXPR:
	  symbol_for_code = ""<"";  // Less than
	  break;
	case LE_EXPR:
	  symbol_for_code = ""<="";  // Less than or equal to
	  break;
	case EQ_EXPR:
	  symbol_for_code = ""=="";  // Equal to
	  break;
	case NE_EXPR:
	  symbol_for_code = ""!="";  // Not equal to
	  break;
	case GE_EXPR:
	  symbol_for_code = "">="";  // Greater than or equal to
	  break;
	case GT_EXPR:
	  symbol_for_code = "">"";  // Greater than
	  break;
	default:
	  abort ();  // Abort if an unknown comparison code is encountered.
	}

      // Print the comparison operation, showing the operands, operator, and result.
      fprintf (stderr, ""%6d: %s %s %s = %s\n"", verbose_index++,
	       ab, symbol_for_code, bb, (ret ? ""true"" : ""false""));
    }

  // Return the result of the comparison (true or false).
  return ret;
}","The real_c_float::cmp function compares the current object's real value (image) with the real value of another real_c_float object (b) based on the specified comparison code (LT_EXPR, EQ_EXPR, etc.). It first converts the image of both objects into real values (ai and bi). The comparison operation is then performed using the helper function real_compare, which returns a boolean result (true or false). If verbose logging is enabled, the function prints detailed information about the comparison, including the hexadecimal representations of the operands and the result, along with the operator symbol (e.g., <, ==, >). The result of the comparison (true or false) is returned. If an unrecognized comparison code is encountered, the function aborts."
"const char *
real_c_float::str() const
{
  // Declare a variable to hold the real value.
  REAL_VALUE_TYPE f;

  // Get the real format for the current mode (e.g., QFmode).
  const real_format *fmt = real_format_for_mode[MODE - QFmode];

  // Calculate the number of digits required for decimal representation based on the format.
  const int digits = int(fmt->p * fmt->log2_b * .30102999566398119521 + 1);

  // Convert the real value from the current image to the real value f.
  real_from_target (&f, image, MODE);

  // Allocate memory for a buffer to hold the decimal string representation of the real value.
  // The buffer size is calculated as digits + 10 to allow for sufficient space.
  char *buf = new char[digits + 10];

  // Convert the real value f to a decimal string and store it in buf.
  // The buffer can hold digits + 10 characters, and the specified number of digits is used for precision.
  real_to_decimal (buf, &f, digits + 10, digits, 0);

  // Return the buffer containing the decimal string representation of the real value.
  return buf;
}","The real_c_float::str function converts the real value stored in the image (the internal representation) into its decimal string representation. The function first retrieves the appropriate real format based on the current mode (e.g., QFmode). It then calculates the number of digits required for the decimal representation of the real number based on the logarithmic base and precision defined by the real format. The real value is extracted from the image using real_from_target. A buffer is allocated dynamically to store the string, with space for the calculated number of digits plus a small buffer margin. The real value is then converted to a decimal string using real_to_decimal and stored in the buffer. Finally, the function returns the buffer containing the string representation of the real number. Note that this function uses dynamic memory allocation, and the caller is responsible for managing the memory."
"const char *
real_c_float::hex() const
{
  // Declare a variable to hold the real value.
  REAL_VALUE_TYPE f;

  // Get the real format for the current mode (e.g., QFmode).
  const real_format *fmt = real_format_for_mode[MODE - QFmode];

  // Calculate the number of digits required for hexadecimal representation based on the format.
  // The formula adjusts the precision by considering the logarithmic base.
  const int digits = (fmt->p * fmt->log2_b + 3) / 4;

  // Convert the real value from the current image to the real value f.
  real_from_target (&f, image, MODE);

  // Allocate memory for a buffer to hold the hexadecimal string representation of the real value.
  // The buffer size is calculated as digits + 10 to allow for sufficient space.
  char *buf = new char[digits + 10];

  // Convert the real value f to a hexadecimal string and store it in buf.
  // The buffer can hold digits + 10 characters, and the specified number of digits is used for precision.
  real_to_hexadecimal (buf, &f, digits + 10, digits, 0);

  // Return the buffer containing the hexadecimal string representation of the real value.
  return buf;
}","The real_c_float::hex function converts the real value stored in the image into its hexadecimal string representation. The function first retrieves the appropriate real format based on the current mode (e.g., QFmode). It then calculates the number of digits required for the hexadecimal representation, considering the precision and logarithmic base defined by the real format. The real value is extracted from the image using real_from_target. A buffer is dynamically allocated to store the string, with enough space for the calculated digits plus an additional margin. The real value is then converted to a hexadecimal string using real_to_hexadecimal and stored in the buffer. Finally, the function returns the buffer containing the hexadecimal string representation of the real number. Like the str() function, this method uses dynamic memory allocation, and the caller is responsible for managing the memory."
"void
real_c_float::ldexp (int exp)
{
  // Declare a variable to hold the real value extracted from the 'image'.
  REAL_VALUE_TYPE ai;

  // Convert the real value from the 'image' into the variable 'ai' based on the current mode.
  real_from_target (&ai, image, MODE);

  // Perform the ldexp operation, which multiplies the real value by 2 raised to the power of 'exp'.
  // The result is stored back in 'ai'.
  real_ldexp (&ai, &ai, exp);

  // Convert the modified real value back into the 'image' in the current mode.
  real_to_target (image, &ai, MODE);
}
","The real_c_float::ldexp function performs the ldexp (floating-point exponentiation) operation on the real value stored in the image. This operation multiplies the real number by 2 raised to the power of exp, where exp is the exponent provided as an argument to the function. The function first extracts the real value from the image using real_from_target, and then the real_ldexp function is used to apply the exponentiation, updating the value in ai. After the operation, the result is stored back into the image using real_to_target. The ldexp function is typically used to scale a floating-point number by a power of two efficiently."
"tree
remove_ssa_names (tree expr)
{
  // Check if the expression is an SSA_NAME and if it is associated with a variable.
  if (TREE_CODE (expr) == SSA_NAME && SSA_NAME_VAR (expr))
    // If it is an SSA_NAME associated with a variable, return the variable itself.
    return SSA_NAME_VAR (expr);

  // Create a copy of the original expression to process further.
  tree t = copy_node (expr);

  // Iterate through all the operands of the expression.
  for (int i = 0; i < TREE_OPERAND_LENGTH (expr); i++)
    if (TREE_OPERAND (expr, i))  // Check if the operand is not NULL.
      // Recursively remove SSA names from each operand and assign the processed operand to the copy.
      TREE_OPERAND (t, i) = remove_ssa_names (TREE_OPERAND (expr, i));

  // Return the processed copy of the expression with SSA names removed.
  return t;
}
","The remove_ssa_names function is designed to traverse a given tree expression and remove any references to SSA (Static Single Assignment) names, replacing them with the associated variables. The function checks if the current expression is an SSA name and, if so, directly returns the corresponding variable. If the expression is more complex (i.e., not a simple SSA name), it creates a copy of the expression and recursively processes all of its operands by calling remove_ssa_names on each operand. This ensures that SSA names are eliminated throughout the entire tree, and the resulting tree contains only variables and their operations, making it easier for further analysis or transformations in compiler optimizations or intermediate representations."
"std::unique_ptr<text_art::styled_string>
bit_size_expr::maybe_get_formatted_str (text_art::style_manager &sm,
					const region_model &model,
					const char *concrete_single_bit_fmt,
					const char *concrete_plural_bits_fmt,
					const char *concrete_single_byte_fmt,
					const char *concrete_plural_bytes_fmt,
					const char *symbolic_bits_fmt,
					const char *symbolic_bytes_fmt) const
{
  // Get the region model manager from the provided model.
  region_model_manager &mgr = *model.get_manager ();

  // Check if the expression can be represented as bytes.
  if (const svalue *num_bytes = maybe_get_as_bytes (mgr))
    {
      // If the number of bytes can be obtained as a constant.
      if (tree cst = num_bytes->maybe_get_constant ())
	{
	  // Convert the constant value to a byte_size_t.
	  byte_size_t concrete_num_bytes = wi::to_offset (cst);
	  
	  // Check if the byte size fits in an unsigned wide integer.
	  if (!wi::fits_uhwi_p (concrete_num_bytes))
	    return nullptr;
	  
	  // Format and return a styled string based on the byte count.
	  if (concrete_num_bytes == 1)
	    return ::make_unique <text_art::styled_string>
	      (fmt_styled_string (sm, concrete_single_byte_fmt,
				  concrete_num_bytes.to_uhwi ()));
	  else
	    return ::make_unique <text_art::styled_string>
	      (fmt_styled_string (sm, concrete_plural_bytes_fmt,
				  concrete_num_bytes.to_uhwi ()));
	}
      else
	{
	  // If the number of bytes is not a constant, print a symbolic representation.
	  pretty_printer pp;
	  pp_format_decoder (&pp) = default_tree_printer;
	  
	  // Attempt to print the number of bytes for the user.
	  if (!num_bytes->maybe_print_for_user (&pp, model))
	    return nullptr;
	  
	  // Return a styled string with the symbolic byte representation.
	  return ::make_unique <text_art::styled_string>
	    (fmt_styled_string (sm, symbolic_bytes_fmt,
				pp_formatted_text (&pp)));
	}
    }
  // If the expression can be represented as a number of bits.
  else if (tree cst = m_num_bits.maybe_get_constant ())
    {
      // Convert the constant value to a bit_size_t.
      bit_size_t concrete_num_bits = wi::to_offset (cst);
      
      // Check if the bit size fits in an unsigned wide integer.
      if (!wi::fits_uhwi_p (concrete_num_bits))
	return nullptr;
      
      // Format and return a styled string based on the bit count.
      if (concrete_num_bits == 1)
	return ::make_unique <text_art::styled_string>
	  (fmt_styled_string (sm, concrete_single_bit_fmt,
			      concrete_num_bits.to_uhwi ()));
      else
	return ::make_unique <text_art::styled_string>
	  (fmt_styled_string (sm, concrete_plural_bits_fmt,
			      concrete_num_bits.to_uhwi ()));
    }
  else
    {
      // If neither the number of bytes nor the number of bits is constant, print a symbolic representation.
      pretty_printer pp;
      pp_format_decoder (&pp) = default_tree_printer;
      
      // Attempt to print the number of bits for the user.
      if (!m_num_bits.maybe_print_for_user (&pp, model))
	return nullptr;
      
      // Return a styled string with the symbolic bit representation.
      return ::make_unique <text_art::styled_string>
	(fmt_styled_string (sm, symbolic_bits_fmt,
			    pp_formatted_text (&pp)));
    }
}","The maybe_get_formatted_str function is responsible for obtaining a formatted string representation of a bit size expression, either in terms of bytes or bits, based on whether the expression is constant or symbolic. It first attempts to retrieve the expression as a byte value and formats the output using either a concrete byte format or a symbolic representation, depending on the availability of a constant value. If the byte representation is not available, the function falls back to checking the number of bits, following a similar process for formatting. If the number of bits is symbolic, the function uses a symbolic format. It ensures that the expression fits into an unsigned wide integer before formatting and returns the formatted string as a std::unique_ptr<text_art::styled_string>. This function handles different scenarios for displaying the bit size in a user-friendly and formatted manner, either for individual bits or bytes or their plural forms, and employs the pretty_printer for symbolic cases."
"bool
bit_size_expr::maybe_print_for_user (pretty_printer *pp,
				     const region_model &model) const
{
  // Check if the number of bits can be obtained as a constant.
  if (tree cst = m_num_bits.maybe_get_constant ())
    {
      // Convert the constant value to bit_size_t and print it.
      bit_size_t concrete_num_bits = wi::to_offset (cst);
      pp_bit_size_t (pp, concrete_num_bits);
      return true;
    }
  else
    {
      // If not a constant, check if the expression can be represented as bytes.
      if (const svalue *num_bytes = maybe_get_as_bytes (*model.get_manager ()))
	{
	  // Create a temporary pretty printer for the byte representation.
	  pretty_printer tmp_pp;
	  pp_format_decoder (&tmp_pp) = default_tree_printer;
	  
	  // If the number of bytes can be printed for the user, format the output.
	  if (!num_bytes->maybe_print_for_user (&tmp_pp, model))
	    return false;
	  
	  // Print the formatted byte value.
	  pp_printf (pp, _(""%qs bytes""), pp_formatted_text (&tmp_pp));
	  return true;
	}
      else
	{
	  // If not bytes, print the bit representation.
	  pretty_printer tmp_pp;
	  pp_format_decoder (&tmp_pp) = default_tree_printer;
	  
	  // If the number of bits can be printed for the user, format the output.
	  if (!m_num_bits.maybe_print_for_user (&tmp_pp, model))
	    return false;
	  
	  // Print the formatted bit value.
	  pp_printf (pp, _(""%qs bits""), pp_formatted_text (&tmp_pp));
	  return true;
	}
    }
}","The maybe_print_for_user function is designed to print a bit size expression for the user, either as bytes or bits. First, it checks if the number of bits is available as a constant and, if so, prints the concrete value in a formatted manner. If the number of bits is not constant, the function checks if the expression can be interpreted as a number of bytes. If so, it formats the byte value for the user. If neither the number of bits nor the number of bytes can be printed directly, it prints the number of bits. The function employs a pretty_printer to handle formatting and printing the expression. It returns true if the printing was successful and false if there was an issue with printing the value. The function adapts its output based on whether the expression is represented in terms of bytes or bits, ensuring user-friendly presentation."
"const svalue *
bit_size_expr::maybe_get_as_bytes (region_model_manager &mgr) const
{
  // Check if the number of bits can be obtained as a constant.
  if (tree cst = m_num_bits.maybe_get_constant ())
    {
      // Convert the constant value to bit_offset_t.
      bit_offset_t concrete_bits = wi::to_offset (cst);
      
      // If the number of bits is not an exact multiple of BITS_PER_UNIT (i.e., not divisible by 8), return nullptr.
      if (concrete_bits % BITS_PER_UNIT != 0)
	/* Not an exact multiple, so fail.  */
	return nullptr;
    }

  // Get the number of bits per byte (i.e., 8 bits per byte).
  const svalue *bits_per_byte
    = mgr.get_or_create_int_cst (NULL_TREE, BITS_PER_UNIT);
  
  // Attempt to divide the number of bits by the number of bits per byte (BITS_PER_UNIT) and return the result as bytes.
  return mgr.maybe_fold_binop (NULL_TREE, EXACT_DIV_EXPR,
			       &m_num_bits, bits_per_byte);
}","The maybe_get_as_bytes function attempts to convert the bit size expression (m_num_bits) into a byte size. First, it checks whether the number of bits is a constant. If the number of bits is constant, it verifies that the value is a multiple of BITS_PER_UNIT (which is typically 8, representing the number of bits in a byte). If it's not divisible by BITS_PER_UNIT, the function returns nullptr, indicating that the conversion cannot be performed.

If the number of bits is divisible by BITS_PER_UNIT, the function proceeds by retrieving the constant value for bits per byte and attempts to perform a division to convert the number of bits into the corresponding number of bytes using a binary operation (EXACT_DIV_EXPR). The result is returned as an svalue representing the byte size.

The function is part of a process that facilitates converting bit size expressions into byte size, which can be helpful for optimizing memory usage or understanding data representation in a more user-friendly format (bytes instead of bits)."
"bool
access_range::empty_p () const
{
  // Create a concrete bit range with a start of 0 and end of 0.
  bit_range concrete_bits (0, 0);
  
  // Check if the access range can be represented as a concrete bit range.
  if (!as_concrete_bit_range (&concrete_bits))
    return false;  // If it can't, the range is not empty, return false.
  
  // If the concrete bit range is valid, check if it's empty.
  return concrete_bits.empty_p ();
}","The empty_p function checks whether the current access range is empty. It first creates a bit_range object (concrete_bits) initialized to a range from 0 to 0. It then attempts to convert the current access range to a concrete bit range using the as_concrete_bit_range method. If the conversion fails (i.e., the current access range can't be represented as a concrete bit range), the function returns false, indicating the access range is not empty. If the conversion is successful, it checks whether the concrete_bits range is empty using its empty_p() method and returns the result.

This method is typically used to verify if an access range has no valid bits, meaning it doesn't span any valid memory region or data."
"void
access_range::dump_to_pp (pretty_printer *pp, bool simple) const
{
  // Check if both start and next offsets are concrete (i.e., they represent actual values).
  if (m_start.concrete_p () && m_next.concrete_p ())
    {
      // Create a bit range representing the span between the start and next offsets.
      bit_range bits (m_start.get_bit_offset (),
		      m_next.get_bit_offset () - m_start.get_bit_offset ());
      
      // Dump the bit range to the pretty printer.
      bits.dump_to_pp (pp);
      return;  // Exit the function after printing the concrete bit range.
    }
  
  // If the offsets are not concrete, print the start and next offsets in a more verbose format.
  pp_character (pp, '[');  // Print opening bracket.
  m_start.dump_to_pp (pp, simple);  // Dump the start offset.
  pp_string (pp, "" to "");  // Print "" to "".
  m_next.dump_to_pp (pp, simple);  // Dump the next offset.
  pp_character (pp, ')');  // Print closing bracket.
}","The dump_to_pp function prints a representation of the access range to the provided pretty_printer. If both the m_start and m_next members are concrete (i.e., they represent actual, fixed values), the function creates a bit_range using the m_start and m_next values, calculates the difference between them, and prints this bit range.

If either the m_start or m_next is not concrete, the function prints the range in a more verbose, human-readable format. It prints the m_start value, followed by "" to "" and the m_next value, enclosed in square brackets. This is typically used for debugging or presenting access ranges in a readable form.

The simple parameter controls the verbosity of the printed output."
"void
access_range::log (const char *title, logger &logger) const
{
  // Start a new log line.
  logger.start_log_line ();

  // Log the title followed by a colon.
  logger.log_partial (""%s: "", title);

  // Dump the access range in a simple format (controlled by 'true').
  dump_to_pp (logger.get_printer (), true);

  // End the log line after the access range is printed.
  logger.end_log_line ();
}","The log function logs the access range with an optional title using the provided logger object. The function starts a new log line using start_log_line(), then logs the title followed by a colon using log_partial(). It then calls dump_to_pp() to print the access range in a simple format (as controlled by the true argument), and finally, it ends the log line with end_log_line().

This function is typically used for logging access range information with a specific title for better context in the logs, especially during debugging or tracking. The use of a simple format (true argument in dump_to_pp) ensures that the output is not overly verbose."
"access_range
access_operation::get_valid_bits () const
{
  // Retrieve the capacity in bytes for the base region from the model.
  const svalue *capacity_in_bytes_sval = m_model.get_capacity (m_base_region);

  // Return an access range that spans from the start of the region to its byte offset.
  return access_range
    (region_offset::make_concrete (m_base_region, 0), // Start at the beginning of the base region.
     region_offset::make_byte_offset (m_base_region, capacity_in_bytes_sval), // End at the byte offset of the region capacity.
     *get_manager ()); // Get the manager for the operation.
}","The get_valid_bits() function in the access_operation class calculates and returns an access_range that defines the valid bits for a particular access operation. It first retrieves the capacity of the base region in bytes from the model (m_model.get_capacity). Using the retrieved capacity, the function constructs an access range that starts from the beginning of the region and ends at the byte offset corresponding to the capacity of the region. The access range is constructed using the region_offset::make_concrete() and region_offset::make_byte_offset() methods, and it is associated with the manager returned by get_manager(). This function ensures that the valid bits correspond to the capacity of the region being accessed."
"bool
access_operation::maybe_get_invalid_before_bits (access_range *out) const
{
  // Retrieve the valid and actual bits for the current access operation.
  access_range valid_bits (get_valid_bits ());
  access_range actual_bits (get_actual_bits ());

  // Check if any part of the accessed range is before the valid range.
  if (actual_bits.m_start >= valid_bits.m_start)
    {
      // No part of accessed range is before the valid range.
      return false;
    }
  else if (actual_bits.m_next > valid_bits.m_start)
    {
      // If part of the accessed range overlaps with the valid range, get the invalid bits before the valid range.
      *out = access_range (actual_bits.m_start, valid_bits.m_start, *get_manager ());
      return true;
    }
  else
    {
      // If the accessed range is entirely before the valid range, return the entire accessed range as invalid.
      *out = actual_bits;
      return true;
    }
}","The maybe_get_invalid_before_bits() function in the access_operation class determines if there are any ""invalid"" bits before the valid range for a given access operation. It compares the actual_bits (the bits being accessed) and the valid_bits (the valid bits range for the operation).

If the accessed range starts at or beyond the valid range (actual_bits.m_start >= valid_bits.m_start), then there are no invalid bits before the valid range, and the function returns false.
If part of the accessed range overlaps with the valid range (actual_bits.m_next > valid_bits.m_start), the function sets out to the portion of the accessed range before the valid range.
If the accessed range is entirely before the valid range (actual_bits.m_next <= valid_bits.m_start), the entire accessed range is considered invalid, and it sets out to the whole actual_bits range.
The function returns true when it successfully identifies invalid bits before the valid range, and false when there are no such invalid bits."
"bool
access_operation::maybe_get_invalid_after_bits (access_range *out) const
{
  // Get the valid range of bits from the access operation
  access_range valid_bits (get_valid_bits ());
  
  // Get the actual range of bits accessed in this operation
  access_range actual_bits (get_actual_bits ());

  // Check if the accessed range is completely within the valid range
  if (actual_bits.m_next <= valid_bits.m_next)
    {
      // If the accessed range does not extend beyond the valid range, return false
      /* No part of accessed range is after the valid range. */
      return false;
    }
  // Check if part of the accessed range overlaps with the valid range
  else if (actual_bits.m_start < valid_bits.m_next)
    {
      // If part of the accessed range is after the valid range, create an invalid range
      /* Get part of accessed range that's after the valid range. */
      *out = access_range (valid_bits.m_next, actual_bits.m_next,
                           *get_manager ());  // Create a new access range from the valid end to the accessed end
      return true;  // Return true to indicate an invalid range was found
    }
  else
    {
      // If the accessed range is fully after the valid range, assign it to the output
      /* Accessed range is fully after valid range. */
      *out = actual_bits;  // Assign the full accessed range as invalid
      return true;  // Return true to indicate an invalid range was found
    }
}","The maybe_get_invalid_after_bits function checks if any part of the accessed bit range falls after the valid bit range and, if so, returns the invalid part of the range. It compares the m_next values of the valid and accessed ranges to determine if the accessed range is entirely within, overlaps with, or extends beyond the valid range. If part or all of the accessed range is invalid (i.e., falls after the valid range), the function creates a new access_range to represent the invalid range and returns true. Otherwise, it returns false, indicating that there is no invalid part of the accessed range after the valid range. This function helps in managing and tracking invalid accesses within a given range."
"void add (const access_range &range, enum kind kind)
{
  // Add the starting point of the access range
  add (range.m_start, kind);

  // Add the ending point of the access range
  add (range.m_next, kind);

  // If logging is enabled (m_logger is not null)
  if (m_logger)
    {
      // Start a new log line
      m_logger->start_log_line ();
      
      // Log the message indicating an access range has been added
      m_logger->log_partial (""added access_range: "");
      
      // Dump the access range to the logger for further details
      range.dump_to_pp (m_logger->get_printer (), true);
      
      // Log the kind of access range (HARD or soft)
      m_logger->log_partial ("" (%s)"",
                             (kind == boundaries::kind::HARD)
                             ? ""HARD"" : ""soft"");
      
      // End the log line
      m_logger->end_log_line ();
    }
}","The add function adds the start and end points of an access_range to an internal structure, based on the specified kind (either HARD or soft). If logging is enabled (m_logger is not nullptr), the function logs detailed information about the access range being added, including the range itself and its type (HARD or soft). This function is useful for managing and tracking access ranges while providing logging capabilities for debugging or auditing access events. It ensures that both the start and end of the range are added, and if applicable, the access type is logged for future reference."
"void add_all_bytes_in_range (const byte_range &bytes)
{
  // Iterate over each byte in the given byte range
  for (byte_offset_t byte_idx = bytes.get_start_byte_offset ();
       byte_idx <= bytes.get_next_byte_offset ();  // Loop until the end of the byte range
       byte_idx = byte_idx + 1)  // Increment the byte index by 1
    {
      // Add each byte's corresponding bit offset (byte_idx * 8) with the kind SOFT
      add (region_offset::make_concrete (&m_base_reg, byte_idx * 8),
           kind::SOFT);
    }
}","The add_all_bytes_in_range function iterates over a specified byte range (byte_range object) and adds each byte's corresponding bit offset to an internal structure. The offset for each byte is computed by multiplying the byte index by 8, as the function is working with bit offsets (8 bits per byte). The access type for each byte is set to SOFT. This function is used to process and track all the bytes within a given range, ensuring that each byte's position is added and categorized accordingly. It operates byte by byte, making it useful for dealing with fine-grained memory or data access patterns."
"void log (logger &logger) const
{
  // Log the ""boundaries:"" label to indicate the start of boundary logging
  logger.log (""boundaries:"");

  // Increase the indentation level for the following log entries
  logger.inc_indent ();

  // Iterate through each offset in the m_all_offsets collection
  for (auto offset : m_all_offsets)
    {
      // Determine the kind (HARD or soft) for the current offset
      enum kind k = get_kind (offset);

      // Start a new log line for the current boundary
      logger.start_log_line ();

      // Log the kind of boundary (either ""HARD"" or ""soft"")
      logger.log_partial (""%s: "", (k == kind::HARD) ? ""HARD"" : ""soft"");

      // Log the offset in a human-readable format
      offset.dump_to_pp (logger.get_printer (), true);

      // End the current log line
      logger.end_log_line ();
    }

  // Decrease the indentation level after logging the boundaries
  logger.dec_indent ();
}
","The log function logs the boundaries of an access range to the provided logger object. It begins by logging the label ""boundaries:"", then iterates over all the offsets in the m_all_offsets collection. For each offset, it determines the kind of boundary (either HARD or soft) using the get_kind function. It then logs the boundary's type (e.g., ""HARD"" or ""soft"") followed by the formatted offset using the dump_to_pp function. The log entries are indented to improve readability, and indentation is adjusted before and after logging the boundaries. This function provides a structured way to log boundary information with appropriate formatting and indentation for better clarity.






"
"enum kind get_kind (region_offset offset) const
{
  // Assert that the given offset exists in the m_all_offsets container
  gcc_assert (m_all_offsets.find (offset) != m_all_offsets.end ());

  // Check if the offset is present in the m_hard_offsets container
  if (m_hard_offsets.find (offset) != m_hard_offsets.end ())
    {
      // If the offset is found in m_hard_offsets, return the HARD kind
      return kind::HARD;
    }
  else
    {
      // If the offset is not found in m_hard_offsets, return the SOFT kind
      return kind::SOFT;
    }
}","The get_kind function determines the type of a given region_offset (whether it is a HARD or SOFT boundary) by checking its presence in two containers: m_all_offsets and m_hard_offsets. The function first asserts that the provided offset exists in the m_all_offsets container, ensuring it is a valid offset. Then, it checks if the offset is found in the m_hard_offsets container. If found, it returns the HARD boundary type; otherwise, it returns the SOFT boundary type. This function provides a mechanism for categorizing an offset as either a hard or soft boundary based on its location in the respective containers."
"std::vector<region_offset> 
get_hard_boundaries_in_range (byte_offset_t min_offset,
                               byte_offset_t max_offset) const
{
  // Create a vector to store the results (the found hard boundaries)
  std::vector<region_offset> result;

  // Iterate through each offset in the m_hard_offsets container
  for (auto &offset : m_hard_offsets)
    {
      // Skip the offset if it is not concrete (i.e., if it's not a valid offset)
      if (!offset.concrete_p ())
        continue;

      byte_offset_t byte;

      // Attempt to get the concrete byte offset of the current region_offset
      if (!offset.get_concrete_byte_offset (&byte))
        continue;

      // Skip the offset if its byte value is less than the specified minimum offset
      if (byte < min_offset)
        continue;

      // Skip the offset if its byte value is greater than the specified maximum offset
      if (byte > max_offset)
        continue;

      // Add the offset to the result vector if it falls within the range
      result.push_back (offset);
    }

  // Return the vector containing all the valid hard boundaries found within the specified range
  return result;
}","The get_hard_boundaries_in_range function identifies and collects the region_offset values from the m_hard_offsets container that lie within a specified byte offset range (from min_offset to max_offset). It iterates through all the offsets, skipping those that are not concrete or fail to retrieve their concrete byte offset. For each valid offset, it checks if its byte offset falls within the given range. Offsets that satisfy these conditions are added to the result vector, which is then returned. This function is useful for retrieving all the hard boundaries that exist within a specified byte range, ensuring that only concrete and valid offsets are considered."
"int 
get_table_x_for_offset (region_offset offset) const
{
  // Attempt to find the offset in the m_table_x_for_offset map
  auto slot = m_table_x_for_offset.find (offset);

  /* If the offset is not found in the map, assert failure.
     This implies that we likely failed to fully populate m_boundaries
     in the find_boundaries function. */
  gcc_assert (slot != m_table_x_for_offset.end ());

  // Return the value associated with the found offset from the map
  return slot->second;
}","The get_table_x_for_offset function retrieves the associated integer value (or ""table X"") for a given region_offset from the m_table_x_for_offset map. If the offset is not found in the map, the function asserts failure using gcc_assert, indicating that the map was not properly populated, potentially due to an incomplete population of the m_boundaries container during the find_boundaries function. If the offset is successfully found, the corresponding value (the ""table X"") is returned. This function is crucial for obtaining the table or index related to a specific offset in the context of boundary handling."
"int 
get_table_x_for_prev_offset (region_offset offset) const
{
  // Attempt to find the offset in the m_table_x_for_prev_offset map
  auto slot = m_table_x_for_prev_offset.find (offset);

  /* If the offset is not found in the map, assert failure.
     This indicates that we likely failed to fully populate m_boundaries
     in the find_boundaries function. */
  gcc_assert (slot != m_table_x_for_prev_offset.end ());

  // Return the value associated with the found offset from the map
  return slot->second;
}","The get_table_x_for_prev_offset function retrieves the corresponding integer value (representing ""table X"") for a given region_offset from the m_table_x_for_prev_offset map. If the provided offset is not found, the function triggers an assertion failure using gcc_assert, implying that there was an issue with the full population of the m_boundaries container during the find_boundaries function. When the offset is found, it returns the associated ""table X"" value. This function is used for obtaining the table or index related to a previous offset in boundary handling.





"
"table 
make_table (const bit_to_table_map &btm,
            style_manager &sm) const final override
{
  // Create a vector to hold child tables
  std::vector<table> child_tables;

  // Initialize variable to track the maximum number of rows
  int max_rows = 0;

  // Iterate through the children and generate child tables
  for (auto &iter : m_children)
  {
    // Generate the table for the current child using the bit-to-table map and style manager
    table child_table (iter->make_table (btm, sm));

    // Update max_rows to the greater of the current max_rows or the height of the new child table
    max_rows = MAX (max_rows, child_table.get_size ().h);

    // Add the generated child table to the vector
    child_tables.push_back (std::move (child_table));
  }

  // Create a new table with the number of columns from the bit-to-table map and the calculated max_rows
  table t (table::size_t (btm.get_num_columns (), max_rows));

  // Add each child table to the main table at position (0, 0)
  for (auto &&child_table : child_tables)
    t.add_other_table (std::move (child_table), table::coord_t (0, 0));

  // Return the populated table
  return t;
}","The make_table function is responsible for creating a table by assembling child tables. It starts by iterating through the m_children collection, where each child table is generated using a provided bit_to_table_map (btm) and a style_manager (sm). The function tracks the maximum number of rows encountered while generating the child tables. Once all child tables are created, it initializes a new table with the appropriate number of columns (derived from btm) and the maximum row count. The child tables are then added to the new table at position (0, 0) using the add_other_table method. Finally, the newly assembled table is returned. This function is used for building a hierarchical structure of tables, where the main table consists of child tables arranged in a specified layout."
"static void
add_ellipsis_to_gaps (table &t,
                      style_manager &sm,
                      const table::range_t &table_x_range,
                      const table::range_t &table_y_range)
{
  // Start at the minimum x-coordinate of the table's x-range
  int table_x = table_x_range.get_min ();
  
  // Loop through the x-range of the table
  while (table_x < table_x_range.get_next ())
    {
      /* Find a run of unoccupied table cells.  */
      const int start_table_x = table_x;  // Store the starting x-coordinate of unoccupied cells
      
      // Find the end of the unoccupied cells run by checking if the placement is empty
      while (table_x < table_x_range.get_next ()
             && !t.get_placement_at (table::coord_t (table_x,
                                                     table_y_range.get_min ())))
        table_x++;  // Move to the next column
      
      // Create a range representing the unoccupied cells along the x-axis
      const table::range_t unoccupied_x_range (start_table_x, table_x);
      
      // If there are unoccupied cells, set a span with ellipsis (""..."") to represent the gap
      if (unoccupied_x_range.get_size () > 0)
        t.set_cell_span (table::rect_t (unoccupied_x_range, table_y_range),
                         styled_string (sm, ""...""));
      
      /* Skip occupied table cells.  */
      // Move past any occupied cells in the x-range
      while (table_x < table_x_range.get_next ()
             && t.get_placement_at (table::coord_t (table_x,
                                                    table_y_range.get_min ())))
        table_x++;
    }
}
","The add_ellipsis_to_gaps function is responsible for adding ellipses (""..."") to represent gaps of unoccupied cells in a table. It scans through the table's x-coordinate range (table_x_range) and identifies consecutive unoccupied cells. For each unoccupied range, the function creates a cell span and fills it with ellipses. The function also ensures that it skips over any occupied cells by checking the placement at each (x, y) coordinate. The gaps are represented visually in the table, making it clear where data is missing. The ellipsis is styled using a style_manager (sm) to maintain the table's appearance.





"
"void add_boundaries (boundaries &out, logger *logger) const final override
{
  // Log the scope entry
  LOG_SCOPE (logger);

  // Set the boundary reference
  m_boundaries = &out;

  // Get the valid access bits from the operation
  access_range valid_bits = m_op.get_valid_bits ();

  // Log the valid bits if the logger is present
  if (logger)
  {
    logger->start_log_line ();
    logger->log_partial (""valid bits: "");
    valid_bits.dump_to_pp (logger->get_printer (), true);
    logger->end_log_line ();
  }

  // Add the valid bits as HARD boundaries
  out.add (valid_bits, boundaries::kind::HARD);

  // If there is an existing spatial item for the svalue, add its boundaries as well
  if (m_existing_sval_spatial_item)
  {
    // Log the existing svalue if the logger is present
    if (logger)
    {
      logger->start_log_line ();
      logger->log_partial (""existing svalue: "");
      m_existing_sval->dump_to_pp (logger->get_printer (), true);
      logger->end_log_line ();
    }
    // Add boundaries for the existing spatial item
    m_existing_sval_spatial_item->add_boundaries (out, logger);
  }

  // Support for showing the first and last element in array types
  if (tree base_type = m_op.m_base_region->get_type ())
  {
    // Check if the type is an array type
    if (TREE_CODE (base_type) == ARRAY_TYPE)
    {
      // Log the array type handling if the logger is present
      if (logger)
        logger->log (""showing first and final element in array type"");

      // Get the region model manager
      region_model_manager *mgr = m_op.m_model.get_manager ();

      // Get the domain (range of valid indices) of the array
      tree domain = TYPE_DOMAIN (base_type);
      if (domain && TYPE_MIN_VALUE (domain) && TYPE_MAX_VALUE (domain))
      {
        // Get the minimum and maximum index values of the array
        const svalue *min_idx_sval = mgr->get_or_create_constant_svalue (TYPE_MIN_VALUE (domain));
        const svalue *max_idx_sval = mgr->get_or_create_constant_svalue (TYPE_MAX_VALUE (domain));

        // Get the regions of the first (min index) and last (max index) elements of the array
        const region *min_element = mgr->get_element_region (m_op.m_base_region,
                                                             TREE_TYPE (base_type),
                                                             min_idx_sval);
        out.add (*min_element, mgr, boundaries::kind::SOFT);
        
        const region *max_element = mgr->get_element_region (m_op.m_base_region,
                                                             TREE_TYPE (base_type),
                                                             max_idx_sval);
        out.add (*max_element, mgr, boundaries::kind::SOFT);
      }
    }
  }
}
","The add_boundaries function adds boundary information to the given boundaries object (out). The function first retrieves the valid access bits from the current operation and adds them as ""HARD"" boundaries. If there is an existing spatial item associated with an svalue, the function recursively adds its boundaries. Additionally, if the base type of the region is an array, the function identifies the first and last elements in the array and adds their boundaries as ""SOFT"" boundaries. Throughout the process, if a logger is provided, it logs relevant information such as valid bits, existing svalues, and array boundary handling. The function is designed to handle both scalar and array types, adding appropriate boundary information to the out object based on the operation's context."
"table make_headings_table () const
{
  // Create a new table with dimensions based on the number of columns in the bit-to-table map
  table t (table::size_t (m_btm.get_num_columns (), 2));

  // Fill the first row of the table with column headings (tc0, tc1, tc2, ...)
  for (int table_x = 0; table_x < t.get_size ().w; table_x++)
  {
    const int table_y = 0; // First row (heading row)
    t.set_cell (table::coord_t (table_x, table_y),
                fmt_styled_string (m_sm, ""tc%i"", table_x)); // Set styled text (tc0, tc1, tc2, ...)
  }

  // Fill the second row with access range information for each column
  for (int table_x = 0; table_x < t.get_size ().w; table_x++)
  {
    const int table_y = 1; // Second row (values row)
    access_range range_for_column (NULL, bit_range (0, 0)); // Initialize range with default value
    // If an access range for the column is available, print the formatted range in the cell
    if (m_btm.maybe_get_access_range_for_table_x (table_x, &range_for_column))
    {
      pretty_printer pp;
      pp_format_decoder (&pp) = default_tree_printer; // Set the default printer format
      range_for_column.dump_to_pp (&pp, true); // Dump the access range to the printer
      t.set_cell (table::coord_t (table_x, table_y),
                  styled_string (m_sm, pp_formatted_text (&pp))); // Set the formatted text in the cell
    }
  }

  // Return the constructed table
  return t;
}","The make_headings_table function creates a two-row table where:

First row: The columns are labeled with ""tc0"", ""tc1"", ""tc2"", ..., based on the number of columns in the bit_to_table_map (m_btm). These labels are created dynamically using the table index.

Second row: For each column, the function attempts to fetch an access range using maybe_get_access_range_for_table_x. If a valid range is found, it is formatted using a pretty_printer and displayed in the corresponding table cell.

The function returns a populated table with formatted headers and values, which is useful for visualizing the structure or boundaries of the table, particularly in a context where access ranges are important (e.g., memory regions or bitmaps)."
"void add_invalid_accesses_to_region_table (table &t_region)
{
  // Ensure the number of columns in the region table matches the number of columns in the bit-to-table map
  gcc_assert (t_region.get_size ().w == (int)m_btm.get_num_columns ());

  const int table_y = 0; // First row
  const int table_h = t_region.get_size ().h; // Total height of the table

  // Initialize access_range objects to hold invalid access ranges before and after valid bits
  access_range invalid_before_bits;
  // If an invalid access range exists before valid bits, set the cell span for this range in the table
  if (m_op.maybe_get_invalid_before_bits (&invalid_before_bits))
  {
    t_region.set_cell_span (m_btm.get_table_rect (invalid_before_bits,
                                                  table_y, table_h),
                            styled_string (m_sm,
                                           _(""before valid range""))); // Label the range as ""before valid range""
  }

  // Initialize another access_range object for invalid access after valid bits
  access_range invalid_after_bits;
  // If an invalid access range exists after valid bits, set the cell span for this range in the table
  if (m_op.maybe_get_invalid_after_bits (&invalid_after_bits))
  {
    t_region.set_cell_span (m_btm.get_table_rect (invalid_after_bits,
                                                  table_y, table_h),
                            styled_string (m_sm,
                                           _(""after valid range""))); // Label the range as ""after valid range""
  }
}","The add_invalid_accesses_to_region_table function updates a region table (t_region) to highlight invalid access ranges before and after valid memory ranges. Specifically:

Precondition: The table’s width must match the number of columns in the bit_to_table_map (m_btm).

Invalid Access Before Valid Range: The function checks if there are invalid access bits before the valid range (maybe_get_invalid_before_bits). If such a range exists, it sets the corresponding cells in the table to indicate that these areas are ""before the valid range.""

Invalid Access After Valid Range: Similarly, it checks for invalid access after the valid range (maybe_get_invalid_after_bits). If such a range exists, it sets the corresponding cells in the table to indicate that these areas are ""after the valid range.""

The table is updated by marking the invalid access regions with descriptive labels (""before valid range"" and ""after valid range""). This function is useful for visualizing and managing invalid access areas in the context of memory or data ranges, providing an overview of where valid data ends and invalid access starts."
"void adjust_to_scale ()
{
  // Start logging for the scope of this function.
  LOG_SCOPE (m_logger);

  // Get the number of columns in the table `m_btm`.
  const unsigned num_columns = m_btm.get_num_columns ();

  // Create a vector `bit_sizes` to store the size in bits for each column.
  // Initialize with zero values.
  std::vector<bit_offset_t> bit_sizes (num_columns);

  // Loop over each column index in the table.
  for (unsigned table_x = 0; table_x < num_columns; table_x++)
  {
    // Initialize an access range for the current column with an empty range.
    access_range range_for_column (NULL, bit_range (0, 0));

    // Try to fetch the access range for the current column (table_x).
    // If successful, range_for_column will contain the bit range.
    if (m_btm.maybe_get_access_range_for_table_x (table_x, &range_for_column))
    {
      // Declare a variable to hold the size of the range in bits.
      bit_size_t size_in_bits;

      // Get the size of the range in bits. If the size cannot be determined,
      // assign a default value `BITS_PER_UNIT`, which is a non-zero arbitrary value.
      if (!range_for_column.get_size_in_bits (&size_in_bits))
        size_in_bits = BITS_PER_UNIT;  // arbitrary non-zero value

      // Ensure that the bit size is greater than zero.
      gcc_assert (size_in_bits > 0);

      // Store the computed bit size for the current column in the `bit_sizes` vector.
      bit_sizes[table_x] = size_in_bits;
    }
    else
    {
      // If the access range couldn't be fetched, set the bit size for the column to 0.
      bit_sizes[table_x] = 0;
    }
  }

  // Call the function `adjust_to_scale_once` with the computed bit sizes.
  // This function adjusts the scale based on the bit sizes and may repeat the process.
  // The loop continues until `adjust_to_scale_once` returns false, indicating no further adjustment is needed.
  while (adjust_to_scale_once (bit_sizes))
  {
    // Continue adjusting until no changes are made.
  }
}","Logging Start: LOG_SCOPE(m_logger) begins logging for the current scope, which helps in debugging or tracking the function’s execution.
Fetching Columns and Initializing Bit Sizes: The function retrieves the number of columns (num_columns) from m_btm and initializes a vector bit_sizes to store the bit sizes for each column.
Accessing and Calculating Bit Size: The loop over each column checks if an access range can be retrieved using maybe_get_access_range_for_table_x. If it succeeds, the bit size is computed, and if that fails, a default size is assigned.
Adjusting Scale: Once the bit sizes are computed, adjust_to_scale_once is called repeatedly until no further adjustment is needed (i.e., the function returns false)."
"bool analysis_plan::use_summary_p (const cgraph_edge *edge) const
{
  /* Check if call summaries are enabled. If not, return false. */
  if (!flag_analyzer_call_summaries)
    return false;

  /* If the edge is null or does not have a callee, return false. */
  if (!edge || !edge->callee)
    return false;

  /* Initialize a variable to count the number of call sites for the callee. */
  int num_call_sites = 0;
  
  /* Get the callee node from the edge. */
  const cgraph_node *callee = edge->callee;

  /* Count the number of call sites (i.e., the number of callers for this callee). */
  for (cgraph_edge *edge = callee->callers; edge; edge = edge->next_caller)
    ++num_call_sites;

  /* If there is only one call site or less, do not use a call summary. */
  if (num_call_sites <= 1)
    return false;

  /* Get the function associated with the callee's ultimate alias target. */
  const function *fun
    = const_cast <cgraph_node *> (callee)->ultimate_alias_target ()->get_fun ();
  /* TODO: Consider making ultimate_alias_target const, if possible. */

  /* Check if the function has enough complexity (based on the number of nodes) to warrant a call summary. */
  if ((int)m_sg.get_num_snodes (fun)
      < param_analyzer_min_snodes_for_call_summary)
    return false;

  /* If all conditions are met, return true to indicate that the call summary should be used. */
  return true;
}","The use_summary_p function is a decision-making function that determines whether a call summary should be used for a given callgraph edge (cgraph_edge). The function performs the following checks:

It first verifies whether call summaries are enabled via the flag_analyzer_call_summaries flag. If summaries are disabled, it returns false.
It then checks if the edge is valid and has a callee. If not, it returns false.
The function counts the number of call sites (i.e., the number of callers) for the callee associated with the edge. If there is only one or fewer call sites, it returns false.
It checks the complexity of the callee's associated function. If the function has fewer nodes than the minimum threshold (param_analyzer_min_snodes_for_call_summary), the function returns false.
If all the checks pass, the function returns true, indicating that a call summary should be used for this callgraph edge.
This function helps optimize the usage of call summaries by ensuring that summaries are used only for sufficiently complex and frequently called functions, avoiding unnecessary overhead for simpler or less common calls."
"static void stash_named_constants (logger *logger, const translation_unit &tu)
{
  /* Start a new logging scope to group all log entries related to this function. */
  LOG_SCOPE (logger);

  /* Stash the constant ""O_ACCMODE"" from the translation unit for later use. */
  maybe_stash_named_constant (logger, tu, ""O_ACCMODE"");
  
  /* Stash the constant ""O_RDONLY"" from the translation unit for later use. */
  maybe_stash_named_constant (logger, tu, ""O_RDONLY"");
  
  /* Stash the constant ""O_WRONLY"" from the translation unit for later use. */
  maybe_stash_named_constant (logger, tu, ""O_WRONLY"");
  
  /* Stash the constant ""SOCK_STREAM"" from the translation unit for later use. */
  maybe_stash_named_constant (logger, tu, ""SOCK_STREAM"");
  
  /* Stash the constant ""SOCK_DGRAM"" from the translation unit for later use. */
  maybe_stash_named_constant (logger, tu, ""SOCK_DGRAM"");
}","The stash_named_constants function is responsible for stashing a set of predefined constants from a given translation unit (tu) for later use by other components of the program, particularly the sm-fd.cc file. The function performs the following actions:

It begins a new logging scope using the LOG_SCOPE macro to group all logging related to the stashing process.
It then calls the maybe_stash_named_constant function multiple times to stash a series of constants, including O_ACCMODE, O_RDONLY, O_WRONLY, SOCK_STREAM, and SOCK_DGRAM. These constants are typically used for setting file access modes and socket types in system programming.
Each call to maybe_stash_named_constant checks whether the constant is available in the translation unit and, if so, stashes it for future use.
This function is part of a larger system that deals with named constants, ensuring that specific system constants are stored for later reference, potentially optimizing the handling of file and socket operations in the codebase."
"void on_finish_translation_unit (const translation_unit &tu)
{
  /* Bail out early if the analyzer is not enabled. */
  if (!flag_analyzer)
    return;

  /* Get or create a log file for recording analysis-related logs. */
  FILE *logfile = get_or_create_any_logfile ();

  /* Initialize a logger object to handle logging functionality. */
  log_user the_logger (NULL);

  /* If a log file was successfully created, set up the logger to use it. */
  if (logfile)
    the_logger.set_logger (new logger (logfile, 0, 0,
                                       *global_dc->get_reference_printer ()));

  /* Stash named constants from the translation unit for later use. */
  stash_named_constants (the_logger.get_logger (), tu);

  /* Run any registered callbacks with the created logger and translation unit. */
  run_callbacks (the_logger.get_logger (), tu);
}","The on_finish_translation_unit function is called once the translation unit (tu) has been processed and the analysis is ready to be finalized. The function performs the following steps:

Check if the analyzer is enabled: It first checks whether the analyzer is enabled by evaluating the flag_analyzer flag. If the analyzer is disabled, the function exits early without performing further operations.
Log file creation: It retrieves or creates a log file by calling get_or_create_any_logfile. This file will be used for recording logs related to the translation unit analysis.
Logger setup: A log_user object is created and initialized. If the log file is successfully created, the logger is set up with the provided log file, enabling logging functionality.
Stash named constants: It calls the stash_named_constants function to store certain predefined constants from the translation unit. These constants may be used in subsequent analysis or other parts of the program.
Run callbacks: The function then calls run_callbacks, passing the logger and the translation unit to invoke any registered callbacks, which might perform additional actions or analysis on the translation unit.
This function is part of the analysis pipeline and is invoked when the translation unit has been fully processed, ensuring that named constants are stored, logs are recorded, and any registered callbacks are executed."
"tree get_stashed_constant_by_name (const char *name)
{
  /* If there are no stashed constants, return NULL_TREE immediately. */
  if (!analyzer_stashed_constants)
    return NULL_TREE;

  /* Get the identifier (tree) for the given constant name. */
  tree id = get_identifier (name);

  /* Check if the identifier exists in the stashed constants map. */
  if (tree *slot = analyzer_stashed_constants->get (id))
    {
      /* Ensure the constant is of type INTEGER_CST (integer constant). */
      gcc_assert (TREE_CODE (*slot) == INTEGER_CST);
      return *slot;  /* Return the stashed constant. */
    }

  /* If no constant with the given name was found, return NULL_TREE. */
  return NULL_TREE;
}","The get_stashed_constant_by_name function retrieves a stashed constant based on its name. It performs the following steps:

Check if there are any stashed constants: It first checks whether the analyzer_stashed_constants map (or container) is null. If there are no stashed constants, it immediately returns NULL_TREE.

Get identifier for the constant: The function uses the get_identifier function to obtain a tree identifier corresponding to the provided constant name (name).

Check if the constant is present in the stash: It checks if the constant with the given identifier exists in the analyzer_stashed_constants map using the get function. If found, it proceeds to the next step.

Validate and return the constant: If the constant is found, the function asserts that the constant is of type INTEGER_CST (integer constant). This assertion ensures that the retrieved value is indeed an integer constant, preventing invalid or unexpected data types from being returned. The constant is then returned.

Return NULL_TREE if the constant is not found: If the constant is not found in the map, the function returns NULL_TREE to indicate that no matching constant was found for the given name.

This function is used to retrieve constants that have been previously ""stashed"" (stored) for later use, typically during the analysis phase, based on the provided name.





"
"void log_stashed_constants (logger *logger)
{
  /* Ensure that the logger is not null. */
  gcc_assert (logger);

  /* Begin logging scope for this function. */
  LOG_SCOPE (logger);

  /* If there are any stashed constants, iterate over them. */
  if (analyzer_stashed_constants)
    for (auto iter : *analyzer_stashed_constants)
      {
        /* Log each constant's identifier and its value. */
        logger->log (""%qE: %qE"", iter.first, iter.second);
      }
}","The log_stashed_constants function logs the constants stored in analyzer_stashed_constants, if any exist. It works as follows:

Validate the logger: The function asserts that the logger object is valid (non-null) to avoid null pointer dereferencing.

Begin logging scope: A logging scope is initiated using LOG_SCOPE(logger), which ensures that the logs are associated with the function's execution context.

Check for stashed constants: The function checks if the analyzer_stashed_constants (a container storing constant data) is populated.

Iterate over stashed constants: If analyzer_stashed_constants contains constants, it iterates through each key-value pair stored in the container. The auto iter automatically unpacks the container's key-value pairs, where iter.first is the constant's identifier and iter.second is its value.

Log the constants: Each constant is logged using the logger object, where the identifier and its corresponding value are formatted and output via logger->log(""%qE: %qE"", iter.first, iter.second). The %qE format specifier ensures that the constant is printed in an appropriate human-readable form.

This function is used to provide a trace of all the constants that have been stashed, typically for debugging or analysis purposes, and it outputs the constant names (identifiers) and their values."
"static tree
get_diagnostic_tree_for_gassign_1 (const gassign *assign_stmt,
				   hash_set<tree> *visited)
{
  // Retrieve the operation code for the right-hand side of the assignment
  enum tree_code code = gimple_assign_rhs_code (assign_stmt);

  /* Reverse the effect of extract_ops_from_tree during
     gimplification. This function reconstructs the tree representation
     for diagnostic purposes. */
  switch (get_gimple_rhs_class (code))
    {
    default:
    case GIMPLE_INVALID_RHS:
      // The assignment has an invalid right-hand side, which should never occur
      gcc_unreachable ();
    
    case GIMPLE_TERNARY_RHS:
    case GIMPLE_BINARY_RHS:
    case GIMPLE_UNARY_RHS:
      {
        // Create a new tree node with the appropriate RHS code type
        tree t = make_node (code);
        TREE_TYPE (t) = TREE_TYPE (gimple_assign_lhs (assign_stmt));

        // Determine the number of arguments on the right-hand side, excluding the LHS
        unsigned num_rhs_args = gimple_num_ops (assign_stmt) - 1;

        // Iterate over each argument on the right-hand side and process it
        for (unsigned i = 0; i < num_rhs_args; i++)
          {
            // Retrieve the operand for the current argument
            tree op = gimple_op (assign_stmt, i + 1);

            if (op)
              {
                // Perform any necessary adjustments for diagnostic output
                op = fixup_tree_for_diagnostic_1 (op, visited);
                
                // If the operand was invalid or cannot be processed, return NULL_TREE
                if (op == NULL_TREE)
                  return NULL_TREE;
              }

            // Set the operand in the tree node
            TREE_OPERAND (t, i) = op;
          }

        // Return the constructed tree node representing the RHS
        return t;
      }
    
    case GIMPLE_SINGLE_RHS:
      {
        // For a single operand on the RHS, process it similarly
        tree op = gimple_op (assign_stmt, 1);
        
        // Perform any necessary adjustments for diagnostic output
        op = fixup_tree_for_diagnostic_1 (op, visited);
        
        // Return the operand itself, as there is only one
        return op;
      }
    }
}","The get_diagnostic_tree_for_gassign_1 function reconstructs a tree representation of the right-hand side (RHS) of a gassign (general assignment) statement, for diagnostic purposes. The function first retrieves the operation code for the RHS of the assignment. Depending on the class of the RHS (such as unary, binary, or ternary), it constructs a new tree node for the RHS expression. It processes each operand of the RHS, applying necessary fixes or adjustments through the fixup_tree_for_diagnostic_1 function, and ensures the validity of the operands before including them in the tree. If an operand cannot be processed correctly, the function returns NULL_TREE. In the case of a single operand on the RHS, the function directly returns that operand after adjustments. The function provides a way to generate a diagnostic tree representation, useful for debugging or generating human-readable error reports."
"static tree
maybe_reconstruct_from_def_stmt (tree ssa_name,
				 hash_set<tree> *visited)
{
  /* Ensure termination: If the SSA name has already been processed, 
     avoid cycles and prevent infinite recursion. */
  if (visited->contains (ssa_name))
    return NULL_TREE;

  // Mark the SSA name as visited
  visited->add (ssa_name);

  // Retrieve the definition statement associated with the SSA name
  gimple *def_stmt = SSA_NAME_DEF_STMT (ssa_name);

  // Process the definition statement based on its type
  switch (gimple_code (def_stmt))
    {
    default:
      // If the statement type is unrecognized, terminate (should not happen)
      gcc_unreachable ();
    
    case GIMPLE_ASM:
    case GIMPLE_NOP:
    case GIMPLE_PHI:
      // These statement types cannot be handled in this context
      return NULL_TREE;
    
    case GIMPLE_ASSIGN:
      // If the statement is an assignment, reconstruct the diagnostic tree for it
      return get_diagnostic_tree_for_gassign_1
        (as_a <const gassign *> (def_stmt), visited);
    
    case GIMPLE_CALL:
      {
        // If the statement is a function call, handle it by reconstructing the call tree
        gcall *call_stmt = as_a <gcall *> (def_stmt);

        // Retrieve the return type of the function call
        tree return_type = gimple_call_return_type (call_stmt);

        // Process the function name for the call, applying necessary fixes
        tree fn = fixup_tree_for_diagnostic_1 (gimple_call_fn (call_stmt), visited);
        if (fn == NULL_TREE)
          return NULL_TREE;

        // Process the arguments of the call
        unsigned num_args = gimple_call_num_args (call_stmt);
        auto_vec<tree> args (num_args);
        for (unsigned i = 0; i < num_args; i++)
          {
            // Process each argument, applying fixes and checking for validity
            tree arg = gimple_call_arg (call_stmt, i);
            arg = fixup_tree_for_diagnostic_1 (arg, visited);
            if (arg == NULL_TREE)
              return NULL_TREE;

            // Add the valid argument to the argument list
            args.quick_push (arg);
          }

        // Ensure the function pointer is valid
        gcc_assert (fn);

        // Build and return the reconstructed call tree, including the location and arguments
        return build_call_array_loc (gimple_location (call_stmt),
                                     return_type, fn,
                                     num_args, args.address ());
      }
      break;
    }
}","The function maybe_reconstruct_from_def_stmt attempts to reconstruct a diagnostic tree representation from the definition statement of an SSA name (Static Single Assignment name) in the form of a gimple statement. It starts by ensuring that the SSA name has not already been processed to prevent cycles and infinite recursion. It then retrieves the associated definition statement of the SSA name. The function handles different types of gimple statements:

For GIMPLE_ASM, GIMPLE_NOP, and GIMPLE_PHI, it returns NULL_TREE because these types of statements cannot be processed for diagnostic reconstruction.
For GIMPLE_ASSIGN, it calls another function to reconstruct the tree for assignment statements.
For GIMPLE_CALL, it processes the function call, retrieves the return type, applies necessary fixes to the function and arguments, and constructs a diagnostic tree representing the call, including the function location, arguments, and return type.
In essence, this function reconstructs a diagnostic representation of the SSA name's definition, based on the type of gimple statement it corresponds to, while ensuring the correctness of the involved components."
"static tree
fixup_tree_for_diagnostic_1 (tree expr, hash_set<tree> *visited)
{
  // Check if the expression is a valid SSA_NAME and if the associated variable
  // is either NULL_TREE or an artificial variable (used for temporary computations).
  if (expr
      && TREE_CODE (expr) == SSA_NAME
      && (SSA_NAME_VAR (expr) == NULL_TREE
          || DECL_ARTIFICIAL (SSA_NAME_VAR (expr))))
    {
      // If there is an associated variable, check if it is a real variable (VAR_P)
      // and if it has a debug expression associated with it.
      if (tree var = SSA_NAME_VAR (expr))
        if (VAR_P (var) && DECL_HAS_DEBUG_EXPR_P (var))
          return DECL_DEBUG_EXPR (var); // Return the debug expression for the variable.
      
      // Attempt to reconstruct the expression from its definition statement if possible.
      if (tree expr2 = maybe_reconstruct_from_def_stmt (expr, visited))
        return expr2; // Return the reconstructed expression.
    }

  // Return the original expression if no modifications were necessary.
  return expr;
}","The function fixup_tree_for_diagnostic_1 is responsible for performing fixes on a given expression (expr) for diagnostic purposes. It checks if the expression is an SSA name (Static Single Assignment) and whether it is associated with an artificial or temporary variable. If the SSA name corresponds to a variable that has a debug expression associated with it, the function returns that debug expression.

If no debug expression is found, the function attempts to reconstruct the expression from its definition statement using the helper function maybe_reconstruct_from_def_stmt. This allows for a more accurate representation of the expression in a diagnostic context, especially when dealing with temporary variables or SSA names.

If neither a debug expression nor a valid reconstruction is found, the original expression is returned unchanged. The visited set is used to prevent infinite recursion when processing SSA names that may refer to the same variable or expression multiple times."
"std::unique_ptr<json::value>
tree_to_json (tree node)
{
  // If the provided node is null, return a JSON literal with a null value.
  if (!node)
    return ::make_unique<json::literal> (json::JSON_NULL);

  // Initialize a pretty printer to format the node into a human-readable form.
  pretty_printer pp;

  // Dump the generic representation of the node into the pretty printer. 
  // The flags TDF_VOPS and TDF_MEMSYMS are used for specific dumping options related to value operations and memory symbols.
  // The 'false' argument indicates no printing of a location (location not needed for this conversion).
  dump_generic_node (&pp, node, 0, TDF_VOPS|TDF_MEMSYMS, false);

  // Create and return a JSON string representation of the formatted text generated by the pretty printer.
  return ::make_unique<json::string> (pp_formatted_text (&pp));
}","The tree_to_json function converts a given tree node into its corresponding JSON representation. If the node is null, the function returns a JSON literal with the value null.

For non-null nodes, it uses the pretty_printer class to generate a human-readable format of the node's contents. The function dump_generic_node is called with specific flags (TDF_VOPS | TDF_MEMSYMS) to control the type of information that is printed, including value operations and memory symbols. The false argument indicates that location information is not included in the output.

Finally, the function converts the formatted text from the pretty printer into a JSON string and returns it as a std::unique_ptr<json::value>. This allows for easy handling and manipulation of the tree data in JSON format."
"std::unique_ptr<json::value>
diagnostic_event_id_to_json (const diagnostic_event_id_t &event_id)
{
  // If the event ID is known (i.e., it has a valid value), proceed to convert it to JSON.
  if (event_id.known_p ())
    {
      // Initialize a pretty printer to format the event ID into a human-readable form.
      pretty_printer pp;

      // Use the pp_printf function to print the formatted string representation of the event_id into the pretty printer.
      pp_printf (&pp, ""%@"", &event_id);

      // Return the formatted event ID as a JSON string.
      return ::make_unique<json::string> (pp_formatted_text (&pp));
    }
  else
    // If the event ID is unknown, return a JSON literal with a null value.
    return ::make_unique<json::literal> (json::JSON_NULL);
}","The diagnostic_event_id_to_json function converts a diagnostic_event_id_t object into its corresponding JSON representation. If the event_id is known (i.e., it is valid), the function uses a pretty_printer to format the event ID into a human-readable string. The pp_printf function is used to print the formatted string representation of the event ID, and pp_formatted_text extracts the formatted text from the pretty_printer.

The function then returns a std::unique_ptr<json::string> containing the formatted string as a JSON string. If the event_id is unknown (i.e., not valid), the function returns a std::unique_ptr<json::literal> with a JSON null value, indicating the absence of a valid event ID. This makes the function useful for handling both valid and invalid diagnostic event IDs and converting them into a JSON-compatible format.





"
"bool
is_special_named_call_p (const gcall *call, const char *funcname,
                         unsigned int num_args, bool look_in_std)
{
  // Ensure that the function name is provided.
  gcc_assert (funcname);

  // Retrieve the function declaration (fndecl) for the call.
  tree fndecl = gimple_call_fndecl (call);

  // If there is no function declaration, return false as it can't be a named function call.
  if (!fndecl)
    return false;

  // Check if the function is a named call matching the provided function name and number of arguments.
  if (is_named_call_p (fndecl, funcname, call, num_args))
    return true;

  // If the look_in_std flag is set to true, check if the function is in the standard library
  // and matches the provided function name and number of arguments.
  if (look_in_std)
    if (is_std_named_call_p (fndecl, funcname, call, num_args))
      return true;

  // Return false if neither condition is satisfied.
  return false;
}","The is_special_named_call_p function checks if a function call (gcall) matches a specific name (funcname) and the correct number of arguments (num_args). It first ensures that the provided function name is valid. Then, it retrieves the function declaration associated with the call. If there is no function declaration, it immediately returns false because the call cannot be matched to a named function.

The function then checks if the call matches the provided function name and number of arguments using the helper function is_named_call_p. If the look_in_std flag is set to true, it also checks whether the function belongs to the standard library using is_std_named_call_p. If either of these checks returns true, the function returns true, indicating that the call is a special named call. Otherwise, it returns false. This function is useful for identifying whether a function call corresponds to a particular named function, including functions in the standard library.





"
"bool
is_named_call_p (const_tree fndecl, const char *funcname)
{
  // Ensure that the function declaration and function name are provided.
  gcc_assert (fndecl);
  gcc_assert (funcname);

  // Check if the function is a special function (using a helper function).
  if (!maybe_special_function_p (fndecl))
    return false;

  // Retrieve the identifier (name) of the function declaration.
  tree identifier = DECL_NAME (fndecl);

  // Get the string representation of the function's name.
  const char *name = IDENTIFIER_POINTER (identifier);
  
  // Initialize a pointer to the function's name for potential modification.
  const char *tname = name;

  // Potentially disregard prefix underscores (_) or double underscores (__)
  // in the function's name, but not if the target function name itself starts with underscores.
  if (funcname[0] != '_' && name[0] == '_')
    {
      // Skip one underscore if it is followed by a character other than another underscore.
      if (name[1] == '_')
        tname += 2;
      else
        tname += 1;
    }

  // Compare the modified name of the function with the provided function name.
  return 0 == strcmp (tname, funcname);
}","The is_named_call_p function checks if a function declaration (fndecl) corresponds to a specified function name (funcname). It first validates that both the function declaration and function name are provided. It then verifies whether the function is considered a ""special function"" using the helper function maybe_special_function_p. If the function is not special, the function returns false.

Next, the function retrieves the name of the function declaration and processes it by checking for and potentially skipping leading underscores. This is done to handle cases where the function name may start with an underscore or double underscore (e.g., when looking for __analyzer_eval). If the provided function name does not begin with an underscore, the function will disregard any leading underscores in the function declaration’s name.

Finally, it compares the processed name of the function with the provided funcname. If they match, the function returns true, indicating that the function declaration corresponds to the given function name. Otherwise, it returns false. This function is particularly useful for identifying whether a function matches a specific name, with special handling for underscore-prefixed names commonly found in system-level functions."
"bool
is_std_function_p (const_tree fndecl)
{
  // Retrieve the name of the function declaration.
  tree name_decl = DECL_NAME (fndecl);
  
  // If the function doesn't have a name, it cannot be a standard function.
  if (!name_decl)
    return false;

  // Check if the function declaration has a valid context (namespace or translation unit).
  if (!DECL_CONTEXT (fndecl))
    return false;

  // The function's context must be a namespace (i.e., function should belong to a namespace).
  if (TREE_CODE (DECL_CONTEXT (fndecl)) != NAMESPACE_DECL)
    return false;

  // Retrieve the namespace where the function is declared.
  tree ns = DECL_CONTEXT (fndecl);

  // Ensure that the parent context of the namespace is either NULL_TREE or a translation unit declaration.
  if (!(DECL_CONTEXT (ns) == NULL_TREE || TREE_CODE (DECL_CONTEXT (ns)) == TRANSLATION_UNIT_DECL))
    return false;

  // If the namespace doesn't have a name, it's not a standard function.
  if (!DECL_NAME (ns))
    return false;

  // Check if the namespace is named ""std"", which is the standard namespace in C++.
  return id_equal (""std"", DECL_NAME (ns));
}","The is_std_function_p function checks whether a given function declaration (fndecl) is part of the C++ standard namespace (std). The function performs several validation checks:

It first ensures that the function declaration has a valid name (DECL_NAME).
It verifies that the function declaration belongs to a valid context (i.e., a namespace or translation unit).
The function then checks whether the context of the function is a namespace declaration by confirming that the DECL_CONTEXT is of type NAMESPACE_DECL.
If the function is inside a namespace, it retrieves that namespace's context and checks if the parent context is either NULL_TREE or a TRANSLATION_UNIT_DECL, which indicates that the namespace is at the top level or within a translation unit.
If the namespace is valid, the function checks if the namespace name matches ""std"", which is the name of the C++ standard namespace.
If all conditions are satisfied, the function returns true, indicating that the function declaration is part of the std namespace. Otherwise, it returns false. This function is useful for identifying functions that belong to the C++ standard library."
"bool
is_longjmp_call_p (const gcall *call)
{
  // Check if the function call is either ""longjmp"" or ""siglongjmp"" with exactly two arguments.
  if (is_special_named_call_p (call, ""longjmp"", 2)
      || is_special_named_call_p (call, ""siglongjmp"", 2))
    {
      // Check if the type of the first argument is a pointer.
      // This is required by exploded_node::on_longjmp, which expects a pointer for the initial argument.
      if (POINTER_TYPE_P (TREE_TYPE (gimple_call_arg (call, 0))))
        return true;  // Return true if it's a valid longjmp or siglongjmp call.

    }

  return false;  // Return false if the call doesn't meet the conditions.
}","The is_longjmp_call_p function checks whether a given function call (gcall *call) corresponds to a longjmp or siglongjmp function call with exactly two arguments. The function performs the following checks:

It first checks whether the call is either ""longjmp"" or ""siglongjmp"" using the is_special_named_call_p function, ensuring that the function has exactly two arguments.
If the function name is one of these two, the function then verifies that the type of the first argument is a pointer. This check is performed using POINTER_TYPE_P on the type of the first argument of the call (gimple_call_arg(call, 0)).
The reason for this pointer type check is based on the requirement of exploded_node::on_longjmp, which expects the first argument of the longjmp-related functions to be a pointer.
If both conditions are satisfied (the function is either longjmp or siglongjmp with two arguments, and the first argument is a pointer), the function returns true.
If either of these conditions is not met, the function returns false.
This function is useful for identifying calls to longjmp and siglongjmp that meet specific criteria, such as the number of arguments and the type of the first argument, which is relevant for certain analysis or transformations."
"const char *
get_user_facing_name (const gcall *call)
{
  // Retrieve the function declaration (fndecl) from the function call.
  tree fndecl = gimple_call_fndecl (call);
  gcc_assert (fndecl);  // Assert that the function declaration is valid.

  // Get the identifier (name) of the function from the declaration.
  tree identifier = DECL_NAME (fndecl);
  gcc_assert (identifier);  // Assert that the identifier is valid.

  // Retrieve the string representation of the function name.
  const char *name = IDENTIFIER_POINTER (identifier);

  // Strip any leading underscores from the function name (used in internal naming conventions).
  if (name[0] == '_')
    {
      // If the name starts with two underscores, skip both.
      if (name[1] == '_')
        return name + 2;  // Skip both leading underscores.
      else
        return name + 1;  // Skip the single leading underscore.
    }

  // Return the function name as is if no leading underscores are found.
  return name;
}","The get_user_facing_name function takes a gcall (function call) and extracts the name of the function that was called. The function performs the following steps:

Retrieve the Function Declaration: The function first retrieves the function declaration (fndecl) associated with the given function call (gcall *call) using gimple_call_fndecl. An assertion ensures that the fndecl is valid.

Get the Function Identifier: It then accesses the function's name through DECL_NAME(fndecl), which is stored in the identifier variable. Another assertion is made to ensure the identifier is valid.

Extract the Name as a String: The function extracts the function's name as a C-style string pointer (const char *name), which is retrieved from the IDENTIFIER_POINTER(identifier).

Handle Special Naming Conventions: The function handles special naming conventions by stripping off any leading underscores (_ or __). This is done because internal function names may start with underscores, but the user-facing names typically do not.

If the name starts with two underscores (__), it removes both.
If it starts with a single underscore (_), it removes just one.
Return the Processed Name: Finally, the function returns the user-facing name, either with the underscores stripped or as is if no underscores were present.

This function is useful when processing function names to make them more readable or consistent with user-facing conventions, especially when internal names include leading underscores for various purposes."
"label_text
make_label_text (bool can_colorize, const char *fmt, ...)
{
  // Create a unique pointer to a pretty_printer object by cloning the global printer configuration.
  std::unique_ptr<pretty_printer> pp (global_dc->clone_printer ());
  
  // Clear any existing output in the pretty printer's output area.
  pp_clear_output_area (pp.get ());

  // If colorization is not allowed, disable color output in the pretty printer.
  if (!can_colorize)
    pp_show_color (pp.get ()) = false;

  // Initialize a rich_location object with unknown location (this might be used for debugging or source mapping).
  rich_location rich_loc (line_table, UNKNOWN_LOCATION);

  // Initialize a va_list to process the variable arguments passed to the function.
  va_list ap;
  va_start (ap, fmt);

  // Create a text_info object with the formatted string (fmt) and the variable arguments.
  text_info ti (_(fmt), &ap, 0, NULL, &rich_loc);

  // Format the text using the pretty printer and the provided text_info.
  pp_format (pp.get (), &ti);

  // Output the formatted text to the pretty printer's output area.
  pp_output_formatted_text (pp.get ());

  // Clean up the variable argument list.
  va_end (ap);

  // Create a label_text object from the formatted text and return it.
  label_text result = label_text::take (xstrdup (pp_formatted_text (pp.get ())));
  return result;
}","The make_label_text function generates a formatted string of text, potentially with colorization, and returns it as a label_text object. The function performs the following tasks:

Create a Pretty Printer: It first creates a new pretty_printer by cloning the global printer configuration (global_dc->clone_printer()). This pretty_printer will be used to format the text.

Clear the Printer Output Area: The output area of the pretty_printer is cleared using pp_clear_output_area(pp.get()), ensuring that the printer is starting with an empty state.

Handle Colorization: If the can_colorize flag is false, the function disables color output by setting pp_show_color(pp.get()) to false.

Initialize Location for Debugging: A rich_location object is created, initialized with UNKNOWN_LOCATION. This could be used for debugging or tracing the source code location from which this label text is generated.

Process Variable Arguments: The function then sets up a va_list (ap) to handle the variable arguments (fmt and additional arguments) passed to the function. va_start prepares the variable arguments, which are later used to format the string.

Format the Text: A text_info object is created, which includes the format string (fmt), the variable arguments, and the rich_location. This object is then passed to the pretty_printer for formatting using the pp_format function.

Output the Formatted Text: After formatting, the resulting text is output to the printer's output area using pp_output_formatted_text(pp.get()).

Clean Up: The variable argument list is cleaned up with va_end(ap).

Return the Result: Finally, the function creates a label_text object using the formatted text. The label_text::take method is used to duplicate the formatted string, and the resulting label_text is returned.

This function is useful for generating formatted labels with customizable output, such as for debugging, logging, or user interfaces, where the content can vary based on format strings and optional colorization."
"label_text
make_label_text_n (bool can_colorize, unsigned HOST_WIDE_INT n,
		   const char *singular_fmt,
		   const char *plural_fmt, ...)
{
  // Create a unique pointer to a pretty_printer object by cloning the global printer configuration.
  std::unique_ptr<pretty_printer> pp (global_dc->clone_printer ());
  
  // Clear any existing output in the pretty printer's output area.
  pp_clear_output_area (pp.get ());

  // If colorization is not allowed, disable color output in the pretty printer.
  if (!can_colorize)
    pp_show_color (pp.get ()) = false;

  // Initialize a rich_location object with unknown location (this might be used for debugging or source mapping).
  rich_location rich_loc (line_table, UNKNOWN_LOCATION);

  // Initialize a va_list to process the variable arguments passed to the function.
  va_list ap;
  va_start (ap, plural_fmt);

  // Use ngettext to select the singular or plural format string based on the value of 'n'.
  const char *fmt = ngettext (singular_fmt, plural_fmt, n);

  // Create a text_info object with the selected format string (fmt) and the variable arguments.
  text_info ti (fmt, &ap, 0, NULL, &rich_loc);

  // Format the text using the pretty printer and the provided text_info.
  pp_format (pp.get (), &ti);

  // Output the formatted text to the pretty printer's output area.
  pp_output_formatted_text (pp.get ());

  // Clean up the variable argument list.
  va_end (ap);

  // Create a label_text object from the formatted text and return it.
  label_text result = label_text::take (xstrdup (pp_formatted_text (pp.get ())));
  return result;
}","The make_label_text_n function generates a formatted label based on a count value (n), selecting between singular and plural format strings. It then returns the formatted text as a label_text object. The function performs the following tasks:

Create a Pretty Printer: It first creates a new pretty_printer by cloning the global printer configuration (global_dc->clone_printer()). This pretty_printer is used to format the text.

Clear the Printer Output Area: The function clears the output area of the pretty_printer by calling pp_clear_output_area(pp.get()), ensuring that no previous content is included in the new output.

Handle Colorization: If the can_colorize flag is set to false, the function disables color output by setting pp_show_color(pp.get()) to false.

Initialize Location for Debugging: A rich_location object is created with UNKNOWN_LOCATION. This object can be used for debugging or tracing the source code location from which the label is generated.

Process Variable Arguments: The function sets up a va_list (ap) to handle the variable arguments (singular_fmt, plural_fmt, and additional arguments) passed to the function. The variable argument list is initialized using va_start.

Select Format String (Singular or Plural): The function uses ngettext to choose between the singular and plural format strings based on the count value n. If n is 1, it selects the singular_fmt, otherwise, it uses the plural_fmt.

Format the Text: A text_info object is created with the selected format string (fmt) and the variable arguments. This object is passed to the pretty_printer for formatting using the pp_format function.

Output the Formatted Text: After the text is formatted, it is output to the printer's output area with pp_output_formatted_text(pp.get()).

Clean Up: The variable argument list is cleaned up with va_end(ap).

Return the Result: Finally, a label_text object is created from the formatted text, using label_text::take to duplicate the formatted string. The resulting label_text object is returned.

This function is useful for generating labels that require singular or plural formatting based on a count, such as displaying messages for a specific number of items, tasks, or events, with optional colorization support."
"void
maybe_show_diagram (logger *logger) const
{
  // Create an access_operation object to manage access details of the model.
  access_operation op (m_model, get_dir (), *m_reg, m_sval_hint);

  // Check if there is a valid way to access the base region (e.g., a non-zero size array).
  // If there is no valid way (empty bits), return early without drawing the diagram.
  if (op.get_valid_bits ().empty_p ())
    return;

  // If a diagram theme is available from the global context, proceed to generate the diagram.
  if (const text_art::theme *theme = global_dc->get_diagram_theme ())
  {
    // Create a style manager and canvas to draw the diagram.
    text_art::style_manager sm;
    text_art::canvas canvas (make_access_diagram (op, sm, *theme, logger));
    
    // If the canvas has zero width and height (indicating an error or invalid diagram), do nothing.
    if (canvas.get_size ().w == 0 && canvas.get_size ().h == 0)
    {
      // Return if the diagram could not be created successfully (zero-sized canvas).
      return;
    }
    
    // Create a diagnostic diagram object with the generated canvas and an alt-text description.
    diagnostic_diagram diagram
      (canvas,
       // Alt text for the diagram.
       _(""Diagram visualizing the predicted out-of-bounds access""));

    // Emit the diagram to the global diagnostic context for output.
    global_dc->emit_diagram (diagram);
  }
}","The maybe_show_diagram function attempts to generate and display a diagram visualizing the predicted out-of-bounds access based on a model and other associated data. Here's a step-by-step breakdown of the logic:

Create Access Operation: The function starts by creating an access_operation object, op, which manages the access details for the model. This object takes into account the model (m_model), direction (get_dir()), register (*m_reg), and an optional hint (m_sval_hint).

Validate Access: It then checks if the access operation contains any valid bits (indicating valid access regions). If there are no valid bits (i.e., the access operation is invalid), the function returns early without attempting to create a diagram.

Retrieve Diagram Theme: If there is a valid diagram theme (retrieved from the global diagnostic context global_dc->get_diagram_theme()), the function proceeds to generate the diagram."
"bool
describe_final_event (pretty_printer &pp,
                      const evdesc::final_event &) final override
{
  // Check if there is a byte-bound condition or no bit-bound condition.
  if (m_byte_bound || !m_bit_bound)
  {
    // Create an object to represent the range of out-of-bounds bytes, initialized to (0, 0).
    byte_range out_of_bounds_bytes (0, 0);
    
    // Attempt to get the out-of-bounds bytes. If successful, describe it as bytes.
    if (get_out_of_bounds_bytes (&out_of_bounds_bytes))
    {
      describe_final_event_as_bytes (pp, out_of_bounds_bytes);
      return true; // Return true if the event was described as bytes.
    }
  }

  // If the condition for byte-bound or no bit-bound is not met, describe the event as bits.
  describe_final_event_as_bits (pp);
  return true; // Return true after describing the event as bits.
}","The function describe_final_event is a method in a class (likely a subclass) that overrides a base class method. This function is responsible for describing a ""final event"" based on certain conditions, either as byte-range information or as bit-range information. Here's how it works:

Check Bound Conditions: The first condition checks whether there is a byte-bound (m_byte_bound) or the absence of a bit-bound (!m_bit_bound). If either of these conditions is true, the function proceeds to handle the event as bytes.

Handle Out-of-Bounds Bytes:

A byte_range object (out_of_bounds_bytes) is created, initialized with a range of (0, 0).
The function then attempts to retrieve the out-of-bounds byte range by calling get_out_of_bounds_bytes. If the function returns successfully, it describes the final event as bytes using describe_final_event_as_bytes.
The method then returns true to indicate that the event has been successfully described as bytes.
Handle Event as Bits: If the initial condition for byte-bound or bit-bound is not satisfied, the function proceeds to describe the final event as bits by calling describe_final_event_as_bits.

Return Value: The function always returns true, indicating that it successfully described the event, either as bytes or bits.

This function provides a mechanism to describe events in two different formats (bytes or bits) depending on the bound conditions and the availability of out-of-bounds byte information."
"static tree
maybe_get_integer_cst_tree (const svalue *sval)
{
  // Attempt to retrieve the constant tree from the svalue object.
  tree cst_tree = sval->maybe_get_constant ();
  
  // Check if the retrieved constant tree exists and is of type INTEGER_CST.
  if (cst_tree && TREE_CODE (cst_tree) == INTEGER_CST)
    return cst_tree;  // Return the constant tree if it is an integer constant.

  return NULL_TREE;  // Return NULL_TREE if it is not an integer constant.
}","The function maybe_get_integer_cst_tree attempts to retrieve an integer constant tree from an svalue object:

Retrieve Constant Tree: The function calls maybe_get_constant on the svalue object (sval) to get a potential constant tree. This method may return a constant or NULL_TREE if no constant exists.

Check Constant Type: If the cst_tree is valid (non-NULL_TREE), the function checks whether its type is INTEGER_CST (indicating an integer constant).

Return Constant Tree: If the constant is of type INTEGER_CST, the function returns the constant tree.

Return NULL_TREE: If the constant is either not found or not an integer constant, the function returns NULL_TREE.

This function ensures that only integer constants are returned from the svalue object, providing a mechanism for handling constant values in the context of integer arithmetic or expressions."
"void
call_details::set_any_lhs_with_defaults () const
{
  // Return early if there's no left-hand side (lhs) region.
  if (!m_lhs_region)
    return;

  // Attempt to retrieve a constant function result value.
  const svalue *sval = maybe_get_const_fn_result (*this);
  
  // If no constant value is found, handle the situation based on the function attribute.
  if (!sval)
    {
      region_model_manager *mgr = get_manager ();  // Get the region manager.

      // If the function is marked as 'malloc', handle the heap allocation.
      if (lookup_function_attribute (""malloc""))
	{
	  // Create a new region for heap allocation and mark it as unknown.
	  const region *new_reg
	    = m_model->get_or_create_region_for_heap_alloc (NULL, m_ctxt);
	  m_model->mark_region_as_unknown (new_reg, NULL);

	  // Get or create a pointer svalue for the new region.
	  sval = mgr->get_ptr_svalue (get_lhs_type (), new_reg);
	}
      else
	// For functions without the 'const' attribute, use a conjured svalue.
	sval = get_or_create_conjured_svalue (m_lhs_region);
      
      // If the size of the result in bytes is available, set dynamic extents.
      if (const svalue *size_in_bytes = get_result_size_in_bytes (*this))
	{
	  const region *reg
	    = m_model->deref_rvalue (sval, NULL_TREE, m_ctxt, false);
	  m_model->set_dynamic_extents (reg, size_in_bytes, m_ctxt);
	}
    }
  
  // Set the left-hand side value.
  maybe_set_lhs (sval);
}","Technical Description:
The function set_any_lhs_with_defaults is designed to set the value of a left-hand side (LHS) variable in the context of a function call. It does so by checking for specific conditions and setting default values or dynamic extents as needed:

Early Return for Missing LHS Region: If the left-hand side region (m_lhs_region) is not set, the function returns early without further processing.

Attempt to Retrieve Constant Function Result: The function first attempts to retrieve a constant value (sval) associated with the function call through the maybe_get_const_fn_result method.

Handle Function Attributes:

If no constant result is found (sval is nullptr), the function checks whether the function is marked with the ""malloc"" attribute (indicating dynamic memory allocation).
For malloc-like functions, a new region is created for the heap allocation, and it is marked as unknown. A pointer to this region is then obtained.
For functions without a const attribute, a ""conjured"" value is created to represent the result.
Set Dynamic Extents: If the size of the result in bytes is available, the function retrieves the dereferenced value (reg) and sets dynamic extents for it using set_dynamic_extents.

Set Left-Hand Side (LHS): Finally, the function attempts to set the left-hand side of the call (m_lhs) with the computed or retrieved sval.

This function helps manage the state of the LHS variable in the context of a function call, especially for dynamically allocated memory or functions with complex behaviors like malloc."
"const char *
call_details::get_arg_string_literal (unsigned idx) const
{
  // Retrieve the argument value for the given index.
  const svalue *str_arg = get_arg_svalue (idx);
  
  // Check if the argument can be converted to a region.
  if (const region *pointee = str_arg->maybe_get_region ())
    // If the region is of type string_region, extract the constant string.
    if (const string_region *string_reg = pointee->dyn_cast_string_region ())
      {
        // Retrieve the constant string associated with the string_region.
        tree string_cst = string_reg->get_string_cst ();
        
        // Return the pointer to the string's data.
        return TREE_STRING_POINTER (string_cst);
      }
  
  // Return NULL if the argument isn't a string literal.
  return NULL;
}","The function get_arg_string_literal is used to retrieve the string literal from a function argument, based on the index idx:

Retrieve Argument Value: The function first retrieves the argument value for the given index idx using get_arg_svalue. This returns an svalue object representing the argument at the specified index.

Check if the Argument is a Region: It then checks if this argument can be interpreted as a region using maybe_get_region. If successful, it checks whether the region is specifically a string_region.

Extract Constant String: If the argument is a string_region, the function calls get_string_cst on the string_region object to obtain the constant string (tree object).

Return the String Pointer: The pointer to the string's data is then extracted using TREE_STRING_POINTER and returned.

Return NULL for Non-String Arguments: If the argument is not a string or cannot be interpreted as a string region, the function returns NULL.

This function is helpful for extracting string literals from the arguments of a function call, particularly when dealing with values that are represented as regions or constants in the program's memory model."
"void
call_details::dump_to_pp (pretty_printer *pp, bool simple) const
{
  // Print the string ""gcall: "" to the pretty printer.
  pp_string (pp, ""gcall: "");
  
  // Dump the gimple statement corresponding to the function call.
  pp_gimple_stmt_1 (pp, m_call, 0 /* spc */, TDF_NONE /* flags */);
  pp_newline (pp);
  
  // Print ""return region: "" and the region if it exists.
  pp_string (pp, ""return region: "");
  if (m_lhs_region)
    // If a left-hand side region exists, dump its details.
    m_lhs_region->dump_to_pp (pp, simple);
  else
    // If no left-hand side region exists, print ""NULL"".
    pp_string (pp, ""NULL"");
  
  pp_newline (pp);
  
  // Iterate over the function call arguments and print each argument's value.
  for (unsigned i = 0; i < gimple_call_num_args (m_call); i++)
    {
      const svalue *arg_sval = get_arg_svalue (i);  // Get the argument value.
      
      // Print the argument index.
      pp_printf (pp, ""arg %i: "", i);
      
      // Dump the argument's details.
      arg_sval->dump_to_pp (pp, simple);
      
      // Print a newline after each argument.
      pp_newline (pp);
    }
}","The function dump_to_pp is used to output the details of a function call, including the function itself, its return region, and the arguments passed to it. Here's the breakdown of the function's steps:

Print ""gcall:"": The function begins by printing the string ""gcall: "" to the pretty_printer (pp), followed by the representation of the function call (m_call) in GIMPLE format using pp_gimple_stmt_1.

Print Return Region: It then prints ""return region: "", followed by either the details of the return region (m_lhs_region) if it exists, or the string ""NULL"" if no return region is present. The region's details are printed by calling dump_to_pp on it.

Print Function Arguments: The function iterates over all the arguments of the function call. For each argument:

It retrieves the corresponding argument value (arg_sval) using get_arg_svalue.
It prints the argument index (e.g., ""arg 0: "").
The argument value is then printed by calling dump_to_pp on it.
Newline after Each Argument: After printing each argument, a newline is printed using pp_newline."
"bool emit (diagnostic_emission_context &ctxt) final override
{
  auto_diagnostic_group d;  // Create an auto-scoped diagnostic group for managing diagnostic messages.

  // Issue a warning if overlapping buffers are passed as arguments to the function m_fndecl.
  bool warned = ctxt.warn (""overlapping buffers passed as arguments to %qD"", m_fndecl);

  // TODO: Consider adding a visualization (e.g., drawing a picture) to help illustrate the warning.

  // If a warning was issued, provide additional information on the undefined behavior of the function
  // when passed overlapping buffers.
  if (warned)
    inform (DECL_SOURCE_LOCATION (m_fndecl),
            ""the behavior of %qD is undefined for overlapping buffers"", m_fndecl);

  // Return whether a warning was issued or not.
  return warned;
}","The function is designed to issue warnings for a common issue in low-level programming: the passing of overlapping buffers as function arguments. This can lead to undefined behavior, particularly in functions that manipulate memory buffers, as operations may inadvertently overwrite data.

The diagnostic system helps catch potential errors during static analysis or compilation, providing feedback to developers about code that may lead to runtime issues. This function’s primary role is to inform the developer about the risk of undefined behavior when passing overlapping buffers and to encourage fixing this problem before runtime."
"void call_summary::get_user_facing_desc (pretty_printer *pp) const
{
  // Retrieve the function declaration associated with this summary.
  tree fndecl = get_fndecl ();

  // If there are multiple summaries for the same function, try to use the return value to distinguish between them.
  if (m_per_fn_data->m_summaries.length () > 1)
    {
      // Check if the function has a return value.
      if (tree result = DECL_RESULT (fndecl))
	{
	  // Retrieve the region model and get the corresponding region for the return value.
	  const region *result_reg
	    = get_state ().m_region_model->get_lvalue (result, NULL);

	  // Retrieve the store value for the return value region.
	  const svalue *result_sval
	    = get_state ().m_region_model->get_store_value (result_reg, NULL);

	  // Switch on the type of the result value.
	  switch (result_sval->get_kind ())
	    {
	    default:
	      break;
	    case SK_REGION:
	      {
		// If the result is a region, cast to a region_svalue and check the region kind.
		const region_svalue *region_sval
		  = as_a <const region_svalue *> (result_sval);
		const region *pointee_reg = region_sval->get_pointee ();
		
		// Switch on the kind of the pointee region.
		switch (pointee_reg->get_kind ())
		  {
		  default:
		    break;
		  case RK_HEAP_ALLOCATED:
		    // If the pointee is heap-allocated, print a description with the return value pointing to a heap-allocated buffer.
		    pp_printf (pp,
			       ""when %qE returns pointer""
			       "" to heap-allocated buffer"",
			       fndecl);
		    return;
		  }
	      }
	      break;
	    case SK_CONSTANT:
	      {
		// If the result is a constant, cast to a constant_svalue and retrieve the constant value.
		const constant_svalue *constant_sval
		  = as_a <const constant_svalue *> (result_sval);
		tree cst = constant_sval->get_constant ();

		// Check if the constant is a null pointer and print the appropriate description.
		if (POINTER_TYPE_P (TREE_TYPE (result))
		    && zerop (cst))
		  pp_printf (pp, ""when %qE returns NULL"", fndecl);
		else
		  pp_printf (pp, ""when %qE returns %qE"", fndecl, cst);
		return;
	      }
	    }
	}
    }

  // Fallback: Print a generic description when no specific case is found.
  pp_printf (pp, ""when %qE returns"", fndecl);
}","The get_user_facing_desc function generates a description of a function's return value for user-facing diagnostics. The description is printed using the pretty_printer (pp), which formats the output. This function is part of the call_summary class and helps communicate the nature of the function’s return value in a human-readable format. It handles multiple possible return types and provides specific descriptions based on the type of the return value.

Here’s a breakdown of how the function works:

Function Declaration:

The function first retrieves the function declaration (fndecl) associated with the current call summary using get_fndecl().
Handling Multiple Summaries:

If the function has multiple summaries (e.g., multiple return paths), it tries to differentiate between them using the return value by checking if m_per_fn_data->m_summaries.length () > 1."
"// Dump a textual representation of the call summary to a pretty printer.
void
call_summary::dump_to_pp (const extrinsic_state &ext_state,  // The external state used for dumping.
                          pretty_printer *pp,               // The printer where the output will be written.
                          bool simple) const                // A flag to control the level of detail in the output.
{
  // Retrieve the description of the call summary.
  label_text desc = get_desc ();  // Get a description of the call summary.

  // Print the description with the format ""desc: %qs"" followed by a newline.
  pp_printf (pp, ""desc: %qs"", desc.get ());  // Format and print the description.
  pp_newline (pp);  // Insert a newline in the output.

  // Print the current state of the object using the state dump method.
  get_state ().dump_to_pp (ext_state, simple, true, pp);  // Dump the state to the printer with the provided external state and detail flag.
}","The dump_to_pp function is a member of the call_summary class that outputs a textual representation of the summary to a pretty_printer object (pp). It first retrieves a description of the summary using the get_desc() function, which returns a label_text. Then, the description is printed with the format ""desc: %qs"", followed by a newline. After printing the description, the function retrieves the current state of the object using get_state() and calls its dump_to_pp function to output additional state-related details to the pretty_printer. The ext_state and simple flags are passed to control the format and detail of the state dump."
"// Convert a summary svalue to a caller svalue, using caching to avoid redundant conversions.
const svalue *
call_summary_replay::convert_svalue_from_summary (const svalue *summary_sval)  // The summary svalue to be converted.
{
  gcc_assert (summary_sval);  // Assert that the summary svalue is not null.

  // Check if a conversion from summary_sval to caller_sval already exists in the cache.
  if (const svalue **slot = m_map_svalue_from_summary_to_caller.get (summary_sval))
    return *slot;  // If cached, return the cached caller svalue.

  // If not cached, perform the conversion.
  const svalue *caller_sval = convert_svalue_from_summary_1 (summary_sval);  // Convert the summary svalue.

  // Ensure the types of summary_sval and caller_sval are compatible, if both have types.
  if (caller_sval)  // Proceed if conversion was successful.
    if (summary_sval->get_type () && caller_sval->get_type ())  // Both svalues must have types.
      gcc_assert (types_compatible_p (summary_sval->get_type (), caller_sval->get_type ()));  // Assert type compatibility.

  // Add the newly converted svalue to the cache for future reference.
  add_svalue_mapping (summary_sval, caller_sval);  // Cache the mapping.

  return caller_sval;  // Return the converted caller svalue.
}","The convert_svalue_from_summary function is a member of the call_summary_replay class that converts a summary_sval (summary svalue) to a corresponding caller_sval (caller svalue). It first checks if the summary_sval is valid (non-null) using gcc_assert. Then, the function attempts to retrieve a previously cached value from the m_map_svalue_from_summary_to_caller mapping. If the mapping exists, it returns the cached caller_sval. If the mapping doesn't exist, it invokes convert_svalue_from_summary_1 to perform the conversion. After the conversion, it checks the types of the summary_sval and caller_sval for compatibility using types_compatible_p and asserts that they are compatible. Finally, it caches the newly converted value using add_svalue_mapping and returns the caller_sval."
"// Convert a summary region to a caller region, using caching to avoid redundant conversions.
const region *
call_summary_replay::convert_region_from_summary (const region *summary_reg)  // The summary region to be converted.
{
  gcc_assert (summary_reg);  // Assert that the summary region is not null.

  // Check if a conversion from summary_reg to caller_reg already exists in the cache.
  if (const region **slot = m_map_region_from_summary_to_caller.get (summary_reg))
    return *slot;  // If cached, return the cached caller region.

  // If not cached, perform the conversion.
  const region *caller_reg = convert_region_from_summary_1 (summary_reg);  // Convert the summary region.

  // Ensure the types of summary_reg and caller_reg are compatible, if both have types.
  if (caller_reg)  // Proceed if conversion was successful.
    if (summary_reg->get_type () && caller_reg->get_type ())  // Both regions must have types.
      gcc_assert (types_compatible_p (summary_reg->get_type (), caller_reg->get_type ()));  // Assert type compatibility.

  // Add the newly converted region to the cache for future reference.
  add_region_mapping (summary_reg, caller_reg);  // Cache the mapping.

  return caller_reg;  // Return the converted caller region.
}","The convert_region_from_summary function is a member of the call_summary_replay class that converts a summary_reg (summary region) to a corresponding caller_reg (caller region). The function first checks if the summary_reg is valid (non-null) using gcc_assert. Then, it tries to retrieve a cached caller_reg from the m_map_region_from_summary_to_caller mapping. If the mapping exists, the cached value is returned. If the mapping doesn't exist, the function proceeds to convert the summary_reg by invoking convert_region_from_summary_1. After the conversion, the function verifies that the types of the summary_reg and caller_reg are compatible using types_compatible_p and asserts type compatibility. Finally, it adds the newly converted region to the cache using add_region_mapping and returns the caller_reg."
"// Convert a summary binding key to a caller binding key. If the key is symbolic, 
// it involves converting the associated region as well.
const binding_key *
call_summary_replay::convert_key_from_summary (const binding_key *summary_key)  // The summary binding key to be converted.
{
  // If the key is concrete (non-symbolic), return it as it is.
  if (summary_key->concrete_p ())  // Check if the key is concrete.
    return summary_key;  // Return the concrete key.

  // If the key is symbolic, extract the region and convert it.
  const symbolic_binding *symbolic_key = (const symbolic_binding *)summary_key;  // Cast to symbolic_binding.
  const region *summary_reg = symbolic_key->get_region ();  // Get the region associated with the symbolic key.

  // Convert the summary region to the caller region.
  const region *caller_reg = convert_region_from_summary (summary_reg);  // Convert region.

  // If the region conversion fails, return NULL.
  if (!caller_reg)  // If the caller region is null (conversion failed).
    return NULL;  // Return NULL as the conversion was unsuccessful.

  // Retrieve the store manager from the region model manager.
  region_model_manager *mgr = get_manager ();  // Get the region model manager.
  store_manager *store_mgr = mgr->get_store_manager ();  // Get the store manager.

  // Return the symbolic binding for the caller region.
  return store_mgr->get_symbolic_binding (caller_reg);  // Retrieve and return the symbolic binding for the caller region.
}","The convert_key_from_summary function is a member of the call_summary_replay class that converts a summary_key (summary binding key) to a corresponding caller_key (caller binding key). If the provided summary_key is concrete (i.e., not symbolic), the function simply returns the summary_key as it is. If the key is symbolic, the function extracts the associated region from the symbolic_binding object and converts the summary_reg (summary region) to a caller_reg (caller region) using the convert_region_from_summary function. If the region conversion fails (i.e., the caller_reg is NULL), the function returns NULL. Otherwise, it retrieves the symbolic binding corresponding to the caller_reg using the store manager (store_mgr) and returns the corresponding symbolic binding."
"// This function sets the state for a given svalue (state value) in the state machine. 
// It ensures that the state is updated correctly, handling compound values and special cases like state 0.
bool
sm_state_map::impl_set_state (const svalue *sval,  // The state value to set.
			      state_machine::state_t state,  // The state to assign to the svalue.
			      const svalue *origin,  // The origin of the state change (typically the source of the update).
			      const extrinsic_state &ext_state)  // The extrinsic state that might influence the state setting.
{
  // Normalize the svalue to ensure it is in a canonical form.
  sval = canonicalize_svalue (sval, ext_state);

  // If the current state is already the desired state, no action is needed.
  if (get_state (sval, ext_state) == state)
    return false;  // Return false as no change is needed.

  // Ensure the svalue can have an associated state.
  gcc_assert (sval->can_have_associated_state_p ());

  // Check if the state machine allows inherited states.
  if (m_sm.inherited_state_p ())
    {
      // If the svalue is a compound svalue, recursively set states for its elements.
      if (const compound_svalue *compound_sval
	    = sval->dyn_cast_compound_svalue ())  // Check if the svalue is of type compound_svalue.
	for (auto iter : *compound_sval)  // Iterate over each element in the compound svalue.
	  {
	    const svalue *inner_sval = iter.second;  // Get the inner svalue.
	    if (inner_sval->can_have_associated_state_p ())  // Check if the inner svalue can have a state.
	      impl_set_state (inner_sval, state, origin, ext_state);  // Recursively set the state for the inner svalue.
	  }
    }

  // Special handling for state 0, which is considered the default value.
  if (state == 0)
    {
      // If the state value already exists in the map, remove it.
      if (m_map.get (sval))
	m_map.remove (sval);
      return true;  // Return true as the state removal is successful.
    }

  // Assert that the svalue is valid.
  gcc_assert (sval);

  // Store the new state in the map with the associated origin.
  m_map.put (sval, entry_t (state, origin));

  return true;  // Return true to indicate that the state has been successfully set.
}","The impl_set_state function sets the state for a given svalue (state value). It first canonicalizes the svalue to ensure it is in a normalized form. If the current state of the svalue matches the requested state, the function returns false without making any changes. The function asserts that the svalue can have an associated state. If the state machine's inherited state flag is set, the function recursively updates the states of any inner svalue elements in the case of compound svalue. The function then handles the special case of setting the state to 0, which removes the state from the internal map. For other states, the function adds the new state to the map. It returns true to indicate that the state has been successfully set."
"// This function handles the leak detection for a given svalue (state value). 
// If the svalue has an associated state, it attempts to purge it, or handles the leak accordingly.
void
sm_state_map::on_svalue_leak (const svalue *sval,  // The svalue that is detected as potentially leaking.
			      impl_region_model_context *ctxt)  // The context containing extrinsic state information.
{
  // Attempt to retrieve the state associated with the svalue.
  if (state_machine::state_t state = get_state (sval, ctxt->m_ext_state))
    {
      // If the state machine allows purging of the state, remove the svalue from the map.
      if (m_sm.can_purge_p (state))  
	m_map.remove (sval);  // Remove the svalue from the internal map.

      else
	// If the state cannot be purged, notify the context that a state leak has occurred.
	ctxt->on_state_leak (m_sm, sval, state);  // Call the context's handler for state leaks.
    }
}
","The on_svalue_leak function is triggered when an svalue (state value) is detected as potentially leaking (i.e., no longer needed or unreachable). The function checks if the svalue has an associated state. If a state is found, it checks whether the state machine can purge the state associated with the svalue. If the state can be purged, the svalue is removed from the internal map. If the state cannot be purged, the function triggers a leak handler (on_state_leak) to handle the leaked state appropriately."
"// This function handles the state reset process when a state value changes due to an unknown function call,
// especially when mutable states are involved.
void
sm_state_map::on_unknown_change (const svalue *sval,  // The svalue whose change has been detected.
				 bool is_mutable,  // A flag indicating whether the svalue is mutable.
				 const extrinsic_state &ext_state)  // The external state context for the operation.
{
  // A set to store svalues that need to be unset (removed).
  svalue_set svals_to_unset;

  // Iterate over all entries in the internal map of states.
  for (map_t::iterator iter = m_map.begin (); iter != m_map.end (); ++iter)
    {
      const svalue *key = (*iter).first;  // The key representing a state variable.
      entry_t e = (*iter).second;  // The entry containing the state and its associated data.

      // If the state is not reset when passed to an unknown function and it's mutable, skip it.
      if (!m_sm.reset_when_passed_to_unknown_fn_p (e.m_state, is_mutable))
	continue;

      // If the key matches the svalue whose change is detected, add it to the unset list.
      if (key == sval)
	svals_to_unset.add (key);

      // If the svalue is an initial value, check if it corresponds to an initialization of another value.
      if (const initial_svalue *init_sval = sval->dyn_cast_initial_svalue ())
	// Check if the key is also an initial value.
	if (const initial_svalue *init_key = key->dyn_cast_initial_svalue ())
	  {
	    // Compare the base region of the changed svalue with that of the key's svalue.
	    const region *changed_reg = init_sval->get_region ();
	    const region *changed_key = init_key->get_region ();
	    // If the regions match (i.e., key's region is within the base region of the changed svalue), unset the key.
	    if (changed_key->get_base_region () == changed_reg)
	      svals_to_unset.add (key);
	  }
    }

  // For all svalues that need to be unset, reset their state by setting it to 0.
  for (svalue_set::iterator iter = svals_to_unset.begin (); iter != svals_to_unset.end (); ++iter)
    impl_set_state (*iter, (state_machine::state_t)0, NULL, ext_state);  // Reset the state of the svalue.
}","The on_unknown_change function handles state changes in the context of unknown function calls or when mutable states are involved. It identifies states that need to be reset or unset based on certain conditions. For each state in the map, it checks whether the state should be reset when passed to an unknown function. If so, the state is marked for removal. Additionally, if an initial value (like a base region) is involved, it unsets any related states within the region. After identifying the states to unset, the function proceeds to reset them by invoking impl_set_state with a state of 0 (indicating removal)."
"// This function purges states that involve a specific svalue, resetting them if applicable.
void
sm_state_map::purge_state_involving (const svalue *sval,  // The svalue to check for involvement.
				     const extrinsic_state &ext_state)  // The external state context.
{
  // Check if the svalue is of kind SK_INITIAL or SK_CONJURED, as only these types are considered for purging.
  /* Currently svalue::involves_p requires this. */
  if (!(sval->get_kind () == SK_INITIAL || sval->get_kind () == SK_CONJURED))
    return;  // If the svalue is neither of these kinds, exit early.

  // A set to store svalues that are involved with the given svalue and need to be purged.
  svalue_set svals_to_unset;

  // Iterate over all entries in the map of states.
  for (map_t::iterator iter = m_map.begin (); iter != m_map.end (); ++iter)
    {
      const svalue *key = (*iter).first;  // The key representing a state variable.
      entry_t e = (*iter).second;  // The entry containing the state and its associated data.

      // If the state cannot be purged, skip this state.
      if (!m_sm.can_purge_p (e.m_state))
	continue;

      // If the key (state variable) involves the specified svalue, add it to the unset list.
      if (key->involves_p (sval))
	svals_to_unset.add (key);
    }

  // For all svalues that need to be purged, reset their state by setting it to 0.
  for (svalue_set::iterator iter = svals_to_unset.begin (); iter != svals_to_unset.end (); ++iter)
    impl_set_state (*iter, (state_machine::state_t)0, NULL, ext_state);  // Reset the state of the svalue.
}","The purge_state_involving function is designed to remove states associated with a specific svalue that involves another svalue in the state machine. The function first checks whether the svalue is of a certain type (either SK_INITIAL or SK_CONJURED) before proceeding. It then iterates through all the states in the map and checks whether each state's key ""involves"" the specified svalue. If the state can be purged and the key involves the svalue, it is added to a set of states to unset. Finally, the function resets those states by calling impl_set_state with a state of 0, effectively purging the states from the map."
"// This function compares two state maps (smap_a and smap_b) and returns an integer
// indicating their relative ordering:
//  - A negative value if smap_a is less than smap_b,
//  - A positive value if smap_a is greater than smap_b,
//  - Zero if both are equal.
int
sm_state_map::cmp (const sm_state_map &smap_a, const sm_state_map &smap_b)
{
  // First, compare the number of elements in both maps.
  if (int cmp_count = smap_a.elements () - smap_b.elements ())
    return cmp_count;  // Return the difference if the number of elements is not the same.

  // Prepare vectors to hold the keys from both state maps.
  auto_vec <const svalue *> keys_a (smap_a.elements ());
  for (map_t::iterator iter = smap_a.begin (); iter != smap_a.end (); ++iter)
    keys_a.quick_push ((*iter).first);  // Add each key from smap_a to the vector.
  keys_a.qsort (svalue::cmp_ptr_ptr);  // Sort the keys of smap_a.

  auto_vec <const svalue *> keys_b (smap_b.elements ());
  for (map_t::iterator iter = smap_b.begin (); iter != smap_b.end (); ++iter)
    keys_b.quick_push ((*iter).first);  // Add each key from smap_b to the vector.
  keys_b.qsort (svalue::cmp_ptr_ptr);  // Sort the keys of smap_b.

  // Compare each key in the sorted vectors.
  unsigned i;
  const svalue *sval_a;
  FOR_EACH_VEC_ELT (keys_a, i, sval_a)
    {
      const svalue *sval_b = keys_b[i];  // Get the corresponding key from smap_b.

      // If the keys differ, return the result of comparing them.
      if (int cmp_sval = svalue::cmp_ptr (sval_a, sval_b))
        return cmp_sval;

      // If the keys are the same, compare the associated entries.
      const entry_t *e_a = const_cast <map_t &> (smap_a.m_map).get (sval_a);
      const entry_t *e_b = const_cast <map_t &> (smap_b.m_map).get (sval_b);
      
      // If the entries differ, return the result of comparing them.
      if (int cmp_entry = entry_t::cmp (*e_a, *e_b))
        return cmp_entry;
    }

  // If no differences were found, return 0, indicating the maps are equal.
  return 0;
}","The cmp function compares two state maps (smap_a and smap_b) to determine their relative ordering. The function first compares the number of elements in the two maps. If the number of elements differs, the difference is returned. If the number of elements is the same, the function proceeds by sorting the keys of both state maps and comparing them in order. For each corresponding pair of keys, it compares the values (entries) associated with those keys. If a difference is found at any point in the keys or values, that difference is returned. If no difference is found after comparing all elements, the function returns 0, indicating that the two maps are equal."
"// This function attempts to canonicalize a given svalue, potentially
// normalizing it to a canonical representation if it meets certain conditions.
// In particular, if the svalue is a pointer and its constant value is zero,
// the function returns a canonical null pointer value.
const svalue *
sm_state_map::canonicalize_svalue (const svalue *sval,
				   const extrinsic_state &ext_state)
{
  // Get the region model manager from the extrinsic state.
  region_model_manager *mgr = ext_state.get_model_manager ();
  
  // Check if the region model manager exists, the svalue has a type,
  // and if the svalue's type is a pointer type.
  if (mgr && sval->get_type () && POINTER_TYPE_P (sval->get_type ()))
    {
      // Check if the svalue has a constant value, and if that constant is zero.
      if (tree cst = sval->maybe_get_constant ())
	if (zerop (cst))
	  {
	    // If the constant value is zero, return the canonical null pointer.
	    return mgr->get_or_create_constant_svalue (null_pointer_node);
	  }
    }

  // If the conditions are not met, simply return the original svalue.
  return sval;
}","The canonicalize_svalue function attempts to normalize or ""canonicalize"" a given svalue object based on its type and constant value. Specifically, if the svalue is of pointer type and holds a constant value of zero (i.e., a null pointer), the function returns a canonical null pointer value. This is done by interacting with the region_model_manager associated with the provided extrinsic_state. If the conditions are met (the svalue is a pointer and its constant value is zero), the function returns a canonical constant null_pointer_node. If the conditions are not met, it simply returns the original svalue."
"// Constructor for the program_state class. It initializes the state of the program
// using data from the provided extrinsic_state.
program_state::program_state (const extrinsic_state &ext_state)
: m_region_model (NULL),  // Initialize m_region_model to NULL.
  m_checker_states (ext_state.get_num_checkers ()),  // Initialize m_checker_states with the number of checkers.
  m_valid (true)  // Set the program state to be valid by default.
{
  // Get the engine associated with the extrinsic state.
  engine *eng = ext_state.get_engine ();
  
  // Retrieve the region model manager from the engine.
  region_model_manager *mgr = eng->get_model_manager ();
  
  // Create a new region model using the model manager.
  m_region_model = new region_model (mgr);

  // Get the number of checker states from the extrinsic state.
  const int num_states = ext_state.get_num_checkers ();
  
  // Loop through each checker state and create a corresponding sm_state_map.
  for (int i = 0; i < num_states; i++)
    {
      // Create a new state map for each checker, initialized with the state machine.
      sm_state_map *sm = new sm_state_map (ext_state.get_sm (i));
      
      // Add the newly created state map to the m_checker_states vector.
      m_checker_states.quick_push (sm);
    }
}","The constructor program_state::program_state initializes an object that represents the state of a program, using data from an extrinsic_state. The constructor first retrieves the model manager from the engine associated with the extrinsic_state and uses it to create a region_model. It then allocates a state map for each checker state in the extrinsic_state, storing each in the m_checker_states vector. The constructor ensures that the program state is valid and associates a region model with the engine's model manager."
"// The replay_call_summary function replays a call summary into the current state map.
bool
sm_state_map::replay_call_summary (call_summary_replay &r,
				   const sm_state_map &summary)
{
  // Iterate over each key-value pair in the summary's state map.
  for (auto kv : summary.m_map)
    {
      const svalue *summary_sval = kv.first;  // The svalue from the summary.
      
      // Convert the summary's svalue to the caller's svalue using the provided replay function.
      const svalue *caller_sval = r.convert_svalue_from_summary (summary_sval);
      
      // If conversion fails, skip this entry.
      if (!caller_sval)
	continue;
      
      // Ensure the caller's svalue can have an associated state.
      if (!caller_sval->can_have_associated_state_p ())
	continue;

      // Retrieve the origin of the summary's svalue.
      const svalue *summary_origin = kv.second.m_origin;
      
      // If there is an origin, convert it to the caller's origin, otherwise set to NULL.
      const svalue *caller_origin
	= (summary_origin
	   ? r.convert_svalue_from_summary (summary_origin)
	   : NULL);
      // caller_origin can be NULL.

      // Update the current map with the converted svalue and associated state.
      m_map.put (caller_sval, entry_t (kv.second.m_state, caller_origin));
    }
  
  // After processing all entries, update the global state.
  m_global_state = summary.m_global_state;
  
  // Return true, indicating that the replay was successful.
  return true;
}","The replay_call_summary function is designed to replay a call summary into the current state map. It processes each entry in the summary's state map, converts the summary's state values into caller-specific values, and updates the current map (m_map) with these converted values. The function handles conversion of both the state values (svalue) and their associated origins, ensuring the caller's state map is properly updated with the corresponding information from the summary. It also updates the m_global_state with the summary's global state."
"// Move constructor for program_state that transfers ownership of resources from another program_state.
program_state::program_state (program_state &&other)
: m_region_model (other.m_region_model),  // Move m_region_model from the other object.
  m_checker_states (other.m_checker_states.length ())  // Move m_checker_states with the same length as the other object.
{
  // Set the other object's m_region_model to NULL since its ownership is transferred.
  other.m_region_model = NULL;

  // Iterate over each element in the other object's m_checker_states vector.
  int i;
  sm_state_map *smap;
  FOR_EACH_VEC_ELT (other.m_checker_states, i, smap)
    // Move each sm_state_map element into the new object's m_checker_states vector.
    m_checker_states.quick_push (smap);

  // Truncate the other object's m_checker_states vector to indicate that it no longer owns the elements.
  other.m_checker_states.truncate (0);

  // Move the m_valid flag from the other object.
  m_valid = other.m_valid;
}","The program_state::program_state constructor is a move constructor that transfers the state from an existing program_state object (other) to a new one, effectively ""moving"" the resources while invalidating the original object. It moves the m_region_model and m_checker_states from other to the new instance. The m_checker_states vector is copied element by element, and other's vector is truncated (emptied) to indicate that its contents have been transferred. The m_valid flag is also moved from the original to the new object, completing the move operation."
"// Overloaded equality operator for comparing two program_state objects.
bool
program_state::operator== (const program_state &other) const
{
  // First, compare the m_region_model objects. If they are not equal, return false.
  if (!(*m_region_model == *other.m_region_model))
    return false;

  // Iterate through each sm_state_map in m_checker_states and compare them to the corresponding sm_state_map in the other object.
  int i;
  sm_state_map *smap;
  FOR_EACH_VEC_ELT (m_checker_states, i, smap)
    // If any sm_state_map is not equal, return false.
    if (!(*smap == *other.m_checker_states[i]))
      return false;

  // Perform an additional consistency check by comparing the hash values of the two objects.
  // The hash values must match for the objects to be considered equal.
  gcc_checking_assert (hash () == other.hash ());

  // If all comparisons passed, return true, indicating that the two program_state objects are equal.
  return true;
}","The operator== is an overloaded comparison operator for the program_state class, designed to compare two program_state objects for equality. It checks if the m_region_model and each element in the m_checker_states vector are equal between the two objects. If any part of the comparison fails, the function immediately returns false. Additionally, it includes an assertion to ensure that the hash values of both program_state objects are the same, providing a consistency check. If all the comparisons are successful, the function returns true, indicating that the two program_state objects are equal."
"// Function to convert the program state into a JSON object for serialization.
std::unique_ptr<json::object>
program_state::to_json (const extrinsic_state &ext_state) const
{
  // Create a new JSON object to hold the state information.
  auto state_obj = ::make_unique<json::object> ();

  // Add the store from the region model to the JSON object.
  // The 'store' represents the memory or data structure of the region model.
  state_obj->set (""store"", m_region_model->get_store ()->to_json ());
  
  // Add the constraints from the region model to the JSON object.
  // Constraints are conditions or limits placed on the state in the model.
  state_obj->set (""constraints"", m_region_model->get_constraints ()->to_json ());
  
  // If there is a current frame in the region model, add it to the JSON object.
  // The current frame represents the execution state at a particular point in the program.
  if (m_region_model->get_current_frame ())
    state_obj->set (""curr_frame"", m_region_model->get_current_frame ()->to_json ());

  // Add checker states as an object, with checker names as keys.
  // Checker states represent the state of various checkers used to monitor the program.
  {
    auto checkers_obj = ::make_unique<json::object> ();

    // Iterate over the checker states (m_checker_states) and add each non-empty state.
    int i;
    sm_state_map *smap;
    FOR_EACH_VEC_ELT (m_checker_states, i, smap)
      if (!smap->is_empty_p ())
	// Use the name from the extrinsic state as the key and the sm_state_map's JSON representation as the value.
	checkers_obj->set (ext_state.get_name (i), smap->to_json ());

    // Add the checkers object (which contains the checker states) to the main state object.
    state_obj->set (""checkers"", std::move (checkers_obj));
  }

  // Add the validity of the program state to the JSON object.
  // 'm_valid' indicates whether the program state is valid or not.
  state_obj->set_bool (""valid"", m_valid);

  // Return the fully constructed JSON object, which now contains all the program state information.
  return state_obj;
}","The function serializes the entire state of the program, including the region model, checker states, and validity status, into a structured JSON object, which can be used for purposes such as logging, transferring data, or debugging. The returned JSON object is ready to be used for further processing or storage."
"// Function to create a hierarchical tree widget representation of the program state for textual dumping.
std::unique_ptr<text_art::tree_widget>
program_state::make_dump_widget (const text_art::dump_widget_info &dwi) const
{
  using text_art::tree_widget;

  // Create the root tree widget for the program state.
  // This widget will have the title ""State"" and will serve as the container for all state components.
  std::unique_ptr<tree_widget> state_widget
    (tree_widget::from_fmt (dwi, nullptr, ""State""));

  // Add a child node to represent the region model.
  // The region model's details will be represented as a nested tree widget.
  state_widget->add_child (m_region_model->make_dump_widget (dwi));

  /* Add nodes for any sm_state_maps that have state information. */
  {
    int i;
    sm_state_map *smap;

    // Iterate over all checker states stored in m_checker_states.
    // For each checker state map (smap), check if it contains any state information.
    FOR_EACH_VEC_ELT (m_checker_states, i, smap)
      if (!smap->is_empty_p ())
	// Add a child widget for the checker state map with its associated region model.
	state_widget->add_child (smap->make_dump_widget (dwi, m_region_model));
  }

  // Return the fully constructed tree widget representing the program state.
  return state_widget;
}","The function is designed for debugging or visualization purposes, providing a detailed breakdown of the program state in a hierarchical and easy-to-read format. The tree widget can be printed, serialized, or displayed in a text-based interface, aiding developers in understanding and analyzing the state of the program."
"void
program_state::push_call (exploded_graph &eg, // The exploded graph representing the program's execution paths.
                          exploded_node *enode, // The specific node in the exploded graph representing a program state.
                          const gcall *call_stmt, // The function call statement triggering the state update.
                          uncertainty_t *uncertainty) // Pointer to uncertainty information, possibly modeling unknown or ambiguous states.
{
  /* Update state. */

  // Retrieve the program point from the exploded node, representing the state in the program's execution.
  const program_point &point = enode->get_point ();

  // Get the last statement in the supernode (a higher-level abstraction) of the program point.
  const gimple *last_stmt = point.get_supernode ()->get_last_stmt ();

  // Create a context object encapsulating the exploded graph, node, current state, this program state,
  // uncertainty information, and the last statement. This context provides the necessary information
  // for updating the region model.
  impl_region_model_context ctxt (eg, enode,
                                  &enode->get_state (), // Current state of the exploded node.
                                  this, // Pointer to the current program state.
                                  uncertainty, // Information about uncertainties, if any.
				  NULL, // Placeholder or optional additional context not used here.
                                  last_stmt); // The last statement in the current program point's supernode.

  // Update the region model to account for the function call, passing the call statement and the context object.
  m_region_model->update_for_gcall (call_stmt, &ctxt);
}","The push_call function updates the program state by handling a function call in the context of an exploded graph and an exploded node. It interacts with the region model, which represents the program's memory state, and updates it using information about the given function call statement. The function leverages an impl_region_model_context object to encapsulate the state and context of the exploded graph node, which facilitates the update process. This function is a critical part of program state management, ensuring that the memory and state changes due to function calls are accurately reflected."
"bool
program_state::can_purge_base_region_p (const extrinsic_state &ext_state, // External state information used for decision-making.
					const region *base_reg) const // The memory region being evaluated for purging.
{
  // Retrieve the binding cluster associated with the given base region from the store in the region model.
  binding_cluster *cluster
    = m_region_model->get_store ()->get_cluster (base_reg);

  // If the cluster does not exist (region has no associated bindings), it can be safely purged.
  if (!cluster)
    return true;

  // Iterate through all symbolic value bindings in the cluster.
  for (auto iter : *cluster)
    {
      const svalue *sval = iter.second; // Extract the symbolic value associated with the current binding.

      // Check if the symbolic value can be purged. If not, return false immediately.
      if (!can_purge_p (ext_state, sval))
	return false;
    }

  // If all symbolic values in the cluster are purgable, return true.
  return true;
}","The can_purge_base_region_p function determines whether a specified memory region (base_reg) can be safely purged from the program state. It interacts with the region_model to retrieve the bindings associated with the memory region and iterates through all the symbolic values (svalue) in the cluster. For each symbolic value, it invokes the helper method can_purge_p to verify whether the value is eligible for purging. If all values in the cluster are purgable, the function returns true; otherwise, it returns false. This function is essential for memory state optimization and cleanup."
"bool
program_state::can_merge_with_p (const program_state &other, // The other program state to merge with.
				 const extrinsic_state &ext_state, // External state for additional context.
				 const program_point &point, // Program point indicating the current state of execution.
				 program_state *out) const // The output program state to hold the merged result.
{
  // Ensure the output state pointer and the current region model are valid.
  gcc_assert (out);
  gcc_assert (m_region_model);

  /* Attempt to merge the symbolic state maps (sm_state_map) for all checkers. */
  int i;
  sm_state_map *smap;

  // Iterate through the state maps of the output program state's checkers.
  FOR_EACH_VEC_ELT (out->m_checker_states, i, smap)
    // If any symbolic state map cannot be merged, return false.
    if (!m_checker_states[i]->can_merge_with_p (*other.m_checker_states[i], // Check the ith state map of 'other'.
						ext_state.get_sm (i), // Get the corresponding state model from extrinsic state.
						ext_state, // Pass extrinsic state for context.
						&out->m_checker_states[i])) // Update the ith state map in the output state.
      return false;

  /* Attempt to merge the region models for the two program states. */
  if (!m_region_model->can_merge_with_p (*other.m_region_model, // Merge the region model of 'other' with 'this'.
					  point, // Provide the program point for context.
					  out->m_region_model, // Update the output state's region model.
					  &ext_state, // Pass extrinsic state for additional information.
					  this, &other)) // Provide references to both states for detailed merging logic.
    return false;

  // Canonicalize the merged region model to ensure consistency and normalization.
  out->m_region_model->canonicalize ();

  // If all merge operations succeeded, return true.
  return true;
}","The can_merge_with_p function checks whether two program states (this and other) can be merged into a single consistent state. This operation is crucial when combining execution paths in analysis, ensuring that the resultant state is logically coherent. The function first verifies if the symbolic state maps (sm_state_map) for each checker in the program states can be merged. If this succeeds, it attempts to merge the region models associated with the states. If both operations are successful, the output program state (out) is updated with the merged region model, and the function returns true. Otherwise, it returns false."
"void
program_state::validate (const extrinsic_state &ext_state) const
{
  /* Skip this validation step in a release build to save performance overhead.
     This directive ensures the function only runs in debugging or development builds. */
#if !CHECKING_P
  return; // Exit the function immediately if validation is disabled.
#endif

  // Assert that the number of checker states in the program state matches
  // the number of checkers defined in the extrinsic state.
  gcc_assert (m_checker_states.length () == ext_state.get_num_checkers ());

  // Delegate the validation of the region model to its own validate method.
  m_region_model->validate ();
}","The validate function performs consistency checks on the program state to ensure it adheres to the expected structure and relationships. Specifically, it checks that the number of checker states matches the number of checkers defined in the provided extrinsic_state. Additionally, it delegates validation of the region model to its validate method. These checks are performed only in debugging or development builds, as indicated by the conditional compilation directive. The function is intended to catch errors during development and is skipped in release builds to avoid unnecessary performance overhead.
"
"static void
log_set_of_svalues (logger *logger, const char *name,
		    const svalue_set &set)
{
  // Log the name of the set to identify the group of `svalue`s being logged.
  logger->log (name);

  // Increase the indentation level for hierarchical logging.
  logger->inc_indent ();

  // Create a vector to store the elements of the `svalue_set` for sorting.
  auto_vec<const svalue *> sval_vecs (set.elements ());

  // Iterate through the `svalue_set` and populate the vector with its elements.
  for (svalue_set::iterator iter = set.begin ();
       iter != set.end (); ++iter)
    sval_vecs.quick_push (*iter);

  // Sort the vector of `svalue` pointers using a custom comparator for consistent ordering.
  sval_vecs.qsort (svalue::cmp_ptr_ptr);

  // Iterate over the sorted vector to log each `svalue`.
  unsigned i;
  const svalue *sval;
  FOR_EACH_VEC_ELT (sval_vecs, i, sval)
    {
      // Start a new log line for the current `svalue`.
      logger->start_log_line ();

      // Retrieve the logger's pretty printer for formatted output.
      pretty_printer *pp = logger->get_printer ();

      // Optionally include the pointer address in the log if the `flag_dump_noaddr` is not set.
      if (!flag_dump_noaddr)
	{
	  pp_pointer (pp, sval);  // Print the pointer address of the `svalue`.
	  pp_string (pp, "": "");   // Append a colon for separation.
	}

      // Log the detailed representation of the `svalue` using its dump method.
      sval->dump_to_pp (pp, false);

      // End the log line after dumping the `svalue` details.
      logger->end_log_line ();
    }

  // Decrease the indentation level to match the previous state.
  logger->dec_indent ();
}","The log_set_of_svalues function logs a collection of svalue objects using a provided logger. The function first logs the name of the set and increases the indentation level to visually group related logs. It then iterates over the svalue_set, collects its elements into a vector, and sorts them using a custom comparator. For each svalue in the sorted collection, it logs detailed information, optionally including the object's address if the flag_dump_noaddr flag is not set. Finally, the function decreases the indentation level to restore the original logging structure. This helps developers debug or analyze the svalue states in an organized and hierarchical manner."
"bool
program_state::replay_call_summary (call_summary_replay &r,
				    const program_state &summary)
{
  // Replay the call summary for the region model.
  // If this fails, the function returns `false` to indicate the replay was unsuccessful.
  if (!m_region_model->replay_call_summary (r, *summary.m_region_model))
    return false;

  // Iterate through all checker states in the `summary` and replay each summary.
  for (unsigned sm_idx = 0; sm_idx < m_checker_states.length (); sm_idx++)
    {
      // Get the corresponding `sm_state_map` from the `summary`.
      const sm_state_map *summary_sm_map = summary.m_checker_states[sm_idx];

      // Replay the call summary for the current state's `sm_state_map`.
      m_checker_states[sm_idx]->replay_call_summary (r, *summary_sm_map);
    }

  // If the `summary` state is invalid, mark the current state as invalid.
  if (!summary.m_valid)
    m_valid = false;

  // Return `true` to indicate the replay was successful.
  return true;
}","The replay_call_summary function replays a call summary from a previously captured program_state (summary) and updates the current state accordingly. It begins by replaying the call summary for the region model, and if that fails, it exits with false. Then, it iterates through each sm_state_map in the summary's checker states and replays the corresponding summary for the current state's checker states. Finally, it checks the validity of the summary state; if the summary is invalid, it marks the current state as invalid. The function returns true if the replay is successful, maintaining consistency between the current state and the provided summary."
"void
program_state::impl_call_analyzer_dump_state (const gcall *call,
					      const extrinsic_state &ext_state,
					      region_model_context *ctxt)
{
  // Extract details from the function call to analyze the state.
  call_details cd (call, m_region_model, ctxt);

  // Retrieve the state machine name from the function's arguments (first argument).
  const char *sm_name = cd.get_arg_string_literal (0);

  // If the state machine name cannot be determined, log an error and return.
  if (!sm_name)
    {
      error_at (call->location, ""cannot determine state machine"");
      return;
    }

  // Retrieve the index of the state machine by name from the extrinsic state.
  unsigned sm_idx;
  if (!ext_state.get_sm_idx_by_name (sm_name, &sm_idx))
    {
      // Log an error if the state machine name is not recognized.
      error_at (call->location, ""unrecognized state machine %qs"", sm_name);
      return;
    }

  // Retrieve the state map associated with the identified state machine index.
  const sm_state_map *smap = m_checker_states[sm_idx];

  // Extract the second argument as the state value (`svalue`).
  const svalue *sval = cd.get_arg_svalue (1);

  // If the state value is cast to an int (e.g., due to variadic arguments),
  // strip off the cast to retrieve the original value.
  if (const svalue *cast = sval->maybe_undo_cast ())
    sval = cast;

  // Retrieve the current state of the state machine for the given state value.
  state_machine::state_t state = smap->get_state (sval, ext_state);

  // Log the state’s name as a warning message at the call's location.
  warning_at (call->location, 0, ""state: %qs"", state->get_name ());
}","The impl_call_analyzer_dump_state function inspects and reports the state of a particular state machine for a given function call (call). It begins by extracting details from the function call to determine the state machine name. If the name is invalid or unrecognized, appropriate error messages are logged. Once the state machine is identified, it retrieves the associated sm_state_map and extracts the state value (value) from the function's arguments. Any casting applied to the value is undone to retrieve the original state value. The function then queries the state machine to determine the current state associated with the value and logs a warning message containing the state’s name. This function is used for debugging or analyzing the internal state of state machines during program execution."
"static void
test_program_state_2 ()
{
  // Create a global pointer variable named ""p"" with type `ptr_type_node`.
  // This simulates a global pointer in the program being analyzed.
  tree p = build_global_decl (""p"", ptr_type_node);

  // Create a string literal ""foo"" in memory and obtain a pointer to it.
  // This will be the value to which the pointer `p` points.
  tree string_cst_ptr = build_string_literal (4, ""foo"");

  // Create a vector of state machines (empty in this case) and an engine instance.
  auto_delete_vec<state_machine> checkers; // Used to manage state machines.
  engine eng;                              // Simulation engine.
  extrinsic_state ext_state (checkers, &eng); // Initialize extrinsic state with checkers and engine.

  // Initialize a new program state with the extrinsic state.
  program_state s (ext_state);

  // Get the region model from the program state. This model tracks memory regions.
  region_model *model = s.m_region_model;

  // Retrieve the memory region (or lvalue) associated with the pointer `p`.
  const region *p_reg = model->get_lvalue (p, NULL);

  // Retrieve the svalue (symbolic value) associated with the string constant pointer.
  const svalue *str_sval = model->get_rvalue (string_cst_ptr, NULL);

  // Set the value of the memory region for `p` to point to the string constant's svalue.
  // This establishes the relationship that `p` points to ""foo"".
  model->set_value (p_reg, str_sval, NULL);
}","The test_program_state_2 function is a test utility that creates a simulated program state to verify how a global pointer variable (p) is managed in a program's memory model. The pointer p is set to point to a string constant (""foo""), and the function initializes the associated program state and region model. It demonstrates how the program_state and its region model can track and set values for global pointer variables and their associated values in memory. This test helps validate the interaction between pointers, memory regions, and program states."
"symbolic_byte_offset::symbolic_byte_offset (region_offset offset,
					    region_model_manager &mgr)
{
  // Check if the offset is concrete (i.e., a specific value rather than symbolic).
  if (offset.concrete_p ())
    {
      // Get the bit offset from the concrete region offset.
      bit_offset_t num_bits = offset.get_bit_offset ();

      // Assert that the bit offset is a multiple of the size of a unit (in bits).
      gcc_assert (num_bits % BITS_PER_UNIT == 0);

      // Convert the bit offset to bytes. 
      // The number of bytes is the bit offset divided by the number of bits per byte.
      byte_offset_t num_bytes = num_bits / BITS_PER_UNIT;

      // Create a symbolic constant representing the byte offset using the region model manager.
      m_num_bytes_sval = mgr.get_or_create_int_cst (size_type_node, num_bytes);
    }
  else
    // If the offset is symbolic, directly assign the symbolic byte offset.
    m_num_bytes_sval = offset.get_symbolic_byte_offset ();
}","The symbolic_byte_offset constructor initializes an object that represents the byte offset in a symbolic or concrete form. It takes a region_offset (which could be either concrete or symbolic) and a region_model_manager as input. If the region_offset is concrete (i.e., it can be resolved to an actual numeric value), the constructor computes the byte offset based on the bit offset. If the offset is symbolic, it directly uses the symbolic byte offset from the region_offset. The constructor ensures that the computed byte offset is consistent with the unit size (assuming the unit size is in bytes) and interacts with the region_model_manager to obtain or create the necessary constant values."
"void
symbolic_byte_range::dump_to_pp (pretty_printer *pp,
				 bool simple,
				 region_model_manager &mgr) const
{
  // Check if the byte range is empty.
  if (empty_p ())
    {
      // If the range is empty, print ""empty"" and return.
      pp_string (pp, ""empty"");
      return;
    }

  // Check if the size of the byte range is a constant.
  if (tree size_cst = m_size.maybe_get_constant ())
    // If the size is constant and equals one byte.
    if (integer_onep (size_cst))
      {
        // Print the start of the range with the label ""byte"" for a range of size 1.
        pp_string (pp, ""byte "");
        // Print the start of the range using the svalue of the start.
        m_start.get_svalue ()->dump_to_pp (pp, simple);
        return;
      }

  // If the range size is more than 1 byte, print ""bytes"" label.
  pp_string (pp, ""bytes "");
  // Print the start of the byte range.
  m_start.get_svalue ()->dump_to_pp (pp, simple);
  // Print the ""to"" keyword.
  pp_string (pp, "" to "");
  // Get and print the last byte offset in the range.
  get_last_byte_offset (mgr).get_svalue ()->dump_to_pp (pp, simple);
}","The dump_to_pp function is a method for printing the details of a symbolic_byte_range object to a pretty_printer. It handles the case where the byte range is empty and outputs a corresponding string. If the range has a constant size, it checks if the size is one byte. In that case, it prints the start of the range with the label ""byte"". Otherwise, it prints the start and end of the byte range in a readable format. The function interacts with the region_model_manager to obtain the last byte offset when necessary and calls the dump_to_pp method of other involved objects to format and print them."
"symbolic_byte_offset
symbolic_byte_range::get_last_byte_offset (region_model_manager &mgr) const
{
  // Ensure the byte range is not empty.
  gcc_assert (!empty_p ());

  // Create a symbolic offset representing 1 byte.
  const symbolic_byte_offset one (1, mgr);

  // Compute and return the last byte offset by subtracting 1 from the next byte offset.
  return symbolic_byte_offset
    (
      // Create a binary operation for subtracting 1 from the next byte offset.
      mgr.get_or_create_binop (size_type_node,
                               MINUS_EXPR, // The subtraction operator.
                               get_next_byte_offset (mgr).get_svalue (), // Get the next byte offset.
                               one.get_svalue ()) // Subtract 1.
    );
}","The get_last_byte_offset function computes the last byte offset of a symbolic_byte_range object. It first checks if the byte range is not empty using the empty_p() method. If the range is not empty, it creates a symbolic symbolic_byte_offset representing a value of 1. The function then retrieves the next byte offset in the range and subtracts 1 from it using the MINUS_EXPR operation. This operation is performed with the help of the region_model_manager, which creates the appropriate binary operation. The result of this subtraction is the last byte offset in the range, returned as a symbolic_byte_offset."
"record_layout::record_layout (tree record_type)
{
  // Ensure the provided type is a RECORD_TYPE (e.g., struct or class).
  gcc_assert (TREE_CODE (record_type) == RECORD_TYPE);

  // Iterate through the fields of the record type.
  for (tree iter = TYPE_FIELDS (record_type); iter != NULL_TREE;
       iter = DECL_CHAIN (iter))  // Move to the next field.
    {
      // If the element is a field declaration, process it.
      if (TREE_CODE (iter) == FIELD_DECL)
	{
	  // Get the field's offset in bits.
	  int iter_field_offset = int_bit_position (iter);
	  bit_size_t size_in_bits;
	  
	  // Get the size of the field in bits; default to 0 if unavailable.
	  if (!int_size_in_bits (TREE_TYPE (iter), &size_in_bits))
	    size_in_bits = 0;

	  // Ensure there is padding between fields if needed.
	  maybe_pad_to (iter_field_offset);

	  // Add the field's information (its bit range and other properties) to the layout.
	  m_items.safe_push (item (bit_range (iter_field_offset,
					      size_in_bits),
				   iter, false));
	}
    }

  // After processing all fields, check if any trailing padding is needed.
  bit_size_t size_in_bits;
  if (int_size_in_bits (record_type, &size_in_bits))
    maybe_pad_to (size_in_bits);  // Add padding if the total size requires it.
}","The constructor of the record_layout class constructs a layout for a record type (a struct or class in C++). It begins by asserting that the provided type is indeed a RECORD_TYPE. The constructor then iterates through the fields of the record type, computing the field offset and the size in bits for each field. For each field, it adds the field's information to the m_items collection, which holds the layout details. The layout also accounts for any padding between fields and ensures the alignment of the record. Finally, the constructor checks the total size of the record type and potentially adds padding at the end to align the record to the appropriate boundary."
"void
record_layout::dump_to_pp (pretty_printer *pp) const
{
  // Declare local variables for iterating through the items in the record layout.
  unsigned i;
  item *it;

  // Iterate over each item in the m_items vector, which stores the record fields.
  FOR_EACH_VEC_ELT (m_items, i, it)
    {
      // Call dump_to_pp on each item to print its details using the provided pretty_printer.
      it->dump_to_pp (pp);

      // After each item is printed, insert a newline for proper formatting.
      pp_newline (pp);
    }
}","This function is responsible for printing the layout of a record type, which includes dumping information about each field of the record to a pretty printer (pretty_printer object). It iterates over the m_items vector (which holds the fields of the record layout), and for each field, it calls the dump_to_pp method of the item class to print its details. After printing each item, it adds a new line. The function ensures that the layout is formatted properly for readability by utilizing the pretty_printer to handle output."
"const record_layout::item *
record_layout::get_item_at (bit_offset_t offset) const
{
  // Declare local variables for iterating through the items in the record layout.
  unsigned i;
  item *it;

  // Iterate over each item in the m_items vector, which stores the record fields.
  FOR_EACH_VEC_ELT (m_items, i, it)
    {
      // Check if the current field contains the specified offset using the contains_p method.
      if (it->contains_p (offset))
        // If a match is found, return a pointer to the matching item (field).
        return it;
    }

  // If no field contains the given offset, return NULL.
  return NULL;
}","This function retrieves the item (field) from the record layout at a specific byte offset. It iterates over the m_items vector, which holds the fields of the record. For each field, it checks if the provided offset falls within the range of that field using the contains_p method. If a matching field is found, the function returns a pointer to that field (item). If no field contains the given offset, the function returns NULL, indicating that no item was found at the specified offset."
"void
record_layout::maybe_pad_to (bit_offset_t next_offset)
{
  // Check if there are any items (fields) in the record layout.
  if (m_items.length () > 0)
    {
      // Retrieve the last item in the m_items vector.
      const item &last_item = m_items[m_items.length () - 1];
      
      // Calculate the offset immediately after the last item in the layout.
      bit_offset_t offset_after_last_item
        = last_item.get_next_bit_offset ();

      // If the provided next_offset is greater than the offset after the last item,
      // it indicates there is a gap that needs to be filled with padding.
      if (next_offset > offset_after_last_item)
        {
          // Calculate the required padding size to align with the next_offset.
          bit_size_t padding_size
            = next_offset - offset_after_last_item;
          
          // Add the padding as a new item in the m_items vector.
          // The padding item spans the gap from offset_after_last_item to the next_offset.
          m_items.safe_push (item (bit_range (offset_after_last_item,
                                              padding_size),
                                   last_item.m_field, true));
        }
    }
void
record_layout::maybe_pad_to (bit_offset_t next_offset)
{
  // Check if there are any items (fields) in the record layout.
  if (m_items.length () > 0)
    {
      // Retrieve the last item in the m_items vector.
      const item &last_item = m_items[m_items.length () - 1];
      
      // Calculate the offset immediately after the last item in the layout.
      bit_offset_t offset_after_last_item
        = last_item.get_next_bit_offset ();

      // If the provided next_offset is greater than the offset after the last item,
      // it indicates there is a gap that needs to be filled with padding.
      if (next_offset > offset_after_last_item)
        {
          // Calculate the required padding size to align with the next_offset.
          bit_size_t padding_size
            = next_offset - offset_after_last_item;
          
          // Add the padding as a new item in the m_items vector.
          // The padding item spans the gap from offset_after_last_item to the next_offset.
          m_items.safe_push (item (bit_range (offset_after_last_item,
                                              padding_size),
                                   last_item.m_field, true));
        }
    }
}
","This function ensures that the record_layout is padded to align with the given next_offset. It checks if there is already at least one item in the m_items vector (which represents the fields in the record). If there are items, it calculates the offset after the last item in the layout. If the provided next_offset is greater than the calculated offset, indicating a gap, the function calculates the required padding size and adds a padding item to the m_items vector. The padding item is represented by a bit_range that spans the gap between the last item and the desired offset, with the field associated with this padding marked as a padding field."
"static bool
deterministic_p (const gasm *asm_stmt)
{
  /* Check if the assembly statement has no inputs and is volatile.
     Volatile statements with no inputs are assumed to query changeable state, 
     like the rdtsc instruction, which can give non-deterministic results. */
  if (gimple_asm_ninputs (asm_stmt) == 0
      && gimple_asm_volatile_p (asm_stmt))
    return false;

  /* If the assembly statement has inputs or is not volatile, assume it is deterministic
     and purely a function of its inputs. */
  return true;
}","This function checks whether a given assembly statement, represented by asm_stmt, is deterministic or not. The function first evaluates if the assembly statement is volatile and has no inputs. If it meets these conditions, it assumes the statement is querying changeable state (such as the rdtsc instruction, which reads the time stamp counter), and thus returns false, indicating non-determinism. For all other cases, the function assumes the assembly statement is purely a function of its inputs (i.e., it is deterministic), returning true."
"void
reachable_regions::add (const region *reg, bool is_mutable)
{
  /* Ensure the provided region is not null. */
  gcc_assert (reg);

  /* Get the base region associated with the given region. 
     The base region is typically the root or the main region in a set. */
  const region *base_reg = const_cast <region *> (reg->get_base_region ());
  gcc_assert (base_reg);

  /* Bail out if this base region is already in the set of reachable regions at the 
     IS_MUTABLE level of mutability. This ensures that we do not add duplicate regions 
     that are already present in the set. */
  if (!is_mutable && m_reachable_base_regs.contains (base_reg))
    return;  // The base region is already present in the reachable set.

  /* Add the base region to the set of reachable regions. */
  m_reachable_base_regs.add (base_reg);

  /* If the region is mutable, handle it separately. 
     Check if the base region is already in the set of mutable regions. */
  if (is_mutable)
    {
      /* If the base region is already in the mutable set, do nothing. */
      if (m_mutable_base_regs.contains (base_reg))
        return;  // The region is already mutable.
      else
        m_mutable_base_regs.add (base_reg);  // Add the base region to the mutable set.
    }

  /* Add values within the cluster associated with the base region. 
     If the region is part of a binding cluster, iterate over all values and 
     handle each one (e.g., adding it to the reachable set). */
  if (binding_cluster *bind_cluster = m_store->get_cluster (base_reg))
    bind_cluster->for_each_value (handle_sval_cb, this);  // Call the callback for each value in the cluster.
  else
    /* If no binding cluster is found, directly handle the value associated with the region. */
    handle_sval (m_model->get_store_value (reg, NULL));
}","The add function adds a region to a set of reachable regions, taking into account whether the region is mutable. The function first validates the input region, ensuring that it has a base region. If the region is not mutable, it checks if the base region is already present in the set of reachable regions and exits early if it is. If the region is mutable, it further checks if the base region is already in the set of mutable regions and adds it if necessary. Additionally, the function adds the values within the cluster of the region, processing them and adding any pointed-to values if they are pointers.
"
"void
reachable_regions::add (const region *reg, bool is_mutable)
{
  /* Ensure the provided region is not null. This prevents any invalid region pointers. */
  gcc_assert (reg);

  /* Retrieve the base region associated with the input region. 
     The base region often represents the root or main region in the cluster. */
  const region *base_reg = const_cast <region *> (reg->get_base_region ());
  gcc_assert (base_reg);

  /* If the region is not mutable and its base region is already in the reachable set, 
     we return early to avoid adding duplicate regions. */
  if (!is_mutable && m_reachable_base_regs.contains (base_reg))
    return;  // The base region is already present in the reachable set of non-mutable regions.

  /* Add the base region to the set of reachable regions. */
  m_reachable_base_regs.add (base_reg);

  /* If the region is mutable, process it separately. Ensure that the base region is also added 
     to the set of mutable regions if it is not already present. */
  if (is_mutable)
    {
      /* If the base region is already in the mutable set, do nothing and exit. */
      if (m_mutable_base_regs.contains (base_reg))
        return;  // The base region is already mutable, no further action needed.
      else
        /* Add the base region to the set of mutable regions, marking it as mutable. */
        m_mutable_base_regs.add (base_reg);
    }

  /* Check if the base region is part of a binding cluster. If it is, iterate through all values 
     in the cluster and process them by calling the appropriate callback function. */
  if (binding_cluster *bind_cluster = m_store->get_cluster (base_reg))
    bind_cluster->for_each_value (handle_sval_cb, this);  // Process each value in the cluster using the callback.
  else
    /* If no binding cluster is found, handle the store value directly using the `handle_sval` method. */
    handle_sval (m_model->get_store_value (reg, NULL));
}","The add function adds a given region to a set of reachable regions, taking into account whether the region is mutable or not. The function ensures that the region is valid, retrieves its base region, and avoids adding duplicate base regions. If the region is mutable, the function ensures the base region is added to the set of mutable regions. Additionally, the function handles the values within the region's binding cluster by either iterating over the values and processing them or directly processing the region's store value if no binding cluster is found. This function is essential for managing and updating the sets of reachable regions, both mutable and non-mutable, within the system."
"void
reachable_regions::mark_escaped_clusters (region_model_context *ctxt)
{
  /* Create a vector to store escaped function regions. Initialize it with the elements 
     from the mutable base regions set (m_mutable_base_regs). */
  auto_vec<const function_region *> escaped_fn_regs
    (m_mutable_base_regs.elements ());

  /* Iterate over the set of mutable base regions (m_mutable_base_regs). For each base region: */
  for (hash_set<const region *>::iterator iter = m_mutable_base_regs.begin ();
       iter != m_mutable_base_regs.end (); ++iter)
    {
      /* Retrieve the current base region from the set. */
      const region *base_reg = *iter;

      /* Mark the current base region as ""escaped"" in the store. */
      m_store->mark_as_escaped (base_reg);

      /* Check if the current base region is a function region. If so, add it to the list
         of escaped function regions (escaped_fn_regs). */
      if (const function_region *fn_reg = base_reg->dyn_cast_function_region ())
        escaped_fn_regs.quick_push (fn_reg);  // Add the function region to the list.
    }

  /* If a context (ctxt) is provided, process the escaped function regions: */
  if (ctxt)
    {
      /* Sort the escaped function regions to ensure deterministic order when processing them. */
      escaped_fn_regs.qsort (region::cmp_ptr_ptr);

      /* Iterate over the sorted list of escaped function regions and call the on_escaped_function 
         callback for each function, passing its function declaration (fndecl). */
      unsigned i;
      const function_region *fn_reg;
      FOR_EACH_VEC_ELT (escaped_fn_regs, i, fn_reg)
        ctxt->on_escaped_function (fn_reg->get_fndecl ());
    }
}","The mark_escaped_clusters function marks clusters of regions as ""escaped,"" meaning that the regions are no longer in the current scope and may have escaped from the context. Specifically, it operates on the mutable base regions in the set m_mutable_base_regs. For each base region, it calls the mark_as_escaped method on the store, and if the base region corresponds to a function region, it adds that function region to a list of escaped function regions. If a context (ctxt) is provided, it sorts the escaped function regions and calls a callback (on_escaped_function) on each escaped function to handle them in a deterministic manner."
"template <typename T>
static void
dump_set (const hash_set<const T *> &set, pretty_printer *pp)
{
  /* Create a vector to store the elements of the hash set. Initialize it with the elements 
     of the hash set, which contains pointers to objects of type T. */
  auto_vec<const T *> elements (set.elements ());

  /* Iterate through the hash set and add each element to the vector. */
  for (typename hash_set<const T *>::iterator iter = set.begin ();
       iter != set.end (); ++iter)
    elements.quick_push (*iter);  // Push each element from the set into the vector.

  /* Sort the elements in the vector using the static comparison method of T: T::cmp_ptr_ptr. 
     This ensures the elements are printed in a deterministic order. */
  elements.qsort (T::cmp_ptr_ptr);

  /* Iterate over the sorted elements and pretty-print each element. */
  unsigned i;
  const T *element;
  FOR_EACH_VEC_ELT (elements, i, element)
    {
      /* Print a prefix for each element (e.g., indentation). */
      pp_string (pp, ""  "");

      /* Call the dump_to_pp method on each element, passing true as the second argument. 
         This likely controls some specific formatting for the element's output. */
      element->dump_to_pp (pp, true);

      /* Print a newline after each element to separate them in the output. */
      pp_newline (pp);
    }
}","The dump_set function is a template function that dumps the contents of a hash set of pointers to objects of type T in a pretty-printed format. The function first retrieves all elements from the set, then sorts them using the static cmp_ptr_ptr method of type T. After sorting, it iterates over the sorted elements and uses the dump_to_pp method to pretty-print each element, appending a newline after each dump."
"state_machine::state_t
get_default_state (const svalue *sval) const final override
{
  /* Check if the svalue contains a constant value. If so, retrieve the constant. */
  if (tree cst = sval->maybe_get_constant ())
    {
      /* If the constant is an integer constant (INTEGER_CST), proceed with evaluation. */
      if (TREE_CODE (cst) == INTEGER_CST)
	{
	  /* Extract the integer value from the constant. */
	  int val = TREE_INT_CST_LOW (cst);

	  /* Check if the integer value is non-negative. If so, return m_constant_fd as the default state. */
	  if (val >= 0)
	    return m_constant_fd;  // Return state indicating a valid constant.

	  /* If the integer value is negative, return m_invalid as the default state. */
	  else
	    return m_invalid;  // Return state indicating an invalid constant.
	}
    }

  /* If no constant is found or the constant is not an integer, return m_start as the default state. */
  return m_start;  // Return the starting state if no valid constant is available.
}","The get_default_state function is a method that determines the default state of a state machine based on the value of an svalue object. It first checks if the svalue contains a constant value. If the constant is an integer, it evaluates whether the integer is non-negative or negative. Based on this evaluation, the function returns one of the predefined states (m_constant_fd, m_invalid, or m_start). If no constant value is found or the constant is not an integer, the default state m_start is returned."
"void
inform_filedescriptor_attribute (access_directions fd_dir)
{
  /* Check if an attribute name is associated with the file descriptor. */
  if (m_attr_name)
    /* Determine the access direction of the file descriptor and 
       provide an appropriate message based on the direction. */
    switch (fd_dir)
      {
      case DIRS_READ_WRITE:
        /* If the file descriptor must be open for both reading and writing,
           generate a diagnostic message. */
        inform (DECL_SOURCE_LOCATION (m_callee_fndecl),
                ""argument %d of %qD must be an open file descriptor, due to ""
                ""%<__attribute__((%s(%d)))%>"",
                m_arg_idx + 1,  // Argument index (1-based) in the function.
                m_callee_fndecl,  // The function declaration.
                m_attr_name,  // The attribute name associated with the constraint.
                m_arg_idx + 1);  // Argument index for the attribute.
        break;

      case DIRS_WRITE:
        /* If the file descriptor must be readable, generate a diagnostic message. */
        inform (DECL_SOURCE_LOCATION (m_callee_fndecl),
                ""argument %d of %qD must be a readable file descriptor, due ""
                ""to %<__attribute__((%s(%d)))%>"",
                m_arg_idx + 1,
                m_callee_fndecl,
                m_attr_name,
                m_arg_idx + 1);
        break;

      case DIRS_READ:
        /* If the file descriptor must be writable, generate a diagnostic message. */
        inform (DECL_SOURCE_LOCATION (m_callee_fndecl),
                ""argument %d of %qD must be a writable file descriptor, due ""
                ""to %<__attribute__((%s(%d)))%>"",
                m_arg_idx + 1,
                m_callee_fndecl,
                m_attr_name,
                m_arg_idx + 1);
        break;
      }
}","The inform_filedescriptor_attribute function provides diagnostics for function arguments that must meet specific file descriptor constraints due to attributes attached to the function. The function checks the direction of access (DIRS_READ_WRITE, DIRS_WRITE, or DIRS_READ) specified for a file descriptor argument and generates an appropriate message indicating the requirement. The message includes the argument number, the function name, and the attribute that imposes the restriction."
"bool
emit (diagnostic_emission_context &ctxt) final override
{
  /* CWE-775: Missing Release of File Descriptor or Handle after Effective Lifetime.
     This diagnostic warns about resource leaks that occur when file descriptors
     are not properly released after their effective usage lifetime. */
  ctxt.add_cwe (775);  // Add the CWE-775 identifier to the diagnostic context.

  /* Check if the file descriptor argument is specified. */
  if (m_arg)
    /* Emit a warning message specifying the leaking file descriptor. */
    return ctxt.warn (""leak of file descriptor %qE"", m_arg);
  else
    /* Emit a general warning about a file descriptor leak. */
    return ctxt.warn (""leak of file descriptor"");
}","The emit function generates a diagnostic warning when a potential file descriptor leak is detected. It identifies the issue as related to CWE-775 (Missing Release of File Descriptor or Handle after Effective Lifetime), a common software weakness that can lead to resource exhaustion. The function utilizes a diagnostic context to add the CWE identifier and issue an appropriate warning message. If a specific argument (m_arg) causing the leak is known, the warning explicitly references it; otherwise, a generic message is issued."
"bool
describe_state_change (pretty_printer &pp,
		       const evdesc::state_change &change) final override
{
  /* Check if the new state corresponds to an unchecked file descriptor
     by querying the state machine. */
  if (m_sm.is_unchecked_fd_p (change.m_new_state))
    {
      /* Record the event ID of the state change as an ""open"" event. */
      m_open_event = change.m_event_id;

      /* Print a descriptive message indicating the state transition. */
      pp_string (&pp, ""opened here"");

      /* Return true to indicate that the state change has been described. */
      return true;
    }

  /* If the new state is not an unchecked FD, delegate the description
     to the parent class implementation. */
  return fd_diagnostic::describe_state_change (pp, change);
}","The describe_state_change function analyzes and describes a state transition for a file descriptor (FD) within a state machine. It checks if the new state (m_new_state) corresponds to an ""unchecked file descriptor"" by querying the state machine (m_sm). If true, the function associates the event with the file descriptor as an ""open"" event and prints a descriptive message (""opened here"") using a pretty printer. If the new state is not an unchecked FD, it delegates the description task to the parent class (fd_diagnostic) for further handling."
"bool
describe_final_event (pretty_printer &pp,
		      const evdesc::final_event &ev) final override
{
  /* Check if the resource has a known ""open"" event. */
  if (m_open_event.known_p ())
    {
      /* If an expression for the event is available, include it in the message. */
      if (ev.m_expr)
	pp_printf (&pp,
		   ""%qE leaks here; was opened at %@"",
		   ev.m_expr, &m_open_event);
      else
	/* If no expression is provided, describe only the leak and its origin. */
	pp_printf (&pp,
		   ""leaks here; was opened at %@"",
		   &m_open_event);
    }
  else
    {
      /* If the ""open"" event is not known, only describe the leak. */
      if (ev.m_expr)
	pp_printf (&pp, ""%qE leaks here"", ev.m_expr);
      else
	/* Provide a generic message for the leak. */
	pp_string (&pp, ""leaks here"");
    }

  /* Return true to indicate that the event description has been handled. */
  return true;
}","The describe_final_event function provides a detailed description of a final event in the lifecycle of a resource, such as a file descriptor. Specifically, it checks if the resource was previously marked as ""opened"" (via the m_open_event member) and correlates this information with the event expression (ev.m_expr). Using a pretty_printer object, the function formats and outputs a message describing the leak's context, including where the resource was originally opened, if known. The function always returns true to indicate successful handling."
"bool
subclass_equal_p (const pending_diagnostic &base_other) const final override
{
  /* Safely cast the base_other diagnostic to fd_type_mismatch.
     This assumes that base_other is guaranteed to be of this type. */
  const fd_type_mismatch &sub_other = (const fd_type_mismatch &)base_other;

  /* Check if the base class properties are equal using the superclass's implementation. */
  if (!fd_param_diagnostic::subclass_equal_p(sub_other))
    return false; // Base class properties do not match.

  /* Compare subclass-specific properties for equality. */
  return (m_actual_state == sub_other.m_actual_state
          && m_expected_type == sub_other.m_expected_type);
}","The subclass_equal_p function determines whether two diagnostics of type fd_type_mismatch are considered equal based on their subclass-specific properties. It overrides a base class method to provide a type-safe comparison. This function first ensures that the base class properties are equal by calling the subclass_equal_p method of fd_param_diagnostic. Then, it compares the subclass-specific properties: m_actual_state and m_expected_type. The function returns true if all conditions are met and false otherwise."
"diagnostic_event::meaning
get_meaning_for_state_change (const evdesc::state_change &change)
  const final override
{
  /* Check if the state transition represents the acquisition of a resource.
     This happens when the old state is the start state and the new state is
     the ""unchecked"" state. */
  if (change.m_old_state == m_sm.get_start_state ()
      && change.m_new_state == m_sm.m_unchecked)
    return diagnostic_event::meaning(diagnostic_event::VERB_acquire,
                                     diagnostic_event::NOUN_resource);

  /* Check if the state transition represents the release of a resource.
     This happens when the new state is the ""closed"" state. */
  if (change.m_new_state == m_sm.m_closed)
    return diagnostic_event::meaning(diagnostic_event::VERB_release,
                                     diagnostic_event::NOUN_resource);

  /* For other transitions, return an empty meaning indicating no specific
     interpretation. */
  return diagnostic_event::meaning();
}","The get_meaning_for_state_change function is part of a diagnostic system that interprets state transitions in a state machine. It maps specific state changes to semantic meanings represented by verbs and nouns, which describe the nature of the transition. This function overrides a base class method and provides tailored behavior for transitions involving file descriptors or similar resources.

The function takes an evdesc::state_change object as input, which represents a transition from an old state (m_old_state) to a new state (m_new_state). Based on the specific states involved, it returns a diagnostic_event::meaning object containing appropriate verb and noun combinations."
"bool
custom_deallocator_set::contains_p (const deallocator *d) const
{
  /* Declare variables for iteration:
     - 'i' will hold the index of the current element.
     - 'cd' will store the current deallocator being checked. */
  unsigned i;
  const deallocator *cd;

  /* Iterate over the vector of deallocators (m_deallocator_vec).
     FOR_EACH_VEC_ELT is a macro that simplifies iteration over elements
     in the vector. */
  FOR_EACH_VEC_ELT (m_deallocator_vec, i, cd)
  {
    /* Check if the current deallocator matches the given deallocator (d). */
    if (cd == d)
      return true;  // The deallocator exists in the set.
  }

  /* If no match is found, return false. */
  return false;
}","The contains_p function checks whether a given deallocator object exists within a custom deallocator set. The set is implemented as a vector of deallocator pointers (m_deallocator_vec). The function iterates over the vector, comparing each element with the input deallocator pointer, and returns true if a match is found. If no match is found after examining all elements, the function returns false.

This function is useful in managing and querying collections of deallocators, ensuring that specific deallocation routines are recognized or tracked in a system."
"void
custom_deallocator_set::dump_to_pp (pretty_printer *pp) const
{
  /* Start the output with an opening curly brace. */
  pp_character (pp, '{');

  /* Declare variables for iteration:
     - 'i' holds the index of the current element.
     - 'd' stores the pointer to the current deallocator. */
  unsigned i;
  const deallocator *d;

  /* Iterate over all elements in the vector of deallocators. */
  FOR_EACH_VEC_ELT (m_deallocator_vec, i, d)
  {
    /* Add a comma and a space for all elements except the first. */
    if (i > 0)
      pp_string (pp, "", "");

    /* Call the `dump_to_pp` method on the current deallocator to
       print its representation to the pretty printer. */
    d->dump_to_pp (pp);
  }

  /* End the output with a closing curly brace. */
  pp_character (pp, '}');
}","The dump_to_pp function outputs the contents of a custom_deallocator_set to a pretty_printer object in a formatted manner. It iterates through the vector of deallocators (m_deallocator_vec), printing each deallocator's representation using their dump_to_pp method. The deallocators are enclosed within curly braces {} and separated by commas, providing a clean and structured visualization.

This function is typically used for debugging or logging purposes, allowing developers to inspect the current state of a custom_deallocator_set."
"void
malloc_state_machine::on_pop_frame (sm_state_map *smap,
				    const frame_region *frame_reg) const
{
  /* Temporary set to hold `svalue` objects that need clearing. */
  hash_set<const svalue *> svals_to_clear;

  /* Iterate through the state map to find states associated with the given frame. */
  for (auto kv : *smap)
    {
      const svalue *sval = kv.first;   // Retrieve the current `svalue` key.
      state_t state = kv.second.m_state; // Retrieve the current state value.

      /* Check if the current state is an 'assumed_non_null' state. */
      if (assumed_non_null_p (state))
	{
	  /* Cast the state to `assumed_non_null_state` to access its details. */
	  const assumed_non_null_state *assumed_state
	    = (const assumed_non_null_state *)state;

	  /* If the frame of the state matches the given `frame_reg`, mark it for clearing. */
	  if (frame_reg == assumed_state->m_frame)
	    svals_to_clear.add (sval);
	}
    }

  /* Iterate over the collected `svalue` objects and clear their states in the map. */
  for (auto sval : svals_to_clear)
    smap->clear_any_state (sval);
}","The malloc_state_machine::on_pop_frame function handles the event of ""popping"" a frame from the stack in a memory state machine. It identifies and clears all svalue entries in the state map (smap) that are associated with a given frame_region. This ensures that memory states linked to the removed frame are no longer tracked, maintaining consistency and avoiding invalid memory state references.

The function first iterates over the state map to identify states associated with the given frame, storing the corresponding svalue objects in a temporary collection. It then clears these states from the map. This behavior is essential for managing memory states dynamically as frames are created and destroyed."
"bool
malloc_state_machine::unaffected_by_call_p (tree fndecl)
{
  /* A set of functions that are known to not affect allocation
     status, even if we haven't fully modelled the rest of their
     behavior yet.  */
  
  // This array contains the names of functions that do not affect allocation.
  static const char * const funcnames[] = {
    /* This array must be kept sorted.  */
    ""strsep"", // Known function that does not affect allocation status.
  };
  
  const size_t count = ARRAY_SIZE (funcnames); // Size of the funcnames array.
  
  // Create a function_set to manage the list of unaffected function names.
  function_set fs (funcnames, count);

  // Check if the function declaration (fndecl) matches any of the unaffected functions.
  if (fs.contains_decl_p (fndecl))
    return true;  // If found, return true, indicating the function does not affect allocation.

  return false;  // If not found, return false, indicating the function might affect allocation.
}","The malloc_state_machine::unaffected_by_call_p function checks if a given function call (specified by fndecl) is known to not affect memory allocation status. This function is used to identify functions that do not alter the state of memory allocation, even if the complete behavior of the function has not been fully modeled.

The function operates by checking if the provided function declaration (fndecl) matches any known function names that are guaranteed not to affect memory allocation. These functions are maintained in a static, sorted array called funcnames. The function uses the function_set class to check if the function is part of the list of unaffected functions."
"void
malloc_state_machine::on_zero_assignment (sm_context &sm_ctxt,
					  const gimple *stmt,
					  tree lhs) const
{
  // Retrieve the current state of the left-hand side (lhs) of the assignment
  state_t s = sm_ctxt.get_state (stmt, lhs);

  // Determine the resource state associated with the retrieved state
  enum resource_state rs = get_rs (s);

  // If the resource state is one of the following, update the next state to ""null""
  if (rs == RS_START
      || rs == RS_UNCHECKED
      || rs == RS_NONNULL
      || rs == RS_FREED)
    {
      // Set the next state of the lhs to be the ""null"" state (m_null)
      sm_ctxt.set_next_state (stmt, lhs, m_null);
    }
}","The malloc_state_machine::on_zero_assignment function handles assignments to a variable in the state machine for tracking memory allocation states. It is specifically concerned with assignments that assign a zero value (which may indicate that a pointer is being set to NULL or an object is being ""freed""). The function checks the current state of the left-hand side (LHS) of the assignment (lhs) and updates its state based on predefined resource states.
"
"void
malloc_state_machine::
on_realloc_with_move (region_model *model,
		      sm_state_map *smap,
		      const svalue *old_ptr_sval,
		      const svalue *new_ptr_sval,
		      const extrinsic_state &ext_state) const
{
  // Update the state of the old pointer (old_ptr_sval) to indicate that it is now freed
  smap->set_state (model, old_ptr_sval,
		   m_free.m_deallocator.m_freed,  // State: Freed
		   NULL,                          // No additional data (NULL)
		   ext_state);                    // External state context

  // Update the state of the new pointer (new_ptr_sval) to indicate that it is now non-null
  smap->set_state (model, new_ptr_sval,
		   m_free.m_nonnull,              // State: Non-null
		   NULL,                          // No additional data (NULL)
		   ext_state);                    // External state context
}","The malloc_state_machine::on_realloc_with_move function is responsible for updating the states of pointers involved in a realloc operation where memory is moved. This typically occurs when reallocating a resource (such as memory) to a new location, and the system must ensure that the states of the old and new pointers are correctly updated to reflect this change."
"void
malloc_state_machine::transition_ptr_sval_non_null (region_model *model,
    sm_state_map *smap,
    const svalue *new_ptr_sval,
    const extrinsic_state &ext_state) const
{
  // Set the state of the new pointer (new_ptr_sval) to indicate that it is now non-null (valid memory)
  smap->set_state(model, new_ptr_sval, m_free.m_nonnull, NULL, ext_state);
}","This function is essential in a memory tracking system where reallocations are involved. When reallocating a resource (e.g., a pointer to memory), it is necessary to update the state machine to reflect that the old memory has been freed, and the new memory is valid and in use. The on_realloc_with_move function ensures that these changes are tracked correctly, helping to prevent memory leaks, dangling pointers, or other errors related to resource management."
"void
malloc_state_machine::on_phi (sm_context &sm_ctxt,
			      const supernode *node ATTRIBUTE_UNUSED,
			      const gphi *phi,
			      tree rhs) const
{
  // If the right-hand side of the Phi instruction is zero (null assignment)
  if (zerop (rhs))
    {
      // Get the left-hand side result of the Phi instruction
      tree lhs = gimple_phi_result (phi);
      
      // Call on_zero_assignment to handle memory state transition for zero assignment
      on_zero_assignment (sm_ctxt, phi, lhs);
    }
}","The malloc_state_machine::on_phi function handles the processing of Phi instructions in a control flow graph during a symbolic execution of a program, particularly when analyzing memory allocation states. A Phi instruction is used in static analysis to merge different values coming from different branches of a program. This function specifically deals with the case where the right-hand side (RHS) of the Phi instruction is zero, which is typically an indicator of a pointer being set to a null value. In such cases, it invokes on_zero_assignment to update the state of the memory management system accordingly."
"void
malloc_state_machine::on_condition (sm_context &sm_ctxt,
				    const supernode *node ATTRIBUTE_UNUSED,
				    const gimple *stmt,
				    const svalue *lhs,
				    enum tree_code op,
				    const svalue *rhs) const
{
  // If the right-hand side (rhs) is not zero, there's nothing to do
  if (!rhs->all_zeroes_p ())
    return;

  // If either the left-hand side (lhs) or right-hand side (rhs) is not a pointer, return early
  if (!any_pointer_p (lhs))
    return;
  if (!any_pointer_p (rhs))
    return;

  // If the condition is 'lhs != 0' (pointer is non-null)
  if (op == NE_EXPR)
    {
      log (""got 'ARG != 0' match"");
      
      // Get the state of the left-hand side (lhs)
      state_t s = sm_ctxt.get_state (stmt, lhs);
      
      // If the state is unchecked (pointer not initialized)
      if (unchecked_p (s))
	{
	  // Transition to a non-null state
	  const allocation_state *astate = as_a_allocation_state (s);
	  sm_ctxt.set_next_state (stmt, lhs, astate->get_nonnull ());
	}
    }
  // If the condition is 'lhs == 0' (pointer is null)
  else if (op == EQ_EXPR)
    {
      log (""got 'ARG == 0' match"");

      // Get the state of the left-hand side (lhs)
      state_t s = sm_ctxt.get_state (stmt, lhs);
      
      // If the state is unchecked (pointer not initialized)
      if (unchecked_p (s))
	{
	  // Transition to a null state (pointer is null)
	  sm_ctxt.set_next_state (stmt, lhs, m_null);
	}
    }
}","The malloc_state_machine::on_condition function handles conditional checks that involve comparisons between pointers (or other values) and zero. Specifically, it deals with conditions where the right-hand side (RHS) of the comparison is zero (e.g., checking for null pointers), and the left-hand side (LHS) is a pointer. The function evaluates whether the condition matches certain criteria, such as a pointer being non-null (!= 0) or null (== 0), and updates the state machine accordingly. It is part of a symbolic execution framework that tracks the states of memory allocations during program analysis."
"bool
malloc_state_machine::unaffected_by_call_p (tree fndecl)
{
  /* A set of functions that are known to not affect allocation
     status, even if we haven't fully modeled the rest of their
     behavior yet.  
  */
  static const char * const funcnames[] = {
    /* This array must be kept sorted. */
    ""strsep"",  // Example function that doesn't affect allocation status
  };

  const size_t count = ARRAY_SIZE(funcnames);  // Calculate the size of the funcnames array
  function_set fs(funcnames, count);           // Create a function_set object with the function names

  // Check if the function declaration matches any function in the set
  if (fs.contains_decl_p(fndecl))
    return true;  // Function doesn't affect allocation status

  return false;  // Function does affect allocation status
}","The function malloc_state_machine::unaffected_by_call_p checks whether a particular function, identified by its declaration (fndecl), is known to not affect the allocation status in memory. It specifically handles cases where certain functions are known to not alter the allocation state, even if their full behavior hasn't been modeled. In this case, the function strsep is hard-coded as an example of such a function. The function works by checking if the function declaration (fndecl) corresponds to one of the functions in a pre-defined set (funcnames), and if so, returns true, indicating that it does not affect allocation status. Otherwise, it returns false."
"void
malloc_state_machine::on_zero_assignment (sm_context &sm_ctxt,
					  const gimple *stmt,
					  tree lhs) const
{
  // Get the current state of the left-hand side (lhs) of the assignment
  state_t s = sm_ctxt.get_state (stmt, lhs);
  
  // Get the resource state from the current state (s)
  enum resource_state rs = get_rs (s);

  // Check if the resource state is one of the following:
  // - RS_START: The resource has just been created or is in its initial state.
  // - RS_UNCHECKED: The resource state has not been evaluated yet.
  // - RS_NONNULL: The resource is valid (non-null).
  // - RS_FREED: The resource has already been freed.
  if (rs == RS_START
      || rs == RS_UNCHECKED
      || rs == RS_NONNULL
      || rs == RS_FREED)
  {
    // Set the next state of lhs to m_null (indicating the resource is nullified)
    sm_ctxt.set_next_state (stmt, lhs, m_null);
  }
}","The function malloc_state_machine::on_zero_assignment is responsible for handling assignments where the left-hand side (LHS) of the statement (lhs) is assigned the value 0. This typically signifies a deallocation or reset of a pointer in memory. The function checks the current state of the LHS variable and, depending on its state, updates its state to m_null. This process is useful in tracking the memory status during symbolic execution or static analysis of the program, where states represent whether a variable is allocated, freed, or uninitialized."
"void
malloc_state_machine::on_zero_assignment (sm_context &sm_ctxt,
					  const gimple *stmt,
					  tree lhs) const
{
  // Get the current state of the left-hand side (lhs) of the assignment
  state_t s = sm_ctxt.get_state (stmt, lhs);
  
  // Get the resource state from the current state (s)
  enum resource_state rs = get_rs (s);

  // Check if the resource state is one of the following:
  // - RS_START: The resource has just been created or is in its initial state.
  // - RS_UNCHECKED: The resource state has not been evaluated yet.
  // - RS_NONNULL: The resource is valid (non-null).
  // - RS_FREED: The resource has already been freed.
  if (rs == RS_START
      || rs == RS_UNCHECKED
      || rs == RS_NONNULL
      || rs == RS_FREED)
  {
    // Set the next state of lhs to m_null (indicating the resource is nullified)
    sm_ctxt.set_next_state (stmt, lhs, m_null);
  }
}","The function malloc_state_machine::on_zero_assignment is responsible for handling assignments where the left-hand side (LHS) of the statement (lhs) is assigned the value 0. This typically signifies a deallocation or reset of a pointer in memory. The function checks the current state of the LHS variable and, depending on its state, updates its state to m_null. This process is useful in tracking the memory status during symbolic execution or static analysis of the program, where states represent whether a variable is allocated, freed, or uninitialized."
"void
region_model::on_realloc_with_move (const call_details &cd,
				    const svalue *old_ptr_sval,
				    const svalue *new_ptr_sval)
{
  // Get the context of the current call from the call details
  region_model_context *ctxt = cd.get_ctxt ();
  if (!ctxt)
    return;  // Exit if no context is found
  
  // Get the extrinsic state from the context, which carries additional information
  const extrinsic_state *ext_state = ctxt->get_ext_state ();
  if (!ext_state)
    return;  // Exit if no extrinsic state is found

  // Retrieve the state machine map, state machine, and its index from the context
  sm_state_map *smap;
  const state_machine *sm;
  unsigned sm_idx;
  if (!ctxt->get_malloc_map (&smap, &sm, &sm_idx))
    return;  // Exit if no state machine map is found
  
  // Ensure that the state machine map and state machine are valid
  gcc_assert (smap);
  gcc_assert (sm);

  // Cast the state machine to a malloc_state_machine for realloc-related operations
  const malloc_state_machine &malloc_sm
    = (const malloc_state_machine &)*sm;

  // Update the state of the old and new pointers based on the malloc state machine
  malloc_sm.on_realloc_with_move (this,
				  smap,
				  old_ptr_sval,
				  new_ptr_sval,
				  *ext_state);
}","The region_model::on_realloc_with_move function is designed to handle memory reallocation operations where a pointer is moved from one memory location (old_ptr_sval) to a new location (new_ptr_sval). It coordinates the process of state transitions between the old and new pointers within the region model context. This function ensures that memory management, specifically reallocations, is properly tracked and the state of the involved pointers is updated accordingly in the associated state machine."
"void
region_model::transition_ptr_sval_non_null (region_model_context *ctxt,
                                            const svalue *ptr_sval)
{
  // Check if the context is valid; if not, return early
  if (!ctxt)
    return;

  // Retrieve the extrinsic state from the context; if not available, return
  const extrinsic_state *ext_state = ctxt->get_ext_state ();
  if (!ext_state)
    return;

  // Retrieve the state machine map, the state machine, and its index from the context
  sm_state_map *smap;
  const state_machine *sm;
  unsigned sm_idx;
  if (!ctxt->get_malloc_map (&smap, &sm, &sm_idx))
    return;  // Exit if no state machine map is found

  // Ensure that the state machine map and state machine are valid
  gcc_assert (smap);
  gcc_assert (sm);

  // Cast the state machine to a malloc_state_machine to handle malloc-specific operations
  const malloc_state_machine &malloc_sm = (const malloc_state_machine &)*sm;

  // Transition the pointer to a non-null state using the malloc_state_machine
  malloc_sm.transition_ptr_sval_non_null (this, smap, ptr_sval, *ext_state);
}","The region_model::transition_ptr_sval_non_null function updates the state of a pointer (ptr_sval) in the region model, setting it to a ""non-null"" state. This function is used to transition the pointer to a state where it is considered valid and non-null, meaning it points to a valid memory location. The function accesses necessary context and state information, retrieves the appropriate state machine, and invokes the corresponding method on the malloc_state_machine to perform the state transition."
"bool
describe_state_change (pretty_printer &pp,
                       const evdesc::state_change &change) override
{
  // Check if the new state is ""tainted""
  if (change.m_new_state == m_sm.m_tainted)
  {
    // If there is an origin (the previous expression), print the corresponding message
    if (change.m_origin)
    {
      pp_printf (&pp,
                 ""%qE has an unchecked value here (from %qE)"",
                 change.m_expr, change.m_origin);
      return true; // Return true to indicate a description was generated
    }
    else
    {
      // If there is no origin, print the message indicating an unchecked value
      pp_printf (&pp,
                 ""%qE gets an unchecked value here"",
                 change.m_expr);
      return true; // Return true to indicate a description was generated
    }
  }
  // Check if the new state is ""has lower bound""
  else if (change.m_new_state == m_sm.m_has_lb)
  {
    pp_printf (&pp,
               ""%qE has its lower bound checked here"",
               change.m_expr);
    return true; // Return true to indicate a description was generated
  }
  // Check if the new state is ""has upper bound""
  else if (change.m_new_state == m_sm.m_has_ub)
  {
    pp_printf (&pp,
               ""%qE has its upper bound checked here"",
               change.m_expr);
    return true; // Return true to indicate a description was generated
  }
  
  // If the new state does not match any of the above, return false
  return false;
}","The describe_state_change function is part of an override method designed to describe state changes in expressions, particularly in the context of memory management or state tracking. This function checks for different state transitions and generates a descriptive output using a pretty printer (pp). It handles different scenarios where an expression (change.m_expr) either receives an unchecked value, has its lower bound (LB) checked, or has its upper bound (UB) checked. Depending on the type of state change, the function generates a message describing the transition."
"static bool
name_used_by_phis_p (tree name, const supernode *snode,
		     size_t phi_arg_idx)
{
  // Ensure that the 'name' is a valid SSA_NAME
  gcc_assert (TREE_CODE (name) == SSA_NAME);

  // Iterate through all PHI nodes in the supernode
  for (gphi_iterator gpi
       = const_cast<supernode *> (snode)->start_phis (); 
       !gsi_end_p (gpi); gsi_next (&gpi))
    {
      gphi *phi = gpi.phi ();
      
      // Check if the 'name' matches the phi argument at the specified index
      if (gimple_phi_arg_def (phi, phi_arg_idx) == name)
        return true;  // Return true if the name is used by the PHI
    }

  // Return false if the name is not used by any PHI node
  return false;
}","The name_used_by_phis_p function is designed to check if a given SSA (Static Single Assignment) name is used by any of the PHI nodes within a particular supernode, specifically checking if it is used as a particular argument in the PHI definition. PHI nodes are typically used in SSA form to merge different control flow paths in compilers, and this function helps determine if a particular SSA name is involved in that process, either as a source operand or an argument in the PHI nodes."
"static bool
same_binding_p (const region *reg_a, const region *reg_b,
		store_manager *store_mgr)
{
  // Check if the base regions of reg_a and reg_b are the same
  if (reg_a->get_base_region () != reg_b->get_base_region ())
    return false;

  // If reg_a is empty, it cannot have the same binding as reg_b
  if (reg_a->empty_p ())
    return false;

  // Generate binding key for reg_a
  const binding_key *bind_key_a = binding_key::make (store_mgr, reg_a);

  // If reg_b is empty, it cannot have the same binding as reg_a
  if (reg_b->empty_p ())
    return false;

  // Generate binding key for reg_b
  const binding_key *bind_key_b = binding_key::make (store_mgr, reg_b);

  // Return true if both binding keys are the same, otherwise false
  return bind_key_a == bind_key_b;
}","The function same_binding_p checks whether two given regions, reg_a and reg_b, are bound to the same memory region in the context of a store manager. It does so by comparing the base regions of both reg_a and reg_b, and if those are the same, it further checks if they are bound in the same manner by creating binding keys for each region using the store_manager.

The function is useful in contexts such as memory management, region analysis, and garbage collection, where regions or memory spaces are being compared to determine whether they are equivalent in terms of their binding to memory."
"static bool
fully_overwrites_p (const gimple *stmt, tree decl,
		    const region_model &model)
{
  // Check if the statement has a left-hand side (LHS)
  if (tree lhs = gimple_get_lhs (stmt))
    {
      // Determine if LHS fully overwrites DECL
      // For cases like ""s.field = EXPR"", we can't just check for equality;
      // instead, we check the regions bound to the LHS and DECL to determine
      // if they are the same.
      
      // Get the region corresponding to the LHS of the statement
      const region *lhs_reg = model.get_lvalue (lhs, NULL);
      
      // Get the region corresponding to the DECL variable
      const region *decl_reg = model.get_lvalue (decl, NULL);
      
      // Compare the regions to check if they are bound to the same memory
      if (same_binding_p (lhs_reg, decl_reg,
			  model.get_manager ()->get_store_manager ()))
        return true;
    }
  
  // Return false if no full overwrite is found
  return false;
}","The function fully_overwrites_p checks whether a given statement (stmt) fully overwrites the value of a specific variable (decl) in the context of a memory region model (model). The function goes beyond simple equality checks to handle cases where a field of a structure is being assigned to, such as in the case of s.field = EXPR;, where the left-hand side (LHS) expression may partially overwrite part of the structure, but not necessarily the entire region.

The function uses a model to determine the regions corresponding to the left-hand side (LHS) and the declared variable (decl). It then checks if these regions are bound to the same memory location. If they are, the function returns true, indicating that the statement fully overwrites the declared variable's region."
"private:
  static bool needs_parens_p (const svalue *outer_sval,
			      const svalue &inner_sval)
  {
    // If outer_sval is nullptr, parentheses are not needed
    if (!outer_sval)
      return false;

    // If the inner expression is a binary operation, parentheses are needed
    if (inner_sval.get_kind () == SK_BINOP)
      return true;

    // Default case: parentheses are not needed
    return false;
  }","The function needs_parens_p determines whether parentheses are needed around an inner expression based on the type of the outer and inner values (svalue). Specifically, it checks whether the inner value is a binary operation, which typically requires parentheses for correct precedence in expression evaluation."
"bool
svalue::maybe_print_for_user (pretty_printer *pp,
			      const region_model &model,
			      const svalue *outer_sval) const
{
  // Initialize the parentheses handler to manage whether parentheses are needed
  auto_add_parens p (pp, outer_sval, *this);

  // Switch on the type of the svalue (symbolic value)
  switch (get_kind ())
    {
    default:
      break;

    // Handle constant values
    case SK_CONSTANT:
      {
	const constant_svalue *sval = (const constant_svalue *)this;
	pp_printf (pp, ""%E"", sval->get_constant ());
	return true;
      }

    // Handle initial values
    case SK_INITIAL:
      {
	const initial_svalue *sval = (const initial_svalue *)this;
	// Print the region of the initial value
	return sval->get_region ()->maybe_print_for_user (pp, model);
      }

    // Handle unary operations
    case SK_UNARYOP:
      {
	const unaryop_svalue *sval = (const unaryop_svalue *)this;
	// If the operation is a no-op, just print the argument
	if (sval->get_op () == NOP_EXPR)
	  {
	    if (!sval->get_arg ()->maybe_print_for_user (pp, model, outer_sval))
	      return false;
	    return true;
	  }
      }
      break;

    // Handle binary operations
    case SK_BINOP:
      {
	const binop_svalue *sval = (const binop_svalue *)this;
	switch (sval->get_op ())
	  {
	  default:
	    break;

	  // For binary operations like addition, subtraction, and multiplication
	  case PLUS_EXPR:
	  case MINUS_EXPR:
	  case MULT_EXPR:
	    {
	      if (!sval->get_arg0 ()->maybe_print_for_user (pp, model, this))
		return false;
	      pp_printf (pp, "" %s "", op_symbol_code (sval->get_op ()));
	      if (!sval->get_arg1 ()->maybe_print_for_user (pp, model, this))
		return false;
	      return true;
	    }
	  }
      }
      break;
    }

  // If none of the specific cases matched, fallback to tree printing
  if (tree expr = model.get_representative_tree (this))
    {
      expr = remove_ssa_names (expr);  // Remove SSA names for printing
      print_expr_for_user (pp, expr);  // Print the expression
      return true;
    }

  return false;  // Return false if no printing occurred
}","The function maybe_print_for_user handles printing the value of a given svalue (symbolic value) in a way that is suitable for user consumption. The printing is dependent on the kind of the symbolic value, and the function may add parentheses if needed for clarity or correct precedence."
"std::unique_ptr<text_art::tree_widget>
svalue::make_dump_widget (const text_art::dump_widget_info &dwi,
			  const char *prefix) const
{
  // Initialize the pretty_printer to format the output
  pretty_printer pp;
  pp_format_decoder (&pp) = default_tree_printer;  // Set default tree printer
  pp_show_color (&pp) = true;  // Enable color in the output

  // Print the optional prefix if provided
  if (prefix)
    pp_printf (&pp, ""%s: "", prefix);

  // Print the ID of the symbolic value
  pp_printf (&pp, ""(%i): "", get_id ());

  // Print the type of the symbolic value if available
  if (get_type ())
    pp_printf (&pp, ""%qT: "", get_type ());

  // Print the label for the widget
  print_dump_widget_label (&pp);

  // Create the tree_widget using the formatted pretty_printer
  std::unique_ptr<text_art::tree_widget> w
    (text_art::tree_widget::make (dwi, &pp));

  // Add children to the widget (e.g., additional details about the symbolic value)
  add_dump_widget_children (*w, dwi);

  // Return the created widget
  return w;
}","The function make_dump_widget is responsible for creating and returning a widget (specifically a tree_widget) that visualizes or represents the symbolic value (svalue) in a textual format. It formats the symbolic value and its associated data, optionally adding a prefix and visual properties, and builds a widget that can be used to display the symbolic value in a tree-like structure."
"tree
svalue::maybe_get_constant () const
{
  // Unwrap any unmergeable symbolic value to handle complex cases
  const svalue *sval = unwrap_any_unmergeable ();

  // Try to cast the unwrapped value to a constant_svalue
  if (const constant_svalue *cst_sval = sval->dyn_cast_constant_svalue ())
    {
      // If the value is a constant, return the constant value
      return cst_sval->get_constant ();
    }
  else
    {
      // If not a constant, return NULL_TREE to indicate no constant available
      return NULL_TREE;
    }
}","The function maybe_get_constant attempts to retrieve the constant value from an svalue object, if the symbolic value can be interpreted as a constant. It first unwraps the symbolic value to handle unmergeable values, then checks if the value is of type constant_svalue. If it is, the constant value is returned; otherwise, NULL_TREE is returned, indicating that the symbolic value does not represent a constant."
"const svalue *
svalue::maybe_undo_cast () const
{
  // Attempt to cast the current svalue to a unaryop_svalue type
  if (const unaryop_svalue *unaryop_sval = dyn_cast_unaryop_svalue ())
    {
      // Get the operation type of the unary operation
      enum tree_code op = unaryop_sval->get_op ();

      // If the operation is either a no-op or a view conversion, return the argument
      if (op == NOP_EXPR || op == VIEW_CONVERT_EXPR)
        return unaryop_sval->get_arg ();  // Undo the cast (or no-op)
    }
  // Return NULL if no unary operation or if operation is not a cast/no-op
  return NULL;
}","The maybe_undo_cast function attempts to reverse a cast operation if the symbolic value is of a unary operation type (unaryop_svalue) and the operation is either a no-op (NOP_EXPR) or a view conversion (VIEW_CONVERT_EXPR). If these conditions are met, the function returns the argument of the unary operation, effectively undoing the cast. Otherwise, it returns NULL, indicating that no cast could be undone."
"bool
svalue::live_p (const svalue_set *live_svalues,
                const region_model *model) const
{
  // Determine if the svalue is explicitly live
  if (live_svalues)
    if (const_cast<svalue_set *> (live_svalues)->contains (this))
      return true;

  // If not explicitly live, check if the svalue is implicitly live due to
  // being composed of other live svalues
  return implicitly_live_p (live_svalues, model);
}","The live_p function checks if a given svalue (symbolic value) is ""live."" A value is considered live if it is part of the set of explicitly live values or if it is implicitly live due to being made up of other live values. This function first checks if the svalue is explicitly live by looking in the provided set of live values. If it's not found explicitly live, the function then checks if it is implicitly live by calling the implicitly_live_p function, which checks if the value depends on other live values."
"static int
cmp_csts_and_types (const_tree cst1, const_tree cst2)
{
  // Extract type UIDs of the constants
  int t1 = TYPE_UID (TREE_TYPE (cst1));  // Get the type UID for the first constant
  int t2 = TYPE_UID (TREE_TYPE (cst2));  // Get the type UID for the second constant

  // Compare the types first, if the types differ, return the difference in their UIDs
  if (int cmp_type = t1 - t2)
    return cmp_type;

  // If types are the same, compare the constants themselves
  return cmp_csts_same_type (cst1, cst2);
}","The cmp_csts_and_types function compares two constants (represented by const_tree values) based on their types first, and if their types are the same, it further compares the constants themselves. This function is likely used in contexts where both the type and the value of constants need to be compared, for example, in optimization or code generation passes in a compiler."
"bool
svalue::involves_p (const svalue *other) const
{
  // Assert that the 'other' svalue is of a supported kind.
  gcc_assert (other->get_kind () == SK_INITIAL
	      || other->get_kind () == SK_CONJURED
	      || other->get_kind () == SK_WIDENING);

  // Create an involvement visitor for the 'other' svalue.
  involvement_visitor v (other);

  // Let the visitor traverse the current svalue ('this').
  accept (&v);

  // Return whether the visitor found an involvement.
  return v.found_p ();
}","The involves_p function checks whether the current svalue (represented by this) involves or depends on another svalue (other). The function currently supports specific kinds of svalue, including SK_INITIAL, SK_CONJURED, and SK_WIDENING. It uses an ""involvement visitor"" pattern to traverse the current svalue and determine if it is involved with the other svalue."
"void
region_svalue::dump_to_pp (pretty_printer *pp, bool simple) const
{
  if (simple)
    {
      // In simple mode, print the address of the region followed by its dump.
      pp_string (pp, ""&"");
      m_reg->dump_to_pp (pp, simple);
    }
  else
    {
      // In detailed mode, print ""region_svalue(<type>, <region>)""
      pp_string (pp, ""region_svalue("");
      
      // If the type is available, print it in a quoted format followed by a comma.
      if (get_type ())
	{
	  print_quoted_type (pp, get_type ());
	  pp_string (pp, "", "");
	}
      
      // Print the region representation.
      m_reg->dump_to_pp (pp, simple);
      
      // Close the detailed representation with a closing parenthesis.
      pp_string (pp, "")"");
    }
}","The dump_to_pp function is used to output a textual representation of a region_svalue object to a pretty_printer (pp). This function supports two modes:

Simple mode: In this mode, it prints a minimal representation of the region_svalue.
Detailed mode: In this mode, it provides more detailed information, including the type of the value and the region associated with it.
The function utilizes a pretty_printer to format and output the information in a human-readable way."
"trimmed_graph::trimmed_graph (const exploded_graph &inner_graph,
			      const exploded_node *inner_dst_node)
: m_enodes (), m_eedges ()
{
  /* Initialize the worklist with the destination node */
  auto_vec <const exploded_node *> worklist;
  worklist.safe_push (inner_dst_node); // Push the destination node onto the worklist.
  
  m_enodes.add (inner_dst_node); // Add the destination node to the set of nodes in the trimmed graph.
  
  // Start processing the worklist.
  while (worklist.length () > 0)
    {
      const exploded_node *inner_node = worklist.pop (); // Pop a node from the worklist.
      
      exploded_edge *inner_pred;
      unsigned i;
      
      // Iterate through all predecessors of the current node.
      FOR_EACH_VEC_ELT (inner_node->m_preds, i, inner_pred)
	{
	  // If the predecessor node hasn't been added yet, add it to the worklist and nodes set.
	  if (!m_enodes.contains (inner_pred->m_src))
	    {
	      worklist.safe_push (inner_pred->m_src);
	      m_enodes.add (inner_pred->m_src);
	    }
	  
	  // Add the edge to the set of edges in the trimmed graph.
	  m_eedges.add (inner_pred);
	}
    }
}","The constructor trimmed_graph::trimmed_graph is used to create a trimmed graph by iterating backward through an existing exploded_graph. It builds a subset of nodes and edges that are reachable from a given destination node (inner_dst_node). The process includes traversing the graph backwards through edges (predecessors of nodes) and collecting the relevant nodes and edges into the new trimmed_graph.

The graph traversal is done using a worklist, which is essentially a stack-based approach to iteratively explore the nodes and their predecessors."
"int
gfc_expr_is_one (gfc_expr *expr, int def)
{
  // Assert that expr is not NULL.
  gcc_assert (expr != NULL);

  // Check if the expression is not a constant.
  if (expr->expr_type != EXPR_CONSTANT)
    return def;

  // Check if the constant is an integer.
  if (expr->ts.type != BT_INTEGER)
    return def;

  // Compare the constant value to 1.
  return mpz_cmp_si (expr->value.integer, 1) == 0;
}","The function gfc_expr_is_one is used to determine whether a given gfc_expr (a structure representing an expression in the GNU Fortran compiler) is equal to the constant value 1. The function performs the following checks:

Checks if the expression is a constant.
Checks if the type of the constant is an integer.
Compares the constant value to 1.
If any of these checks fail, the function returns a default value (def). Otherwise, it returns a boolean result (1 if the expression is equal to 1, 0 otherwise)."
"static bool
identical_array_ref (gfc_array_ref *a1, gfc_array_ref *a2)
{
  int i;

  // Check if both are full array references.
  if (a1->type == AR_FULL && a2->type == AR_FULL)
    return true;

  // Check if both are array section references.
  if (a1->type == AR_SECTION && a2->type == AR_SECTION)
    {
      // Ensure that the sections have the same number of dimensions.
      gcc_assert (a1->dimen == a2->dimen);

      for (i = 0; i < a1->dimen; i++)
        {
          // Currently, we skip if the index is an integer array.
          if (a1->dimen_type[i] != DIMEN_RANGE
              || a2->dimen_type[i] != DIMEN_RANGE)
            return false;

          // Compare the sections along each dimension.
          if (check_section_vs_section (a1, a2, i) != GFC_DEP_EQUAL)
            return false;
        }
      return true;
    }

  // Check if both are element references.
  if (a1->type == AR_ELEMENT && a2->type == AR_ELEMENT)
    {
      // Ensure that the dimensions match.
      if (a1->dimen != a2->dimen)
        gfc_internal_error (""identical_array_ref(): inconsistent dimensions"");

      for (i = 0; i < a1->dimen; i++)
        {
          // Compare the start indices of the elements.
          if (gfc_dep_compare_expr (a1->start[i], a2->start[i]) != 0)
            return false;
        }
      return true;
    }

  // If types don't match, return false.
  return false;
}","The function identical_array_ref checks whether two array references (a1 and a2) are identical. It compares the type and dimensional properties of the array references, as well as the individual indices if applicable. The function handles three types of array references:

Full Array Reference (AR_FULL)
Array Section Reference (AR_SECTION)
Array Element Reference (AR_ELEMENT)"
"gfc_expr *
gfc_discard_nops (gfc_expr *e)
{
  gfc_actual_arglist *arglist;

  // If the expression is NULL, return NULL immediately.
  if (e == NULL)
    return NULL;

  // Start a loop that will continue until no more no-op operations are found.
  while (true)
    {
      // Check if the expression is a unary operation (unary plus or parentheses).
      if (e->expr_type == EXPR_OP
          && (e->value.op.op == INTRINSIC_UPLUS  // Unary plus
              || e->value.op.op == INTRINSIC_PARENTHESES))  // Parentheses
        {
          // Move to the inner expression (the operand of the unary operator).
          e = e->value.op.op1;
          continue;  // Continue the loop to check if the new expression has no-ops.
        }

      // Check if the expression is a function and involves a type conversion.
      if (e->expr_type == EXPR_FUNCTION && e->value.function.isym
          && e->value.function.isym->id == GFC_ISYM_CONVERSION
          && e->ts.type == BT_INTEGER)  // Type conversion is for integers
        {
          arglist = e->value.function.actual;  // Get the arguments of the function.
          // Check if the argument's type is integer and the result type is a more specific integer type.
          if (arglist->expr->ts.type == BT_INTEGER
              && e->ts.kind > arglist->expr->ts.kind)  // Compare type kind for integer types
            {
              // If the conversion is unnecessary, replace the expression with the argument.
              e = arglist->expr;
              continue;  // Continue the loop to check the new expression.
            }
        }
      break;  // If no further no-ops are found, break the loop.
    }

  // Return the simplified expression.
  return e;
}","The function gfc_discard_nops is designed to traverse an expression (gfc_expr *e) and remove certain types of ""no-op"" operations. These operations are typically used for syntactical purposes (such as unary plus or parentheses) and do not change the value of the expression. The function also handles a specific case related to type conversions between integer types."
"gfc_expr *
gfc_get_noncopying_intrinsic_argument (gfc_expr *expr)
{
  // Check if the expression is a function and if the symbol for the function is available
  if (expr->expr_type != EXPR_FUNCTION || !expr->value.function.isym)
    return NULL;

  // Switch on the intrinsic function ID to determine which function we are dealing with
  switch (expr->value.function.isym->id)
    {
    case GFC_ISYM_TRANSPOSE:
      // For the TRANSPOSE intrinsic, return the argument (first element in actual argument list)
      return expr->value.function.actual->expr;

    default:
      // For other intrinsics, return NULL
      return NULL;
    }
}","The function gfc_get_noncopying_intrinsic_argument is designed to retrieve the argument of an intrinsic function, specifically focusing on the case where the function is a TRANSPOSE operation. It returns the argument of the intrinsic function if it meets the criteria, otherwise, it returns NULL. The function checks for intrinsic functions and processes the argument accordingly."
"// Function to determine if a temporary variable is needed for the given reference.
// Returns true if a temporary is required, false otherwise.
bool gfc_ref_needs_temporary_p(gfc_ref *ref)
{
    int n;                 // Variable to iterate over dimensions of an array reference.
    bool subarray_p;       // Flag indicating whether a subarray reference has been encountered.

    subarray_p = false;    // Initialize the subarray flag to false.

    // Loop through the linked list of references.
    for (; ref; ref = ref->next)
        switch (ref->type) // Evaluate the type of the current reference.
        {
        case REF_ARRAY: // Handle array references.
            /* Vector dimensions are generally not monotonic and must be
               handled using a temporary. */
            if (ref->u.ar.type == AR_SECTION) // Check if the array is an array section.
                for (n = 0; n < ref->u.ar.dimen; n++) // Iterate over all dimensions.
                    if (ref->u.ar.dimen_type[n] == DIMEN_VECTOR) // Check for non-monotonic vectors.
                        return true; // A temporary is required for non-monotonic vectors.

            subarray_p = true; // Mark that a subarray reference has been encountered.
            break;

        case REF_SUBSTRING: // Handle substring references.
            /* Within an array reference, character substrings generally
               need a temporary. Character array strides are expressed as
               multiples of the element size (consistent with other array
               types), not in characters. */
            return subarray_p; // Return true if part of a subarray, otherwise false.

        case REF_COMPONENT: // Handle component references (no special handling needed).
        case REF_INQUIRY:   // Handle inquiry references (no special handling needed).
            break; // Continue to the next reference.
        }

    // If no conditions requiring a temporary were met, return false.
    return false;
}","The function gfc_ref_needs_temporary_p determines whether a temporary variable is necessary for handling a given reference (gfc_ref) in the context of a compiler or code-generation scenario. The decision is based on the type of reference, such as arrays, substrings, components, or inquiries. The function considers complexities like non-monotonic vector dimensions or character array substrings, which may require temporary variables to simplify computation. This ensures the correct handling of memory access and computation during runtime."
"// Function to check if a given expression represents a data pointer.
// Returns true (1) if the expression is a data pointer, false (0) otherwise.
static bool gfc_is_data_pointer(gfc_expr *e)
{
    gfc_ref *ref; // Pointer to traverse the reference chain of the expression.

    // Check if the expression type is either a variable or a function.
    if (e->expr_type != EXPR_VARIABLE && e->expr_type != EXPR_FUNCTION)
        return 0; // If not, it cannot be a data pointer.

    /* Ensure no subreference exists if the expression is a function. 
       This is a sanity check to verify the input's structure. */
    gcc_assert(e->expr_type == EXPR_VARIABLE || !e->ref);

    // Check if the symbol associated with the expression has the ""pointer"" attribute.
    if (e->symtree->n.sym->attr.pointer)
        return 1; // If it does, the expression represents a data pointer.

    // Traverse the reference chain linked to the expression.
    for (ref = e->ref; ref; ref = ref->next)
        // Check if the reference type is a component and the component has the ""pointer"" attribute.
        if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)
            return 1; // If found, the expression represents a data pointer.

    // If no pointer attribute was found in the expression or its references, return false.
    return 0;
}",The gfc_is_data_pointer function determines if a given expression (gfc_expr) represents a data pointer. It checks the attributes of the symbol associated with the expression and traverses any reference chains to identify pointer attributes. This function is essential in compiler implementations for understanding memory access patterns and resolving pointers in expressions.
"// Function to check dependency between two Fortran expressions in the context of argument passing.
// Parameters:
// - other: The expression to compare against.
// - intent: The intent of the argument (e.g., INTENT_IN, INTENT_OUT).
// - expr: The expression being checked for dependency.
// - elemental: Indicates whether the dependency check involves an elemental operation.
// Returns non-zero if a dependency is found; otherwise, returns 0.
static int gfc_check_argument_dependency(gfc_expr *other, sym_intent intent,
                                         gfc_expr *expr, gfc_dep_check elemental)
{
    // Evaluate the type of the ""other"" expression.
    switch (other->expr_type)
    {
    case EXPR_VARIABLE: // Case where ""other"" is a variable.
        // Perform a variable-specific dependency check.
        return gfc_check_argument_var_dependency(other, intent, expr, elemental);

    case EXPR_FUNCTION: // Case where ""other"" is a function.
        // Retrieve the non-copying intrinsic argument for the function.
        other = gfc_get_noncopying_intrinsic_argument(other);
        
        // If the non-copying argument is valid, perform a recursive dependency check.
        if (other != NULL)
            return gfc_check_argument_dependency(other, INTENT_IN, expr, NOT_ELEMENTAL);

        // If no valid non-copying argument, return 0 (no dependency found).
        return 0;

    default: // For all other expression types.
        // No dependency checks are applicable; return 0.
        return 0;
    }
}","The gfc_check_argument_dependency function assesses whether a dependency exists between a given expression (expr) and another expression (other) in the context of Fortran arguments. It evaluates the nature of the expressions, such as variables or functions, and applies specific checks for each case. The function also incorporates Fortran-specific concepts like argument intents (INTENT_IN, etc.) and elemental operations (NOT_ELEMENTAL)."
"// Function to check if there is a dependency between an expression and the arguments of a function call.
// Parameters:
// - other: The expression to compare against the arguments of the function.
// - intent: The intent (e.g., INTENT_IN) of the argument being checked.
// - fnsym: The symbol representing the function being called.
// - actual: The actual argument list passed to the function.
// - elemental: Indicates whether the check involves an elemental operation.
// Returns true (1) if a dependency is found; false (0) otherwise.
bool gfc_check_fncall_dependency(gfc_expr *other, sym_intent intent,
                                  gfc_symbol *fnsym, gfc_actual_arglist *actual,
                                  gfc_dep_check elemental)
{
    gfc_formal_arglist *formal; // Pointer to the formal argument list of the function.
    gfc_expr *expr;            // Pointer to each actual argument in the argument list.

    // Get the list of formal arguments for the function, if the function symbol is valid.
    formal = fnsym ? gfc_sym_get_dummy_args(fnsym) : NULL;

    // Iterate over the actual argument list and the corresponding formal arguments.
    for (; actual; actual = actual->next, formal = formal ? formal->next : NULL)
    {
        expr = actual->expr; // Get the current actual argument expression.

        /* Skip arguments that are not present (i.e., NULL expressions). */
        if (!expr)
            continue;

        /* Skip the ""other"" expression itself to avoid comparing it to itself. */
        if (expr == other)
            continue;

        /* Skip intent(IN) arguments if ""other"" itself has INTENT_IN. */
        if (formal && intent == INTENT_IN && formal->sym->attr.intent == INTENT_IN)
            continue;

        // Check for dependency between ""other"" and the current argument.
        if (gfc_check_argument_dependency(other, intent, expr, elemental))
            return 1; // If a dependency is found, return true (1).
    }

    // If no dependency is found after checking all arguments, return false (0).
    return 0;
}","The gfc_check_fncall_dependency function checks if there is a dependency between the expression other and any of the arguments in a function call. It evaluates whether the given expression depends on any of the actual arguments passed to a function, taking into account various attributes such as intent (e.g., INTENT_IN) and the elemental status of the operation. This function is vital for detecting potential side effects or dependencies in function calls, particularly in Fortran compilers or similar environments."
"// Callback function to check if a dummy variable has an intent other than INTENT_IN.
// Parameters:
// - ep: A pointer to the expression pointer that is being checked.
// - walk_subtrees: A pointer to an integer (not used in this function).
// - data: A pointer to additional data (not used in this function).
// Returns 1 if the dummy variable's intent is not INTENT_IN, 0 otherwise.
static int callback_dummy_intent_not_in(gfc_expr **ep,
                                         int *walk_subtrees ATTRIBUTE_UNUSED,
                                         void *data ATTRIBUTE_UNUSED)
{
    gfc_expr *e = *ep; // Dereference the pointer to get the current expression.

    // Check if the expression is a variable and has a valid symbol tree.
    // Additionally, check if the symbol is a dummy argument.
    if (e->expr_type == EXPR_VARIABLE && e->symtree
        && e->symtree->n.sym->attr.dummy)
        // If the variable is a dummy argument, check if its intent is not INTENT_IN.
        return e->symtree->n.sym->attr.intent != INTENT_IN;

    // If the conditions are not met (either not a variable or not a dummy argument),
    // return 0 indicating no match.
    else
        return 0;
}","The callback_dummy_intent_not_in function checks whether a given expression is a dummy variable with an intent attribute other than INTENT_IN. This is typically used in compiler contexts, particularly in Fortran, to identify dummy arguments in function calls that are not marked with the INTENT_IN attribute. The function works within a tree traversal context, where it inspects expressions to evaluate their attributes."
"// Function to check if a reference is the same as the full array reference.
// Parameters:
// - full_ref: The reference representing the full array.
// - ref: The reference being checked for equivalence with the full array.
// Returns true if the references are equivalent, false otherwise.
static bool ref_same_as_full_array(gfc_ref *full_ref, gfc_ref *ref)
{
    int i;                      // Loop variable for iterating over array dimensions.
    bool upper_or_lower;        // Flag to check if the reference matches upper or lower bounds.

    // Check if the full reference is an array.
    if (full_ref->type != REF_ARRAY)
        return false; // Return false if the full reference is not an array.

    // Check if the full reference is a full array (not a section).
    if (full_ref->u.ar.type != AR_FULL)
        return false; // Return false if the full reference is not the full array.

    // Check if the reference is an array.
    if (ref->type != REF_ARRAY)
        return false; // Return false if the reference is not an array.

    // If the reference is a full array, return true as it matches the full array.
    if (ref->u.ar.type == AR_FULL)
        return true;

    // If the reference is not a section, return false.
    if (ref->u.ar.type != AR_SECTION)
        return false; // Only array sections are considered for comparison.

    // Iterate through each dimension to check bounds and strides.
    for (i = 0; i < ref->u.ar.dimen; i++)
    {
        /* Check if we have a single element in the reference.
           We compare the start and end indices with the full array's bounds. */
        if (ref->u.ar.dimen_type[i] == DIMEN_ELEMENT)
        {
            // Check if the full array has valid bounds and the reference matches the correct element.
            if (!full_ref->u.ar.as || !full_ref->u.ar.as->lower[i] || !full_ref->u.ar.as->upper[i]
                || gfc_dep_compare_expr(full_ref->u.ar.as->lower[i], full_ref->u.ar.as->upper[i])
                || !ref->u.ar.start[i]
                || gfc_dep_compare_expr(ref->u.ar.start[i], full_ref->u.ar.as->lower[i]))
                return false; // Return false if the reference does not match the full array element.
        }

        /* Check the strides of the reference and the full array.
           Strides must be equal to 1 for both references. */
        if (full_ref->u.ar.stride[i] && !gfc_expr_is_one(full_ref->u.ar.stride[i], 0))
            return false; // Return false if the stride in the full array is not 1.
        if (ref->u.ar.stride[i] && !gfc_expr_is_one(ref->u.ar.stride[i], 0))
            return false; // Return false if the stride in the reference is not 1.

        upper_or_lower = false; // Reset the flag to check bounds.

        // Check if the lower bound of the reference matches the lower bound of the full array.
        if (ref->u.ar.start[i]
            && (ref->u.ar.as && full_ref->u.ar.as->lower[i]
                && gfc_dep_compare_expr(ref->u.ar.start[i], full_ref->u.ar.as->lower[i]) == 0))
            upper_or_lower = true; // Set the flag if the lower bounds match.

        // Check if the upper bound of the reference matches the upper bound of the full array.
        if (ref->u.ar.end[i]
            && (ref->u.ar.as && full_ref->u.ar.as->upper[i]
                && gfc_dep_compare_expr(ref->u.ar.end[i], full_ref->u.ar.as->upper[i]) == 0))
            upper_or_lower = true; // Set the flag if the upper bounds match.

        // If neither bound matches, return false.
        if (!upper_or_lower)
            return false;
    }

    // If all dimensions and bounds are the same, return true.
    return true;
}","The function ref_same_as_full_array checks if a given reference (ref) is the same as the full array reference (full_ref). It compares various attributes of the two references, including their array types, dimensions, and bounds. The function is primarily used in compilers or analysis tools to verify if a section or subset of an array is equivalent to the entire array based on its dimensions, strides, and bounds."
"// Function to check if an expression depends on a given symbol, either directly or indirectly.
// Parameters:
// - e: The expression to check for dependency.
// - sym: The symbol to check for dependency on.
// - f: An integer (unused in this function).
// Returns true if the expression depends on the symbol, false otherwise.
static bool dependency_fcn(gfc_expr *e, gfc_symbol *sym,
                            int *f ATTRIBUTE_UNUSED)
{
    // Return false if the expression is NULL, as there can be no dependency.
    if (e == NULL)
        return false;

    // Check if the expression is a variable.
    if (e && e->expr_type == EXPR_VARIABLE)
    {
        // If the variable's symbol matches the given symbol, return true (direct dependency).
        if (e->symtree && e->symtree->n.sym == sym)
            return true;

        /* If the symbol is not directly in the expression, recurse to check if the symbol
           is dependent on the result of a function. If so, an indirect dependency exists,
           which is treated the same as a direct dependency. This recursion is controlled
           by statement order to prevent infinite recursion. */
        else if (e->symtree && e->symtree->n.sym)
            return gfc_function_dependency(e->symtree->n.sym, sym);
    }

    // Return false if no dependency is found.
    return false;
}","The dependency_fcn function checks if a given expression (e) depends directly or indirectly on a specified symbol (sym). If the expression is a variable, it compares the variable's symbol to sym to check for a direct dependence. If no direct dependence is found, the function recursively checks whether the symbol is dependent on the result of a function (handled by gfc_function_dependency). This function is used in compilers or static analysis tools to track symbol dependencies in expressions, particularly in function calls or variable references.
"
"// Function to check if a symbol is dependent on the result of a function.
// Parameters:
// - sym: The symbol to check for dependency.
// - proc_name: The function symbol whose result is being checked for dependency.
// Returns true if there is a dependency, false otherwise.
bool gfc_function_dependency(gfc_symbol *sym, gfc_symbol *proc_name)
{
    bool dep = false; // Flag to track whether a dependency is found.

    // Check if the function symbol is valid, if it's the function's result, 
    // and if the symbol is neither a dummy argument nor a result symbol.
    if (proc_name && proc_name->attr.function
        && proc_name == proc_name->result
        && !(sym->attr.dummy || sym->attr.result))
    {
        // If the symbol already has a known dependency, return true.
        if (sym->fn_result_dep)
            return true;

        // If the symbol has explicit array bounds, check each dimension.
        if (sym->as && sym->as->type == AS_EXPLICIT)
        {
            // Iterate over each dimension of the array.
            for (int dim = 0; dim < sym->as->rank; dim++)
            {
                // If the lower bound is not constant, check if it depends on the function result.
                if (sym->as->lower[dim]
                    && sym->as->lower[dim]->expr_type != EXPR_CONSTANT)
                    dep = gfc_traverse_expr(sym->as->lower[dim], proc_name,
                                            dependency_fcn, 0);

                // If a dependency is found, mark it and return true.
                if (dep)
                {
                    sym->fn_result_dep = 1;
                    return true;
                }

                // If the upper bound is not constant, check if it depends on the function result.
                if (sym->as->upper[dim]
                    && sym->as->upper[dim]->expr_type != EXPR_CONSTANT)
                    dep = gfc_traverse_expr(sym->as->upper[dim], proc_name,
                                            dependency_fcn, 0);

                // If a dependency is found, mark it and return true.
                if (dep)
                {
                    sym->fn_result_dep = 1;
                    return true;
                }
            }
        }

        // If the symbol is of character type, check its length for dependencies.
        if (sym->ts.type == BT_CHARACTER
            && sym->ts.u.cl && sym->ts.u.cl->length
            && sym->ts.u.cl->length->expr_type != EXPR_CONSTANT)
            dep = gfc_traverse_expr(sym->ts.u.cl->length, proc_name,
                                    dependency_fcn, 0);

        // If a dependency is found in the character length, return true.
        if (dep)
        {
            sym->fn_result_dep = 1;
            return true;
        }
    }

    // Return false if no dependency is found.
    return false;
}","The gfc_function_dependency function checks if a symbol (sym) is dependent on the result of a function (proc_name). It determines dependencies by inspecting the attributes of the symbol and traversing array bounds or other expressions that might reference the function's result. The function identifies dependencies based on whether the symbol is a function result or whether any of its array bounds or properties depend on the function's result. This is crucial for detecting data dependencies in function calls, especially in scientific computing contexts where array bounds and function outputs are closely tied."
"// Function to check the internal consistency of the location data in a code structure.
// Parameters:
// - c: Pointer to the code structure to check.
// - walk_subtrees: An integer (unused in this function).
// - data: A pointer to additional data (unused in this function).
// Returns 0 to indicate completion of the check.
static int check_locus_code(gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,
                            void *data ATTRIBUTE_UNUSED)
{
    current_code = c; // Set the current code pointer to the passed argument.

    // Check if the code structure exists and the location data is inconsistent.
    if (c && *c)
    {
        // Check for various conditions indicating inconsistent location data:
        // 1. The 'nextc' pointer is NULL, meaning no following code.
        // 2. The 'nextc' pointer is a special value (-1) and the location is unknown.
        // 3. The 'nextc' pointer is not the special value, but the lower bound (lb) is NULL.
        if (((*c)->loc.nextc == NULL) ||
            ((*c)->loc.nextc == (gfc_char_t *) -1 &&
             (*c)->loc.u.location == UNKNOWN_LOCATION) ||
            ((*c)->loc.nextc != (gfc_char_t *) -1 &&
             ((*c)->loc.u.lb == NULL)))
        {
            // Trigger a warning for inconsistent internal state regarding location information.
            gfc_warning_internal(0, ""Inconsistent internal state: ""
                                 ""No location in statement"");
        }
    }

    // Return 0 to indicate the check is completed (no further action is taken).
    return 0;
}","The check_locus_code function verifies the internal consistency of location data in a given code structure (gfc_code). It checks if the location information is properly set for the given code, and if there is an inconsistency (e.g., missing or incorrect location data), it generates a warning. This function is likely used in compiler code or a similar system that tracks the locations of statements in source code, ensuring that the location data is consistent and valid. If inconsistencies are found in the location data, it triggers an internal warning to alert the user or developer."
"// Function to check the internal consistency of the location data in an expression structure.
// Parameters:
// - e: Pointer to the expression structure to check.
// - walk_subtrees: An integer (unused in this function).
// - data: A pointer to additional data (unused in this function).
// Returns 0 to indicate completion of the check.
static int check_locus_expr(gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,
                             void *data ATTRIBUTE_UNUSED)
{
    // Check if the expression structure exists and if the location data is inconsistent.
    if (e && *e)
    {
        // Check for various conditions indicating inconsistent location data:
        // 1. The 'nextc' pointer is NULL, meaning no following code.
        // 2. The 'nextc' pointer is a special value (-1) and the location is unknown.
        // 3. The 'nextc' pointer is not the special value, but the lower bound (lb) is NULL.
        if (((*e)->where.nextc == NULL) ||
            ((*e)->where.nextc == (gfc_char_t *) -1 &&
             (*e)->where.u.location == UNKNOWN_LOCATION) ||
            ((*e)->where.nextc != (gfc_char_t *) -1 &&
             ((*e)->where.u.lb == NULL)))
        {
            // Trigger a warning for inconsistent internal state regarding location information.
            gfc_warning_internal(0, ""Inconsistent internal state: ""
                                 ""No location in expression near %L"",
                                 &((*current_code)->loc)); // Include the location of the current code.
        }
    }

    // Return 0 to indicate the check is completed (no further action is taken).
    return 0;
}","The check_locus_expr function performs a consistency check on the location data of an expression (gfc_expr). Similar to check_locus_code, it verifies if the location information associated with the expression is correctly set. If any inconsistency is found, such as missing or incorrect location data, the function generates a warning. This function is likely part of a compiler or static analysis tool that tracks the locations of expressions in source code. It helps ensure that expressions have valid location data, which is important for debugging and error reporting."
"// Function to recursively check the consistency of location data in a namespace and its contained namespaces.
// Parameters:
// - ns: The namespace to check for location consistency.
static void check_locus(gfc_namespace *ns)
{
    // Call the code and expression location checkers on the code in the current namespace.
    // The check_locus_code checks code location, and check_locus_expr checks expression location.
    gfc_code_walker(&ns->code, check_locus_code, check_locus_expr, NULL);

    // Traverse through any contained namespaces recursively to check their code and expressions.
    // If the namespace is an executable block (op != EXEC_BLOCK), skip it.
    for (ns = ns->contained; ns; ns = ns->sibling)
    {
        // Skip namespaces with no code or non-executable blocks.
        if (ns->code == NULL || ns->code->op != EXEC_BLOCK)
            check_locus(ns);  // Recursively check the contained namespace.
    }
}","The check_locus function performs a recursive consistency check on the location data of all code and expressions within a given namespace (gfc_namespace). It utilizes two functions, check_locus_code and check_locus_expr, to check the location data of code and expressions, respectively. It starts by checking the current namespace's code, then recursively traverses any contained namespaces, applying the same checks. This function is likely used in compiler infrastructure to verify that location information is consistently tracked across different code blocks and namespaces, ensuring that no expressions or code segments are missing necessary location data."
"// Function to optimize the code by handling different operations (calls and assignments).
// Parameters:
// - c: Pointer to the code structure to optimize.
// - walk_subtrees: An integer (unused in this function).
// - data: A pointer to additional data (unused in this function).
// Returns 0 to indicate completion of the optimization.
static int optimize_code(gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,
                         void *data ATTRIBUTE_UNUSED)
{
    gfc_exec_op op;

    // Retrieve the operation type from the code structure.
    op = (*c)->op;

    // If the operation is one of the call types (EXEC_CALL, EXEC_COMPCALL, etc.), set count_arglist to 1.
    // This indicates that the argument list should be counted in the optimization process.
    if (op == EXEC_CALL || op == EXEC_COMPCALL || op == EXEC_ASSIGN_CALL
        || op == EXEC_CALL_PPC)
        count_arglist = 1; // Indicate that argument counting is required.
    else
        count_arglist = 0; // No argument counting needed for other operations.

    // Set the current code pointer and reset variables for the optimization process.
    current_code = c;
    inserted_block = NULL; // Reset any inserted block data.
    changed_statement = NULL; // Reset any changed statement data.

    // If the operation is an assignment (EXEC_ASSIGN), perform assignment-specific optimization.
    if (op == EXEC_ASSIGN)
        optimize_assignment(*c); // Optimize the assignment statement.

    // Return 0 to indicate that the optimization process is complete for this code.
    return 0;
}","The optimize_code function is designed to optimize code statements by handling various types of operations, such as function calls and assignments. The function identifies the operation type of the given code (gfc_code), and depending on the operation, adjusts specific settings like argument counting. For assignments, the function invokes an optimization function (optimize_assignment). This function is likely part of a compiler or code optimization tool, where it is responsible for improving the performance or structure of the generated code, particularly by focusing on specific operations like assignments and calls."
"/*
 * Function to compute signed integer division.
 * Parameters:
 * - `a`: Numerator of the division.
 * - `b`: Denominator of the division.
 * Returns:
 * - The result of the division as a signed long.
 */
long
__divsi3 (long a, long b)
{
  int neg = 0; // Tracks whether the result should be negative.
  long res;    // Variable to store the result.

  // Check if `a` is negative; if so, make it positive and toggle `neg`.
  if (a < 0)
    {
      a = -a;
      neg = !neg; // Toggle `neg` to account for the sign.
    }

  // Check if `b` is negative; if so, make it positive and toggle `neg`.
  if (b < 0)
    {
      b = -b;
      neg = !neg; // Toggle `neg` to account for the sign.
    }

  // Perform unsigned division using `__udivmodsi4` and store the result.
  res = __udivmodsi4 (a, b, 0);

  // If the result should be negative, adjust the sign of `res`.
  if (neg)
    res = -res;

  return res; // Return the computed division result.
}
","The __divsi3 function performs signed integer division. It takes two signed integers, a (numerator) and b (denominator), and computes their quotient. The function handles negative numbers by first converting them to positive values and keeping track of the final result's sign using a neg flag. It then calls an external function, __udivmodsi4, to perform the unsigned division. Finally, if the neg flag is set, the result is negated to restore the correct sign before returning it. This ensures proper behavior for signed division, including handling negative inputs."
"/*
 * Function to compute signed integer modulus.
 * Parameters:
 * - `a`: Numerator of the modulus operation.
 * - `b`: Denominator of the modulus operation.
 * Returns:
 * - The remainder after division as a signed long.
 */
long
__modsi3 (long a, long b)
{
  int neg = 0; // Tracks whether the result should be negative.
  long res;    // Variable to store the result.

  // Check if `a` is negative; if so, make it positive and set `neg`.
  if (a < 0)
    {
      a = -a;
      neg = 1; // Mark `neg` as 1 to indicate a negative remainder.
    }

  // Check if `b` is negative; if so, make it positive.
  if (b < 0)
    b = -b;

  // Perform unsigned modulus using `__udivmodsi4` and store the result.
  res = __udivmodsi4 (a, b, 1);

  // If the result should be negative, adjust the sign of `res`.
  if (neg)
    res = -res;

  return res; // Return the computed modulus result.
}","The __modsi3 function computes the signed modulus (remainder) of two integers. It takes a (numerator) and b (denominator) as inputs and returns the remainder after division. The function manages negative inputs by converting a to a positive value and marking the result's sign using the neg flag. The denominator, b, is also converted to a positive value if negative. It then calls the __udivmodsi4 function to perform the modulus operation. If the neg flag is set, the result is negated to maintain the correct sign. This ensures the modulus computation adheres to the rules of signed arithmetic."
"// Function to clean up and free memory associated with a thread-local storage (TLS) array
static void
emutls_destroy(void *ptr)
{
  struct __emutls_array *arr = ptr; // Cast the pointer to a TLS array structure
  pointer size = arr->size;        // Retrieve the size of the array
  pointer i;

  // Loop through each element in the array
  for (i = 0; i < size; ++i)
  {
    if (arr->data[i])              // If a data element exists
      free(arr->data[i][-1]);      // Free the allocated memory associated with it
  }

  free(ptr); // Free the array structure itself
}
","This function is responsible for cleaning up and freeing the memory associated with a thread-local storage (TLS) array. It iterates over all the elements of the __emutls_array structure and deallocates the memory assigned to each data entry, ensuring no memory leaks. Finally, it frees the memory used by the array structure itself. This function is called when the thread associated with the TLS array terminates."
"// Function to initialize the emutls system
static void
emutls_init(void)
{
#ifndef __GTHREAD_MUTEX_INIT
  __GTHREAD_MUTEX_INIT_FUNCTION(&emutls_mutex); // Initialize the mutex if not already defined
#endif
  // Create a thread-specific key with `emutls_destroy` as the destructor
  if (__gthread_key_create(&emutls_key, emutls_destroy) != 0)
    abort(); // Abort if key creation fails
}","The emutls_init function initializes the TLS system by setting up a mutex (if not already initialized) and creating a thread-specific key. This key is linked to the emutls_destroy function, which will clean up memory when the thread exits. It ensures the TLS system is ready for usage in a multithreaded environment and handles failures by aborting the program."
"// Function to allocate memory for a TLS object
static void *
emutls_alloc(struct __emutls_object *obj)
{
  void *ptr; // Base pointer for allocation
  void *ret; // Aligned pointer to return

  // Allocate memory when alignment is less than or equal to the size of a pointer
  if (obj->align <= sizeof(void *))
  {
    ptr = malloc(obj->size + sizeof(void *)); // Allocate memory with space for alignment metadata
    if (ptr == NULL)
      abort(); // Abort if allocation fails
    ((void **)ptr)[0] = ptr; // Store the base pointer for deallocation
    ret = ptr + sizeof(void *); // Return the aligned memory
  }
  else // Handle allocations requiring specific alignment
  {
    ptr = malloc(obj->size + sizeof(void *) + obj->align - 1); // Allocate memory with padding for alignment
    if (ptr == NULL)
      abort(); // Abort if allocation fails
    ret = (void *)(((pointer)(ptr + sizeof(void *) + obj->align - 1)) & ~(pointer)(obj->align - 1)); // Align the memory
    ((void **)ret)[-1] = ptr; // Store the base pointer
  }

  // Initialize the allocated memory with the template if provided, otherwise zero it out
  if (obj->templ)
    memcpy(ret, obj->templ, obj->size); // Copy template data
  else
    memset(ret, 0, obj->size); // Zero out the memory

  return ret; // Return the aligned memory pointer
}","This function allocates memory for a thread-local storage (TLS) object while respecting its size and alignment requirements. If the alignment of the object is larger than the size of a pointer, the function adjusts the allocation to meet the alignment constraints. It also initializes the allocated memory, either copying a provided template or zeroing out the memory. The function ensures safe memory allocation and aborts if memory allocation fails."
"// Function to retrieve or create a TLS address for an object
EMUTLS_ATTR void *
__emutls_get_address(struct __emutls_object *obj)
{
  // If threads are not active, use a simple allocation path
  if (!__gthread_active_p())
  {
    if (__builtin_expect(obj->loc.ptr == NULL, 0)) // If the pointer is null, allocate memory
      obj->loc.ptr = emutls_alloc(obj);
    return obj->loc.ptr; // Return the TLS address
  }

#ifndef __GTHREADS
  abort(); // Abort if gthreads are not available
#else
  pointer offset = __atomic_load_n(&obj->loc.offset, __ATOMIC_ACQUIRE); // Load the offset atomically

  // If the offset is not set, initialize it
  if (__builtin_expect(offset == 0, 0))
  {
    static __gthread_once_t once = __GTHREAD_ONCE_INIT; // Ensure `emutls_init` is called only once
    __gthread_once(&once, emutls_init);
    __gthread_mutex_lock(&emutls_mutex); // Lock the mutex to update the offset
    offset = obj->loc.offset;
    if (offset == 0)
    {
      offset = ++emutls_size; // Increment the TLS size
      __atomic_store_n(&obj->loc.offset, offset, __ATOMIC_RELEASE); // Store the updated offset
    }
    __gthread_mutex_unlock(&emutls_mutex); // Unlock the mutex
  }

  // Retrieve the thread-local array
  struct __emutls_array *arr = __gthread_getspecific(emutls_key);
  if (__builtin_expect(arr == NULL, 0)) // If no array exists for this thread, allocate one
  {
    pointer size = offset + 32;
    arr = calloc(size + 1, sizeof(void *)); // Allocate memory for the array
    if (arr == NULL)
      abort(); // Abort if allocation fails
    arr->size = size; // Set the array size
    __gthread_setspecific(emutls_key, (void *)arr); // Associate the array with the thread
  }
  else if (__builtin_expect(offset > arr->size, 0)) // If the offset exceeds the current array size, resize it
  {
    pointer orig_size = arr->size;
    pointer size = orig_size * 2;
    if (offset > size)
      size = offset + 32;
    arr = realloc(arr, (size + 1) * sizeof(void *)); // Resize the array
    if (arr == NULL)
      abort(); // Abort if allocation fails
    arr->size = size; // Update the array size
    memset(arr->data + orig_size, 0, (size - orig_size) * sizeof(void *)); // Initialize the new elements to zero
    __gthread_setspecific(emutls_key, (void *)arr); // Update the thread-specific array
  }

  void *ret = arr->data[offset - 1]; // Retrieve the TLS address
  if (__builtin_expect(ret == NULL, 0)) // If the address is null, allocate memory
  {
    ret = emutls_alloc(obj);
    arr->data[offset - 1] = ret; // Store the allocated memory in the array
  }
  return ret; // Return the TLS address
#endif
}
","The __emutls_get_address function retrieves or creates the thread-local address for a given TLS object. For non-threaded environments, it simply returns a pointer to the TLS object. In multithreaded environments, it initializes the TLS system if not already done, retrieves the thread-specific storage array, and ensures the array is properly sized to accommodate the object. If the address for the object does not exist, it allocates and initializes the memory. The function is optimized with atomic operations and is critical for thread-safe access to TLS objects."
"// Function to register a common TLS object with specific size, alignment, and template
EMUTLS_ATTR void
__emutls_register_common(struct __emutls_object *obj,
                         word size, word align, void *templ)
{
  // Update the object's size and template if necessary
  if (obj->size < size)
  {
    obj->size = size;
    obj->templ = NULL;
  }
  // Update the object's alignment if necessary
  if (obj->align < align)
    obj->align = align;
  // Set the template if it matches the current size
  if (templ && size == obj->size)
    obj->templ = templ;
}","This function registers a common TLS object, updating its size, alignment, and template if needed. It ensures that the object's metadata (such as size and alignment) meets or exceeds the requested values and sets the provided template if it matches the object size. This function is used to manage TLS object metadata consistently across the program."
"/* Function to convert an unsigned integer (USItype) to a double-precision floating-point value (DFtype). */
DFtype
__floatunsidf (USItype u)
{
  /* Cast the unsigned integer (u) to a signed integer (s). */
  SItype s = (SItype) u;

  /* Convert the signed integer (s) to a double-precision floating-point value (r). */
  DFtype r = (DFtype) s;

  /* Check if the signed integer (s) is negative. */
  if (s < 0)
    /* Adjust the result (r) by adding a correction value to account for
       unsigned-to-signed conversion overflow. */
    r += (DFtype)2.0 * (DFtype)((USItype)1
                                 << (sizeof(USItype) * __CHAR_BIT__ - 1));

  /* Return the final double-precision floating-point value. */
  return r;
}","The __floatunsidf function converts an unsigned integer (USItype) into a double-precision floating-point value (DFtype).

Unsigned-to-Signed Casting: It first casts the unsigned integer to a signed integer. This allows handling values that exceed the signed range by interpreting the most significant bit as the sign bit.

Floating-Point Conversion: The signed integer is then converted into a floating-point value.

Overflow Adjustment: If the signed value is negative (indicating an overflow during the cast), the function adds a correction value. This correction compensates for the overflow by effectively adding back the value of the unsigned overflowed portion.

Return Value: The final floating-point representation of the unsigned integer is returned.

This function is essential for converting unsigned integers to floating-point representations in a way that ensures correctness even when the value exceeds the signed integer range."
"/* Function to convert an unsigned integer (USItype) to a single-precision floating-point value (SFtype). */
SFtype
__floatunsisf (USItype u)
{
  /* Cast the unsigned integer (u) to a signed integer (s). */
  SItype s = (SItype) u;

  /* Check if the signed integer (s) is negative, indicating overflow. */
  if (s < 0)
    {
      /* Compute a rounded value by combining the least significant bit (u & 1)
         with a right-shifted version of the value (u >> 1).
         This ensures proper rounding if any nonzero bits are shifted out. */
      return (SFtype) 2.0 * (SFtype) (SItype) ((u & 1) | (u >> 1));
    }
  else
    /* If no overflow occurred, directly cast the signed integer (s) to single-precision. */
    return (SFtype) s;
}
","The __floatunsisf function converts an unsigned integer (USItype) into a single-precision floating-point value (SFtype).

Unsigned-to-Signed Casting: The unsigned integer is first cast to a signed integer. This step allows handling overflow scenarios where the unsigned value exceeds the range of the signed integer.

Overflow Handling:

If the cast result is negative, it indicates an overflow.
The function computes a rounded value to avoid precision loss. This involves:
Extracting the least significant bit (u & 1).
Right-shifting the value (u >> 1).
Combining these to ensure proper rounding of the floating-point result.
Normal Conversion:

If there is no overflow (i.e., the signed value is non-negative), the value is directly converted to single-precision.
Return Value: The function returns a single-precision floating-point representation of the unsigned integer, ensuring accurate rounding in overflow scenarios.

This function is typically used in low-level code for precise conversions between integer and floating-point representations, especially in scenarios requiring strict compliance with rounding rules."
"/* Function to convert an unsigned integer (USItype) to a quad-precision floating-point value (TFtype). */
TFtype
__floatunsitf (USItype u)
{
  /* Cast the unsigned integer (u) to a signed integer (s). */
  SItype s = (SItype) u;

  /* Convert the signed integer (s) to a quad-precision floating-point value (r). */
  TFtype r = (TFtype) s;

  /* Check if the signed integer (s) is negative, indicating overflow. */
  if (s < 0)
    {
      /* Adjust the result (r) to account for the overflow:
         Add the quad-precision representation of 2.0 multiplied by
         the highest bit value of the unsigned type (USItype).
         This value is calculated as (1 << (number of bits in USItype - 1)). */
      r += (TFtype) 2.0 * (TFtype) ((USItype) 1
                                    << (sizeof (USItype) * __CHAR_BIT__ - 1));
    }

  /* Return the computed quad-precision floating-point value. */
  return r;
}
","The __floatunsitf function converts an unsigned integer (USItype) into a quad-precision floating-point value (TFtype).

Unsigned-to-Signed Casting: The unsigned integer is first cast to a signed integer. This allows the function to detect overflow when the unsigned value exceeds the range of the signed integer.

Conversion to Quad-Precision:

The signed integer is converted to a quad-precision floating-point value.
If the cast result is negative, it indicates that the unsigned value was too large to fit into a signed integer.
Overflow Adjustment:

When overflow is detected, the function adjusts the quad-precision result by adding a correction factor.
The correction factor represents the highest bit value of the unsigned integer type in quad-precision format. This ensures accurate conversion for values that would overflow the signed integer range.
Return Value: The function returns the quad-precision floating-point representation of the unsigned integer, with adjustments for overflow.

This function is used in scenarios requiring high-precision floating-point operations, such as numerical computing or low-level arithmetic libraries, ensuring accurate conversion from unsigned integers to quad-precision values."
"/* Function to convert an unsigned integer (USItype) to an extended-precision floating-point value (XFtype). */
XFtype
__floatunsixf (USItype u)
{
  /* Cast the unsigned integer (u) to a signed integer (s). */
  SItype s = (SItype) u;

  /* Convert the signed integer (s) to an extended-precision floating-point value (r). */
  XFtype r = (XFtype) s;

  /* Check if the signed integer (s) is negative, indicating overflow. */
  if (s < 0)
    {
      /* Adjust the result (r) to account for the overflow:
         Add the extended-precision representation of 2.0 multiplied by
         the highest bit value of the unsigned type (USItype).
         This value is calculated as (1 << (number of bits in USItype - 1)). */
      r += (XFtype) 2.0 * (XFtype) ((USItype) 1
                                    << (sizeof (USItype) * __CHAR_BIT__ - 1));
    }

  /* Return the computed extended-precision floating-point value. */
  return r;
}
","The __floatunsixf function converts an unsigned integer (USItype) into an extended-precision floating-point value (XFtype). It ensures accurate conversion for large unsigned values, even if they exceed the range of signed integers.

Unsigned-to-Signed Casting:

The unsigned integer is cast to a signed integer to handle potential overflow scenarios where the unsigned value cannot be represented as a signed integer.
Conversion to Extended-Precision:

The signed integer is then converted to an extended-precision floating-point value.
Extended precision provides higher accuracy and a larger dynamic range than standard floating-point formats.
Overflow Adjustment:

If the signed integer value is negative (indicating overflow during the cast), the function adjusts the floating-point result.
The adjustment involves adding a correction factor, which is the highest bit value of the unsigned integer type represented as an extended-precision floating-point value.
Return Value:

The function returns the extended-precision floating-point representation of the unsigned integer, ensuring correctness for all possible values.
This function is typically utilized in low-level arithmetic or systems programming tasks requiring precision and correctness when converting large unsigned integers to extended-precision floating-point values."
"/* Function to release all stack segments when a thread exits. */
static void
free_segments (void* arg)
{
  /* Block signals during cleanup to prevent interruptions that may split the stack. */
  if (pthread_sigmask)
    {
      sigset_t mask;
      sigfillset(&mask); // Block all signals.
      pthread_sigmask(SIG_BLOCK, &mask, NULL);
    }

  /* Release stack segments associated with the thread. */
  __morestack_release_segments((struct stack_segment **)arg, 1);
}","free_segments:

Cleans up stack segments for a thread when it exits.
Blocks signals during cleanup to prevent interference from signal handlers."
"/* Create the thread-specific key for stack segments. Called via pthread_once. */
static void
create_key (void)
{
  int err;

  /* Create a key for thread-specific data to hold stack segments. */
  err = pthread_key_create(&segment_list_key, free_segments);
  if (err != 0)
    {
      static const char msg[] = ""pthread_key_create failed: errno "";
      __morestack_fail(msg, sizeof msg - 1, err); // Report the error and abort.
    }
}","create_key:

Creates a thread-specific key to store stack segment data.
Called once for the process lifetime using pthread_once."
"static void *
stack_split_initialize_thread (void *varg)
{
  struct pthread_create_args *args = (struct pthread_create_args *) varg;
  int err;
  void *(*start_routine) (void *);
  void *arg;

  /* Initialize stack-specific settings for the thread. */
  __stack_split_initialize();

  /* Set the stack segments for the current thread. */
  err = pthread_setspecific(segment_list_key, (void *)&__morestack_segments);
  if (err != 0)
    {
      static const char msg[] = ""pthread_setspecific failed: errno "";
      __morestack_fail(msg, sizeof msg - 1, err); // Report the error and abort.
    }

  /* Retrieve the thread entry function and its arguments. */
  start_routine = args->start_routine;
  arg = args->arg;
  free(args); // Free the argument structure.

  /* Call the actual thread entry function. */
  return (*start_routine)(arg);
}","stack_split_initialize_thread:

Initializes thread-specific stack settings and sets up the stack guard.
Calls the actual thread entry function after initialization."
"int
__wrap_pthread_create (pthread_t *tid, const pthread_attr_t *attr,
                       void *(*start_routine) (void *), void *arg)
{
  int err;
  struct pthread_create_args* args;

  /* Ensure the key is created only once using pthread_once. */
  err = pthread_once(&create_key_once, create_key);
  if (err != 0)
    {
      static const char msg[] = ""pthread_once failed: errno "";
      __morestack_fail(msg, sizeof msg - 1, err); // Report the error and abort.
    }

  /* Allocate memory for the thread arguments. */
  args = malloc(sizeof(struct pthread_create_args));
  if (args == NULL)
    return EAGAIN; // Return error if memory allocation fails.

  /* Populate the argument structure. */
  args->start_routine = start_routine;
  args->arg = arg;

  /* Call the real pthread_create with the initialization wrapper. */
  return __real_pthread_create(tid, attr, stack_split_initialize_thread, args);
}","The function __wrap_pthread_create is a wrapper around the standard pthread_create function. Its primary purpose is to ensure that stack-related initializations, such as creating a thread-specific key for stack segments, are performed before creating a new thread. This function plays a vital role in environments that use split stacks, which require special handling for thread-local stack management.

Key Steps in the Function
Ensure Key Initialization:

The function uses pthread_once to ensure the create_key function is executed exactly once during the program's lifetime. This step creates a thread-local key for storing stack segment data.
If pthread_once fails, the function logs the error and terminates execution using __morestack_fail.
Argument Allocation:

It dynamically allocates memory for a pthread_create_args structure to hold the thread's entry function (start_routine) and its argument (arg).
If memory allocation fails, the function returns EAGAIN, indicating that the system lacks resources to create the thread.
Argument Population:

The allocated structure is populated with the thread's entry function and its argument.
Thread Creation:

The function calls the real pthread_create (referred to as __real_pthread_create) with a modified entry function, stack_split_initialize_thread. This wrapper ensures that necessary stack-related initializations are performed for the new thread.
By intercepting calls to pthread_create, __wrap_pthread_create integrates stack-specific setup seamlessly into the thread creation process, ensuring proper behavior in environments using split-stack memory models."
"// Function to retrieve the corresponding box-drawing character based on the direction of the lines
cppchar_t
text_art::get_box_drawing_char (directions line_dirs)
{
  // Convert the directions object to an index (a value between 0 and 15)
  const size_t idx = line_dirs.as_index ();  
  gcc_assert (idx < 16);  // Ensure that the index is within bounds (0-15)
  
  // Return the corresponding character from the lookup table
  return box_drawing_chars[idx];
}","text_art::get_box_drawing_char Function:

Purpose: This function takes a directions object, which encodes the state of the lines (whether they are present or not in each direction), and looks up the corresponding box-drawing character from the box_drawing_chars array.
Parameters:
line_dirs: An object that represents the direction of the lines.
Return Value: It returns the character from box_drawing_chars corresponding to the combination of lines specified by line_dirs.
Implementation:
The function uses line_dirs.as_index() to convert the directions object into an index.
The index is checked to ensure it is within the valid range (0 to 15) using the gcc_assert function.
It then retrieves the corresponding character from the array."
"// Function to run self-tests for box-drawing characters
  void
  text_art_box_drawing_cc_tests ()
  {
    // Run assertions for different direction combinations and their corresponding box-drawing characters
    ASSERT_EQ (text_art::get_box_drawing_char
              (text_art::directions (false, false, false, false)),
             ' ');  // No lines should result in a space
    
    ASSERT_EQ (text_art::get_box_drawing_char
               (text_art::directions (false, false, true, true)),
             0x2500); /* BOX DRAWINGS LIGHT HORIZONTAL (U+2500) */
    
    ASSERT_EQ (text_art::get_box_drawing_char
               (text_art::directions (true, true, false, false)),
             0x2502); /* BOX DRAWINGS LIGHT VERTICAL (U+2502) */
    
    ASSERT_EQ (text_art::get_box_drawing_char
               (text_art::directions (true, false, true, false)),
             0x2518); /* BOX DRAWINGS LIGHT UP AND LEFT (U+2518) */
  }
","Self-Test Code (text_art_box_drawing_cc_tests):

Purpose: This is a set of unit tests to validate the behavior of the get_box_drawing_char function.
Tests:
The tests assert that for various combinations of line directions (e.g., no lines, horizontal lines, vertical lines, etc.), the correct box-drawing character is returned.
Each ASSERT_EQ compares the function's output with the expected result, which is either a space or a specific Unicode box-drawing character (e.g., 0x2500 for light horizontal)."
"// Paints a single character with style at the specified coordinate
void
canvas::paint (coord_t coord, styled_unichar ch)
{
  m_cells.set (coord, std::move (ch));  // Sets the styled character at the given coordinate
}
","This method paints (sets) a specific cell in the canvas with a given character and style at the specified coordinate.
Parameters:

coord: The coordinates (x, y) of the cell where the character will be painted.
ch: The styled_unichar object representing the character (and its style) to be painted.
Functionality:
Calls the set method on m_cells to paint the character at the specified coordinate."
"// Paints a string of text starting at a specified coordinate
void
canvas::paint_text (coord_t coord, const styled_string &text)
{
  for (auto ch : text)  // Iterates over each character in the string
    {
      paint (coord, ch);  // Paints each character at the current coordinate
      if (ch.double_width_p ())  // If the character is a double-width character (like emoji)
        coord.x += 2;  // Move the coordinate by 2 units
      else
        coord.x++;  // Otherwise, move the coordinate by 1 unit
    }
}","This function paints a string of characters on the canvas, adjusting for double-width characters.
Parameters:

coord: The starting coordinates where the text will be painted.
text: A styled_string object containing the text to be painted on the canvas.
Functionality:
Iterates over each character in the text.
Paints each character in sequence using the paint method, adjusting the x coordinate for double-width characters (increases by 2 for characters that occupy two spaces, otherwise by 1)."
"// Fills a rectangular area of the canvas with a single character
void
canvas::fill (rect_t rect, cell_t c)
{
  for (int y = rect.get_min_y (); y < rect.get_next_y (); y++)  // Iterates over rows in the rectangle
    for (int x = rect.get_min_x (); x < rect.get_next_x (); x++)  // Iterates over columns in the rectangle
      paint(coord_t (x, y), c);  // Paints the specified character at each coordinate
}","Description:
This method fills a rectangular area of the canvas with a given character.
Parameters:

rect: A rect_t object that defines the bounds (start and end coordinates) of the rectangle to be filled.
c: A cell_t object representing the character that will fill the rectangle.
Functionality:
Loops through all the coordinates within the rectangle and paints the given character at each point."
"// Fills the entire canvas with the '*' character for debugging purposes
void
canvas::debug_fill ()
{
  fill (rect_t (coord_t (0, 0), get_size ()), cell_t ('*'));  // Fills the whole canvas with '*' symbols
}
","Description:
This is a debug utility function that fills the entire canvas with a '*' character for visual inspection.
Functionality:

Calls the fill method with a rect_t covering the entire canvas, filling it with '*'"
"// Prints the canvas content to a pretty printer, with optional prefix per line
void
canvas::print_to_pp (pretty_printer *pp,
                     const char *per_line_prefix) const
{
  for (int y = 0; y < m_cells.get_size ().h; y++)  // Iterates over each row in the canvas
    {
      style::id_t curr_style_id = 0;
      if (per_line_prefix)  // If there's a line prefix, print it
        pp_string (pp, per_line_prefix);

      pretty_printer line_pp;
      pp_show_color (&line_pp) = pp_show_color (pp);  // Copies color settings from the main printer
      line_pp.set_url_format (pp->get_url_format ());  // Sets URL format for the printer
      const int final_x_in_row = get_final_x_in_row (y);  // Get the last column with content in this row
      for (int x = 0; x <= final_x_in_row; x++)  // Iterates over each column in the row
        {
          if (x > 0)
            {
              const cell_t prev_cell = m_cells.get (coord_t (x - 1, y));  // Checks the previous cell
              if (prev_cell.double_width_p ())  // If the previous cell is part of a double-width character
                continue;  // Skip this cell
            }
          const cell_t cell = m_cells.get (coord_t (x, y));  // Get the current cell
          if (cell.get_style_id () != curr_style_id)  // If the style has changed
            {
              m_style_mgr.print_any_style_changes (&line_pp, curr_style_id, cell.get_style_id ());
              curr_style_id = cell.get_style_id ();  // Update the current style ID
            }
          pp_unicode_character (&line_pp, cell.get_code ());  // Print the character
          if (cell.emoji_variant_p ())  // If it's an emoji, append the variation selector
            pp_unicode_character (&line_pp, 0xFE0F);
        }
      m_style_mgr.print_any_style_changes (&line_pp, curr_style_id, 0);  // Reset the style at the end of the line
      const char *line_buf = pp_formatted_text (&line_pp);  // Get the formatted text
      ::size_t len = strlen (line_buf);
      while (len > 0)  // Remove trailing whitespace
        {
          if (line_buf[len - 1] == ' ')
            len--;
          else
            break;
        }
      pp_append_text (pp, line_buf, line_buf + len);  // Append the formatted text to the pretty printer
      pp_newline (pp);  // Insert a newline after each row
}
","Description:
This method prints the contents of the canvas to a pretty printer (pp), with optional line prefixes and color formatting.
Parameters:

pp: A pointer to a pretty_printer object that handles the printing of styled content.
per_line_prefix: A string that, if provided, will be prefixed to each printed line.
Functionality:
Loops over each row (y) and each column (x) of the canvas.
Checks for style changes and prints the corresponding characters with proper formatting (handling color changes and special characters like emojis).
Appends each line to pp and trims trailing whitespaces."
"// Debug function for printing the canvas content with optional style printing
DEBUG_FUNCTION void
canvas::debug (bool styled) const
{
  pretty_printer pp;
  if (styled)  // If styling is enabled
    {
      pp_show_color (&pp) = true;
      pp.set_url_format (determine_url_format (DIAGNOSTICS_URL_AUTO));  // Set URL format for debugging
    }
  print_to_pp (&pp);  // Print the canvas content
  fprintf (stderr, ""%s\n"", pp_formatted_text (&pp));  // Output the formatted content to stderr
}","Description:
This is a debugging function that outputs the entire canvas, optionally with color styles, to standard error.
Parameters:

styled: A boolean flag indicating whether to include styling information in the output.
Functionality:
Calls the print_to_pp function to generate the canvas representation.
Outputs the result to stderr using the pp_formatted_text function from the pretty_printer."
"// Finds the right-most non-default cell in a row (or -1 if all cells are default)
int
canvas::get_final_x_in_row (int y) const
{
  for (int x = m_cells.get_size ().w - 1; x >= 0; x--)  // Starts from the right-most column
    {
      cell_t cell = m_cells.get (coord_t (x, y));  // Get the current cell
      if (cell.get_code () != ' ' || cell.get_style_id () != style::id_plain)  // If it's not a default cell
        return x;  // Return the column index of the right-most non-default cell
    }
  return -1;  // If no non-default cells are found, return -1
}","Description:
This function finds the rightmost non-default (non-space) character in a row. If all cells are default (empty), it returns -1.
Parameters:

y: The row (y coordinate) in which to find the rightmost non-default cell.
Return Value:
The x coordinate of the rightmost non-default cell in the specified row, or -1 if all cells are default.
Functionality:
Iterates over each column in the row (x) from right to left, checking if the cell contains a non-space character or if its style is different from the default style.
Returns the x coordinate of the first such cell found."
"// Self-test function for a blank canvas
static void
test_blank ()
{
  style_manager sm;
  canvas c (canvas::size_t (5, 5), sm);
  ASSERT_CANVAS_STREQ (c, false,
                       (""\n""
                        ""\n""
                        ""\n""
                        ""\n""
                        ""\n""));
}","Description:
This self-test function checks if a blank canvas renders correctly with no characters painted on it.
Functionality:

Creates a 5x5 canvas and asserts that the content matches the expected blank output."
"// Self-test function for painting a few characters on the canvas
static void
test_abc ()
{
  style_manager sm;
  canvas c (canvas::size_t (3, 3), sm);
  c.paint (canvas::coord_t (0, 0), styled_unichar ('A'));
  c.paint (canvas::coord_t (1, 1), styled_unichar ('B'));
  c.paint (canvas::coord_t (2, 2), styled_unichar ('C'));

  ASSERT_CANVAS_STREQ (c, false,
                       ""A\n B\n  C\n"");
}","Description:
This test checks the painting of individual characters at specific coordinates, forming a diagonal of 'A', 'B', and 'C'.
Functionality:

Paints 'A', 'B', and 'C' at coordinates (0,0), (1,1), and (2,2) respectively, then checks if the output matches the expected diagonal format."
"// Self-test function for filling the canvas with '*' symbols
static void
test_debug_fill ()
{
  style_manager sm;
  canvas c (canvas::size_t (5, 3), sm);
  c.debug_fill();
  ASSERT_CANVAS_STREQ (c, false,
                       (""*****\n""
                        ""*****\n""
                        ""*****\n""));
}","Description:
This self-test checks the debug_fill function by verifying that the entire canvas is filled with '*' characters.
Functionality:

Fills a 5x3 canvas with '*' and verifies that the output matches the expected result."
"// Self-test function for painting a string of text on the canvas
static void
test_text ()
{
  style_manager sm;
  canvas c (canvas::size_t (6, 1), sm);
  c.paint_text (canvas::coord_t (0, 0), styled_string (sm, ""012345""));
  ASSERT_CANVAS_STREQ (c, false,
                       (""012345\n""));

  /* Paint an emoji character that should occupy two canvas columns when
     printed.  */
  c.paint_text (canvas::coord_t (2, 0), styled_string ((cppchar_t)0x1f642));
  ASSERT_CANVAS_STREQ (c, false,
                       (""01🙂45\n""));
}","Description:
This test checks the painting of a text string and handles the painting of an emoji, ensuring the canvas correctly handles multi-column characters.
Functionality:

Paints the string ""012345"" on a 6x1 canvas.
Paints an emoji character at position (2,0) and verifies the correct rendering of the string with an emoji."
"// Function to test drawing a circle on a canvas with alternating characters.
static void test_circle ()
{
  // Create a 30x30 canvas.
  canvas::size_t sz (30, 30);
  style_manager sm; // Style manager to handle the styles for drawing.
  canvas canvas (sz, sm); // Create a canvas with the given size and style manager.
  
  // Define the center of the canvas (middle point).
  canvas::coord_t center (sz.w / 2, sz.h / 2);
  
  // Define the circle's radius and the squared radius for comparison.
  const int radius = 12;
  const int radius_squared = radius * radius;
  
  // Loop through each point in the canvas.
  for (int x = 0; x < sz.w; x++)
    for (int y = 0; y < sz.h; y++)
    {
      // Calculate the difference from the center point in both x and y directions.
      int dx = x - center.x;
      int dy = y - center.y;
      
      // Select a character (""A"" or ""B"") based on the sum of x and y.
      char ch = ""AB""[(x + y) % 2];
      
      // If the point lies inside the circle (i.e., distance from center < radius), paint it.
      if (dx * dx + dy * dy < radius_squared)
        canvas.paint (canvas::coord_t (x, y), styled_unichar (ch));
    }
  
  // Test that the canvas is drawn correctly using the expected pattern of ""A"" and ""B"".
  ASSERT_CANVAS_STREQ
    (canvas, false,
     (""\n""
      ""\n""
      ""\n""
      ""\n""
      ""           BABABABAB\n""
      ""         ABABABABABABA\n""
      ""        ABABABABABABABA\n""
      ""       ABABABABABABABABA\n""
      ""      ABABABABABABABABABA\n""
      ""     ABABABABABABABABABABA\n""
      ""     BABABABABABABABABABAB\n""
      ""    BABABABABABABABABABABAB\n""
      ""    ABABABABABABABABABABABA\n""
      ""    BABABABABABABABABABABAB\n""
      ""    ABABABABABABABABABABABA\n""
      ""    BABABABABABABABABABABAB\n""
      ""    ABABABABABABABABABABABA\n""
      ""    BABABABABABABABABABABAB\n""
      ""     BABABABABABABABABABAB\n""
      ""     ABABABABABABABABABABA\n""
      ""      ABABABABABABABABABA\n""
      ""       ABABABABABABABABA\n""
      ""        ABABABABABABABA\n""
      ""         ABABABABABABA\n""
      ""           BABABABAB\n""
      ""\n""
      ""\n""
      ""\n""));
}
","Description:
This test generates a circle pattern on the canvas using two alternating characters ('A' and 'B') within a circular radius.
Functionality:

Iterates over a 30x30 canvas, calculating whether each point lies within a circle, and alternates between 'A' and 'B' based on the position."
"// Function to test drawing a circle with two different colors based on distance.
static void test_color_circle ()
{
  // Define a 10x10 canvas.
  const canvas::size_t sz (10, 10);
  const canvas::coord_t center (sz.w / 2, sz.h / 2);
  
  // Define squared distances for the outer and inner parts of the circle.
  const int outer_r2 = 25; // Outer radius squared.
  const int inner_r2 = 10; // Inner radius squared.
  
  style_manager sm; // Style manager for color handling.
  canvas c (sz, sm); // Create a canvas.
  
  // Loop through each point in the canvas.
  for (int x = 0; x < sz.w; x++)
    for (int y = 0; y < sz.h; y++)
    {
      // Calculate the squared distance from the center.
      const int dist_from_center_squared
        = ((x - center.x) * (x - center.x) + (y - center.y) * (y - center.y));
      
      // If the point is within the outer radius, paint it.
      if (dist_from_center_squared < outer_r2)
      {
        style s; // Create a style for painting.
        
        // Choose red for points within the inner radius, green otherwise.
        if (dist_from_center_squared < inner_r2)
          s.m_fg_color = style::named_color::RED;
        else
          s.m_fg_color = style::named_color::GREEN;
        
        // Paint the point with the chosen color.
        c.paint (canvas::coord_t (x, y), styled_unichar ('*', false, sm.get_or_create_id (s)));
      }
    }
  
  // Check that the number of styles is 3 (one for red, one for green, and one default).
  ASSERT_EQ (sm.get_num_styles (), 3);
  
  // Test the canvas output to ensure the correct pattern is drawn.
  ASSERT_CANVAS_STREQ
    (c, false,
     (""\n""
      ""   *****\n""
      ""  *******\n""
      "" *********\n""
      "" *********\n""
      "" *********\n""
      "" *********\n""
      "" *********\n""
      ""  *******\n""
      ""   *****\n""));
  
  // Test that the colors are correctly represented in the canvas output with escape sequences.
  ASSERT_CANVAS_STREQ
    (c, true,
     (""\n""
      ""   [32m[K*****[m[K\n""
      ""  [32m[K***[31m[K*[32m[K***[m[K\n""
      "" [32m[K**[31m[K*****[32m[K**[m[K\n""
      "" [32m[K**[31m[K*****[32m[K**[m[K\n""
      "" [32m[K*[31m[K*******[32m[K*[m[K\n""
      "" [32m[K**[31m[K*****[32m[K**[m[K\n""
      "" [32m[K**[31m[K*****[32m[K**[m[K\n""
      ""  [32m[K***[31m[K*[32m[K***[m[K\n""
      ""   [32m[K*****[m[K\n""));
}
","Description:
This test creates a circular gradient on the canvas, using different colors for points inside and outside an inner radius.
Functionality:

Paints a circle on a 10x10 canvas using two colors (green and red) for the inner and outer areas of the circle."
"// Function to test bold text rendering.
static void test_bold ()
{
  auto_fix_quotes fix_quotes; // Helper to fix quotes in the string.
  style_manager sm; // Style manager for handling styles.
  
  // Create a styled string with a formatted text.
  styled_string s (styled_string::from_fmt (sm, nullptr, ""before %qs after"", ""foo""));
  
  // Create a canvas large enough to hold the string.
  canvas c (canvas::size_t (s.calc_canvas_width (), 1), sm);
  
  // Paint the string on the canvas.
  c.paint_text (canvas::coord_t (0, 0), s);
  
  // Assert that the canvas shows the string with normal text.
  ASSERT_CANVAS_STREQ (c, false, ""before `foo' after\n"");
  
  // Assert that the canvas shows the string with bold formatting for ""foo"".
  ASSERT_CANVAS_STREQ (c, true, ""before `[00;01m[Kfoo[00m[K' after\n"");
}","Description:
This test checks if bold text is properly rendered by the canvas, ensuring that the bold formatting is applied and the result is correctly displayed.
Functionality:

Creates a string with bold formatting and checks if the output correctly applies the bold style."
"// Function to test emoji rendering.
static void test_emoji ()
{
  style_manager sm; // Style manager for emoji handling.
  
  // Create a styled string with the WARNING SIGN emoji.
  styled_string s (0x26A0, true);
  
  // Create a canvas large enough to hold the emoji.
  canvas c (canvas::size_t (s.calc_canvas_width (), 1), sm);
  
  // Paint the emoji on the canvas.
  c.paint_text (canvas::coord_t (0, 0), s);
  
  // Assert that the canvas correctly renders the emoji.
  ASSERT_CANVAS_STREQ (c, false, ""⚠️\n"");
  ASSERT_CANVAS_STREQ (c, true, ""⚠️\n"");
}
","Description:
This test checks if an emoji (U+26A0 WARNING SIGN) is correctly rendered on the canvas.
Functionality:

Paints an emoji on the canvas and verifies that it is correctly displayed both with and without color formatting."
"// Function to test appending multiple emojis in a string.
static void test_emoji_2 ()
{
  style_manager sm; // Style manager for emoji handling.
  
  // Create a styled string with the WARNING SIGN emoji.
  styled_string s;
  s.append (styled_string (0x26A0, true)); // Add emoji.
  s.append (styled_string (sm, ""test"")); // Add regular text.
  
  // Assert the correct number of characters in the string (emoji + text).
  ASSERT_EQ (s.size (), 5);
  
  // Assert the correct width of the string on the canvas.
  ASSERT_EQ (s.calc_canvas_width (), 5);
  
  // Create a canvas to hold the string.
  canvas c (canvas::size_t (s.calc_canvas_width (), 1), sm);
  
  // Paint the string on the canvas.
  c.paint_text (canvas::coord_t (0, 0), s);
  
  // Assert that the canvas correctly renders the emoji and the text.
  ASSERT_CANVAS_STREQ (c, false, ""⚠️test\n"");
}","Description:
This test checks the rendering of an emoji followed by a regular string, ensuring correct handling of emojis and their UTF-8 encoding.
Functionality:

Paints an emoji (U+26A0) followed by the string ""test"" and checks the output, ensuring proper encoding of the emoji and the string."
"// Function to test the canvas rendering of URLs.
static void test_canvas_urls ()
{
  style_manager sm; // Style manager to handle the styles for drawing text and URLs.
  
  // Create a canvas with a size of 9x3 (9 columns, 3 rows).
  canvas canvas (canvas::size_t (9, 3), sm);
  
  // Create a styled string for ""foo"" and set its URL to ""https://www.example.com/foo"".
  styled_string foo_ss (sm, ""foo"");
  foo_ss.set_url (sm, ""https://www.example.com/foo"");
  
  // Create a styled string for ""bar"" and set its URL to ""https://www.example.com/bar"".
  styled_string bar_ss (sm, ""bar"");
  bar_ss.set_url (sm, ""https://www.example.com/bar"");
  
  // Paint the ""foo"" string at position (1, 1) on the canvas.
  canvas.paint_text(canvas::coord_t (1, 1), foo_ss);
  
  // Paint the ""bar"" string at position (5, 1) on the canvas.
  canvas.paint_text(canvas::coord_t (5, 1), bar_ss);

  // Assert that the canvas output matches the expected output without URLs.
  // Expected output: ""foo"" and ""bar"" on the same line with a space between them.
  ASSERT_CANVAS_STREQ (canvas, false,
                       (""\n""
                        "" foo bar\n""
                        ""\n""));
  
  // Create a pretty_printer to format the canvas output with URL formatting.
  pretty_printer pp;
  pp_show_color (&pp) = true; // Enable color in the output.
  
  // Set the URL format to use the ST (ANSI escape sequences) format.
  pp.set_url_format (URL_FORMAT_ST);
  
  // Assert that the canvas output matches the expected output with URL formatting.
  // URLs are inserted using the ANSI escape sequence format.
  assert_canvas_streq (SELFTEST_LOCATION, canvas, &pp,
                         (/* Line 1.  */
                          ""\n""
                          /* Line 2.  */
                          "" ""
                          ""\33]8;;https://www.example.com/foo\33\\foo\33]8;;\33\\""  // URL for foo
                          "" ""
                          ""\33]8;;https://www.example.com/bar\33\\bar\33]8;;\33\\""  // URL for bar
                          ""\n""
                          /* Line 3.  */
                          ""\n""));
  
  // Change the URL format to use BEL (bell character) formatting.
  pp.set_url_format (URL_FORMAT_BEL);
  
  // Assert that the canvas output matches the expected output with BEL format.
  // URLs are inserted using the BEL escape sequence format.
  assert_canvas_streq (SELFTEST_LOCATION, canvas, &pp,
                         (/* Line 1.  */
                          ""\n""
                          /* Line 2.  */
                          "" ""
                          ""\33]8;;https://www.example.com/foo\afoo\33]8;;\a""  // URL for foo
                          "" ""
                          ""\33]8;;https://www.example.com/bar\abar\33]8;;\a""  // URL for bar
                          ""\n""
                          /* Line 3.  */
                          ""\n""));
}","Description:
This test checks if URLs embedded in styled strings are correctly processed and formatted when printed.
Functionality:

Creates two styled strings with URLs and checks that the URLs are embedded correctly in the printed output, both with and without color formatting."
"// Function to run all selftests for this file.
void text_art_canvas_cc_tests ()
{
  // Call each of the individual test functions.
  test_blank ();        // Test blank canvas.
  test_abc ();          // Test canvas with ABC characters.
  test_debug_fill ();   // Test canvas with debug fill.
  test_text ();         // Test canvas with text rendering.
  test_circle ();       // Test canvas with a circle.
  test_color_circle (); // Test canvas with a colored circle.
  test_bold ();         // Test canvas with bold text.
  test_emoji ();        // Test canvas with emoji rendering.
  test_emoji_2 ();      // Test canvas with multiple emojis.
  test_canvas_urls ();  // Test canvas with URL rendering.
}","Description:
This function runs all the self-tests defined in the selftest namespace, ensuring that all canvas-related functionality is working as expected.
Functionality:

Calls each of the individual test functions defined in the selftest namespace."
"// Function to add a label to the x_ruler.
void x_ruler::add_label (const canvas::range_t &r,
                         styled_string text,
                         style::id_t style_id,
                         label_kind kind)
{
  // Push the label with the given range, text, style, and kind into the m_labels vector.
  m_labels.push_back (label (r, std::move (text), style_id, kind));

  // Mark that the layout is invalid so it will be recalculated later.
  m_has_layout = false;
}","This function adds a new label to the x_ruler object. It accepts a range (r), a styled_string (text), a style ID (style_id), and a label kind (kind). The label is appended to the m_labels vector, and the m_has_layout flag is set to false to indicate that the layout needs to be recalculated."
"// Function to get the canvas y-coordinate based on a relative y-coordinate.
int x_ruler::get_canvas_y (int rel_y) const
{
  // Ensure that the relative y-coordinate is within bounds.
  gcc_assert (rel_y >= 0);
  gcc_assert (rel_y < m_size.h);

  // Determine the canvas y-coordinate based on the label's direction.
  switch (m_label_dir)
  {
    default:
      gcc_unreachable (); // Should never reach this case.
    case label_dir::ABOVE:
      // Return the y-coordinate for labels above the ruler.
      return m_size.h - (rel_y + 1);
    case label_dir::BELOW:
      // Return the y-coordinate for labels below the ruler.
      return rel_y;
  }
}","This function calculates the canvas y-coordinate for a given relative y-coordinate (rel_y). It checks the direction of the labels (m_label_dir) and returns the corresponding y-coordinate, either above or below the ruler."
"// Function to paint the x_ruler to the canvas.
void x_ruler::paint_to_canvas (canvas &canvas,
                               canvas::coord_t offset,
                               const theme &theme)
{
  // Ensure the layout is calculated.
  ensure_layout ();

  // (Optional) Fill the canvas with '*' characters in the ruler's area.
  if (0)
    canvas.fill (canvas::rect_t (offset, m_size),
                 canvas::cell_t ('*'));

  // Iterate through each label in the m_labels vector.
  for (size_t idx = 0; idx < m_labels.size (); idx++)
  {
    const label &iter_label = m_labels[idx];

    // Paint the ruler itself.
    const int ruler_rel_y = get_canvas_y (0);
    for (int rel_x = iter_label.m_range.start;
         rel_x < iter_label.m_range.next;
         rel_x++)
    {
      enum theme::cell_kind kind = theme::cell_kind::X_RULER_MIDDLE;

      // Determine the appropriate kind for the left and right edges.
      if (rel_x == iter_label.m_range.start)
      {
        kind = theme::cell_kind::X_RULER_LEFT_EDGE;
        if (idx > 0)
        {
          const label &prev_label = m_labels[idx - 1];
          if (prev_label.m_range.get_max () == iter_label.m_range.start)
            kind = theme::cell_kind::X_RULER_INTERNAL_EDGE;
        }
      }
      else if (rel_x == iter_label.m_range.get_max ())
        kind = theme::cell_kind::X_RULER_RIGHT_EDGE;
      // Handle the connector to the label.
      else if (rel_x == iter_label.m_connector_x)
      {
        switch (m_label_dir)
        {
          default:
            gcc_unreachable (); // Should never reach this case.
          case label_dir::ABOVE:
            kind = theme::cell_kind::X_RULER_CONNECTOR_TO_LABEL_ABOVE;
            break;
          case label_dir::BELOW:
            kind = theme::cell_kind::X_RULER_CONNECTOR_TO_LABEL_BELOW;
            break;
        }
      }

      // Paint the ruler segment at the appropriate position with the selected style.
      canvas.paint (canvas::coord_t (rel_x, ruler_rel_y) + offset,
                    theme.get_cell (kind, iter_label.m_style_id));
    }

    // Paint the vertical connector to the text.
    for (int connector_rel_y = 1;
         connector_rel_y < iter_label.m_text_rect.get_min_y ();
         connector_rel_y++)
    {
      canvas.paint
        ((canvas::coord_t (iter_label.m_connector_x,
                           get_canvas_y (connector_rel_y))
          + offset),
         theme.get_cell (theme::cell_kind::X_RULER_VERTICAL_CONNECTOR,
                         iter_label.m_style_id));
    }

    // Paint the text, based on the label's kind.
    switch (iter_label.m_kind)
    {
      default:
        gcc_unreachable (); // Should never reach this case.
      case x_ruler::label_kind::TEXT:
        // Paint the text label without a border.
        canvas.paint_text
          ((canvas::coord_t (iter_label.m_text_rect.get_min_x (),
                             get_canvas_y (iter_label.m_text_rect.get_min_y ()))
            + offset),
           iter_label.m_text);
        break;

      case x_ruler::label_kind::TEXT_WITH_BORDER:
        {
          // Handle the text label with a border.
          const canvas::range_t rel_x_range
            (iter_label.m_text_rect.get_x_range ());

          enum theme::cell_kind inner_left_kind;
          enum theme::cell_kind inner_connector_kind;
          enum theme::cell_kind inner_right_kind;
          enum theme::cell_kind outer_left_kind;
          enum theme::cell_kind outer_right_kind;

          // Determine the border types based on label direction.
          switch (m_label_dir)
          {
            default:
              gcc_unreachable (); // Should never reach this case.
            case label_dir::ABOVE:
              outer_left_kind = theme::cell_kind::TEXT_BORDER_TOP_LEFT;
              outer_right_kind = theme::cell_kind::TEXT_BORDER_TOP_RIGHT;
              inner_left_kind = theme::cell_kind::TEXT_BORDER_BOTTOM_LEFT;
              inner_connector_kind = theme::cell_kind::X_RULER_CONNECTOR_TO_LABEL_BELOW;
              inner_right_kind = theme::cell_kind::TEXT_BORDER_BOTTOM_RIGHT;
              break;
            case label_dir::BELOW:
              inner_left_kind = theme::cell_kind::TEXT_BORDER_TOP_LEFT;
              inner_connector_kind = theme::cell_kind::X_RULER_CONNECTOR_TO_LABEL_ABOVE;
              inner_right_kind = theme::cell_kind::TEXT_BORDER_TOP_RIGHT;
              outer_left_kind = theme::cell_kind::TEXT_BORDER_BOTTOM_LEFT;
              outer_right_kind = theme::cell_kind::TEXT_BORDER_BOTTOM_RIGHT;
              break;
          }

          // Paint the inner border.
          {
            const int rel_canvas_y
              = get_canvas_y (iter_label.m_text_rect.get_min_y ());
            // Left corner.
            canvas.paint ((canvas::coord_t (rel_x_range.get_min (),
                                            rel_canvas_y)
                           + offset),
                          theme.get_cell (inner_left_kind,
                                          iter_label.m_style_id));
            // Horizontal border and connector.
            const canvas::cell_t edge_border_cell
              = theme.get_cell (theme::cell_kind::TEXT_BORDER_HORIZONTAL,
                                iter_label.m_style_id);
            const canvas::cell_t connector_border_cell
              = theme.get_cell (inner_connector_kind,
                                iter_label.m_style_id);
            for (int rel_x = rel_x_range.get_min () + 1;
                 rel_x < rel_x_range.get_max ();
                 rel_x++)
              if (rel_x == iter_label.m_connector_x)
                canvas.paint ((canvas::coord_t (rel_x, rel_canvas_y)
                               + offset),
                              connector_border_cell);
              else
                canvas.paint ((canvas::coord_t (rel_x, rel_canvas_y)
                               + offset),
                              edge_border_cell);

            // Right corner.
            canvas.paint ((canvas::coord_t (rel_x_range.get_max (),
                                            rel_canvas_y)
                           + offset),
                          theme.get_cell (inner_right_kind,
                                          iter_label.m_style_id));
          }

          // Paint the vertical sides of the border and the text.
          {
            const int rel_canvas_y
              = get_canvas_y (iter_label.m_text_rect.get_min_y () + 1);
            const canvas::cell_t border_cell
              = theme.get_cell (theme::cell_kind::TEXT_BORDER_VERTICAL,
                                iter_label.m_style_id);

            // Left border.
            canvas.paint ((canvas::coord_t (rel_x_range.get_min (),
                                            rel_canvas_y)
                           + offset),
                          border_cell);
            // Text content.
            canvas.paint_text ((canvas::coord_t (rel_x_range.get_min () + 1,
                                                 rel_canvas_y)
                                + offset),
                               iter_label.m_text);
            // Right border.
            canvas.paint ((canvas::coord_t (rel_x_range.get_max (),
                                            rel_canvas_y)
                           + offset),
                          border_cell);
          }

          // Paint the outer border.
          {
            const int rel_canvas_y
              = get_canvas_y (iter_label.m_text_rect.get_max_y ());
            // Left corner.
            canvas.paint ((canvas::coord_t (rel_x_range.get_min (),
                                            rel_canvas_y)
                           + offset),
                          theme.get_cell (outer_left_kind,
                                          iter_label.m_style_id));
            // Horizontal border.
            const canvas::cell_t border_cell
              = theme.get_cell (theme::cell_kind::TEXT_BORDER_HORIZONTAL,
                                iter_label.m_style_id);
            for (int rel_x = rel_x_range.get_min () + 1;
                 rel_x < rel_x_range.get_max ();
                 rel_x++)
              canvas.paint ((canvas::coord_t (rel_x, rel_canvas_y)
                             + offset),
                            border_cell);

            // Right corner.
            canvas.paint ((canvas::coord_t (rel_x_range.get_max (),
                                            rel_canvas_y)
                           + offset),
                          theme.get_cell (outer_right_kind,
                                          iter_label.m_style_id));
          }
        }
        break;
    }
  }
}","This function is responsible for painting the ruler and its labels onto a canvas. It first ensures that the layout is calculated, then iterates through each label in m_labels. For each label, it paints the ruler itself, the connector, and the label's text (with or without a border), depending on the label kind and direction. It makes use of various theme::cell_kind values to determine the style of the ruler and its components."
"DEBUG_FUNCTION void
x_ruler::debug (const style_manager &sm)
{
  // Create a canvas with the size of the ruler and the provided style manager.
  canvas c (get_size (), sm);

  // Paint the ruler onto the canvas at coordinates (0, 0) using the specified theme.
  paint_to_canvas (c, canvas::coord_t (0, 0), unicode_theme ());

  // Output a debug representation of the canvas.
  c.debug (true);
}","Purpose: This function creates a canvas using the provided style_manager, paints the ruler onto the canvas, and then outputs a debug view of the canvas.
Detailed Steps:
A canvas object is created using the size of the ruler and the style manager (sm).
The paint_to_canvas method is called to render the ruler onto the canvas.
The canvas's debug method is invoked with true to display a debug representation."
"x_ruler::label::label (const canvas::range_t &range,
                       styled_string text,
                       style::id_t style_id,
                       label_kind kind)
: m_range (range),
  m_text (std::move (text)),
  m_style_id (style_id),
  m_kind (kind),
  m_text_rect (canvas::coord_t (0, 0),
               canvas::size_t (m_text.calc_canvas_width (), 1)),
  m_connector_x ((m_range.get_min () + m_range.get_max ()) / 2)
{
  // If the label kind is TEXT_WITH_BORDER, adjust the size of the text rectangle to add padding.
  if (kind == label_kind::TEXT_WITH_BORDER)
    {
      m_text_rect.m_size.w += 2;  // Add padding to width.
      m_text_rect.m_size.h += 2;  // Add padding to height.
    }
}
","Purpose: Initializes a label with a specified range, text, style, and label kind.
Detailed Steps:
The constructor takes in a range (specifying where the label will be placed), a styled string text, a style_id, and a label_kind.
The m_text_rect is calculated based on the width of the text, and additional padding is applied if the label has a border (label_kind::TEXT_WITH_BORDER).
The m_connector_x is set as the midpoint of the range."
"bool
x_ruler::label::operator< (const label &other) const
{
  // Compare labels by their range's start position.
  int cmp = m_range.start - other.m_range.start;
  
  // If the start positions are different, use that as the comparison result.
  if (cmp)
    return cmp < 0;
  
  // If the start positions are the same, compare the 'next' position for tie-breaking.
  return m_range.next < other.m_range.next;
}
","Purpose: Defines a comparison operator for sorting labels based on their range (m_range).
Detailed Steps:
The labels are compared based on their m_range.start. If the start points are equal, it compares m_range.next."
"void
x_ruler::ensure_layout ()
{
  // If the layout has already been calculated, no need to recalculate it.
  if (m_has_layout)
    return;
  
  // Otherwise, update the layout and mark it as calculated.
  update_layout ();
  m_has_layout = true;
}
","Purpose: Ensures that the layout is updated if not already done.
Detailed Steps:
If the layout has already been calculated (m_has_layout), this function returns early.
Otherwise, it calls update_layout() to calculate the layout and sets m_has_layout to true."
"void
x_ruler::update_layout ()
{
  // If there are no labels, no need to update the layout.
  if (m_labels.empty ())
    return;

  // Sort the labels by their range (so they can be positioned correctly).
  std::sort (m_labels.begin (), m_labels.end ());

  // Calculate the total width of the ruler by considering the range of the last label.
  int ruler_width = m_labels.back ().m_range.get_next ();
  int width_with_labels = ruler_width;

  // Place labels horizontally by calculating the x-coordinates for each label.
  for (size_t idx = 0; idx < m_labels.size (); idx++)
    {
      label &iter_label = m_labels[idx];
      
      // Calculate the minimum x-coordinate for the label to avoid overlap with the previous label's connector.
      int min_x;
      if (idx > 0)
        {
          // Ensure the label does not overlap with the connector of the previous label.
          int left_neighbor_connector_x = m_labels[idx - 1].m_connector_x;
          min_x = left_neighbor_connector_x + 1;
        }
      else
        {
          // For the first label, ensure it doesn't go beyond the leftmost boundary.
          min_x = 0;
        }

      // Attempt to center the label's text on the canvas.
      int connector_x = iter_label.m_connector_x;
      int centered_x = connector_x - ((int)iter_label.m_text_rect.get_width () / 2);
      
      // Ensure the label's text does not overlap the left boundary.
      int text_x = std::max (min_x, centered_x);
      iter_label.m_text_rect.m_top_left.x = text_x;
    }

  // Place labels vertically by calculating the y-coordinates for each label.
  // Consolidate labels on the same row when possible.
  int label_y = 2;
  for (int idx = m_labels.size () - 1; idx >= 0; idx--)
    {
      label &iter_label = m_labels[idx];
      
      // Get the width of the text to determine where the next label will be placed.
      size_t text_len = iter_label.m_text_rect.get_width ();
      
      // Calculate the x-coordinate immediately after the label's text.
      int next_x = iter_label.m_text_rect.get_min_x () + text_len;
      
      // Check if the label overlaps with the next label in the list.
      if (idx < (int)m_labels.size () - 1)
        {
          if (next_x >= m_labels[idx + 1].m_text_rect.get_min_x ())
            {
              // If it overlaps, start a new row.
              label_y += m_labels[idx + 1].m_text_rect.get_height ();
            }
        }

      // Set the vertical position of the label based on the calculated y-coordinate.
      iter_label.m_text_rect.m_top_left.y = label_y;
      
      // Update the total width with the current label's position.
      width_with_labels = std::max (width_with_labels, next_x);
    }

  // Set the final size of the ruler canvas, which includes the total width and height of all labels.
  m_size = canvas::size_t (width_with_labels,
                           label_y + m_labels[0].m_text_rect.get_height ());
}","Purpose: Ensures that the layout is updated if not already done.
Detailed Steps:
If the layout has already been calculated (m_has_layout), this function returns early.
Otherwise, it calls update_layout() to calculate the layout and sets m_has_layout to true."
"static void
assert_x_ruler_streq (const location &loc,
                      x_ruler &ruler,
                      const theme &theme,
                      const style_manager &sm,
                      bool styled,
                      const char *expected_str)
{
  // Create a canvas for rendering the ruler.
  canvas c (ruler.get_size (), sm);
  
  // Paint the ruler onto the canvas using the given theme.
  ruler.paint_to_canvas (c, canvas::coord_t (0, 0), theme);
  
  // Optionally enable debugging (currently disabled).
  if (0)
    c.debug (styled);
  
  // Compare the rendered canvas with the expected output string.
  assert_canvas_streq (loc, c, styled, expected_str);
}","Purpose:
This function tests the output of the x_ruler component by rendering it onto a canvas with the given theme and comparing the result to the expected output.

Parameters:

location &loc: The location of the test within the code (useful for error reporting).
x_ruler &ruler: The x_ruler object that is being tested.
const theme &theme: The theme used for rendering the ruler.
const style_manager &sm: The style manager to manage the text styles.
bool styled: Flag to indicate whether styled text is being used.
const char *expected_str: The expected string representation of the ruler.
Description:

A canvas is created with the size of the ruler and the provided style_manager.
The ruler is painted onto the canvas using the given theme.
Optionally, debug information can be output (disabled in this case with if (0)).
The rendered output is compared to the expected string (expected_str), and an assertion is made to ensure they match. The assert_canvas_streq function is used for this comparison, which checks whether the canvas's textual representation matches the expected result."
"static void
test_single ()
{
  style_manager sm;
  
  // Create a ruler and add a single label below the ruler.
  x_ruler r (x_ruler::label_dir::BELOW);
  r.add_label (canvas::range_t (0, 11), styled_string (sm, ""foo""),
               style::id_plain, x_ruler::label_kind::TEXT);
  
  // Test the ruler with both ASCII and Unicode themes and compare the output to expected strings.
  ASSERT_X_RULER_STREQ
    (r, ascii_theme (), sm, true,
     (""|~~~~+~~~~|\n""
      ""     |\n""
      ""    foo\n""));
  
  ASSERT_X_RULER_STREQ
    (r, unicode_theme (), sm, true,
     (""├────┬────┤\n""
      ""     │\n""
      ""    foo\n""));
}","Purpose:
This function tests the x_ruler with a single label placed below the ruler and verifies its rendering with both ASCII and Unicode themes.

Description:

A style_manager (sm) is created to manage the styles.
A single x_ruler is created with the label direction set to below the ruler.
A label with text ""foo"" is added to the ruler, starting at position 0 and ending at position 11, using the style::id_plain style and label_kind::TEXT.
The function tests both ASCII and Unicode themes by calling ASSERT_X_RULER_STREQ for each theme.
For the ASCII theme, the expected ruler rendering is:
markdown
Copy code
|~~~~+~~~~|
     |
    foo
For the Unicode theme, the expected ruler rendering is:
markdown
Copy code
├────┬────┤
     │
    foo"
"static void
test_single_above ()
{
  style_manager sm;
  
  // Create a ruler and add a single label above the ruler.
  x_ruler r (x_ruler::label_dir::ABOVE);
  r.add_label (canvas::range_t (0, 11), styled_string (sm, ""hello world""),
               style::id_plain);
  
  // Test the ruler with both ASCII and Unicode themes and compare the output to expected strings.
  ASSERT_X_RULER_STREQ
    (r, ascii_theme (), sm, true,
     (""hello world\n""
      ""     |\n""
      ""|~~~~+~~~~|\n""));
  
  ASSERT_X_RULER_STREQ
    (r, unicode_theme (), sm, true,
     (""hello world\n""
      ""     │\n""
      ""├────┴────┤\n""));
}","Purpose:
This function tests the x_ruler with a single label placed above the ruler and verifies its rendering with both ASCII and Unicode themes.

Description:

A style_manager (sm) is created to manage the styles.
A single x_ruler is created with the label direction set to above the ruler.
A label with text ""hello world"" is added to the ruler, starting at position 0 and ending at position 11, using the style::id_plain style.
The function tests both ASCII and Unicode themes by calling ASSERT_X_RULER_STREQ for each theme.
For the ASCII theme, the expected ruler rendering is:
markdown
Copy code
hello world
     |
|~~~~+~~~~|
For the Unicode theme, the expected ruler rendering is:
markdown
Copy code
hello world
     │
├────┴────┤"
"// Test for multiple contiguous labels placed below the ruler.
static void
test_multiple_contiguous ()
{
  style_manager sm;  // Creates a style manager to manage the styles.
  x_ruler r (x_ruler::label_dir::BELOW);  // Creates a ruler with labels placed below.
  
  // Add two labels to the ruler with ranges and styles.
  r.add_label (canvas::range_t (0, 11), styled_string (sm, ""foo""), style::id_plain);
  r.add_label (canvas::range_t (10, 16), styled_string (sm, ""bar""), style::id_plain);
  
  // Assert the rendered output of the ruler matches the expected result in ASCII theme.
  ASSERT_X_RULER_STREQ
    (r, ascii_theme (), sm, true,
     (""|~~~~+~~~~|~+~~|\n""
      ""     |      |\n""
      ""    foo    bar\n""));
  
  // Assert the rendered output of the ruler matches the expected result in Unicode theme.
  ASSERT_X_RULER_STREQ
    (r, unicode_theme (), sm, true,
     (""├────┬────┼─┬──┤\n""
      ""     │      │\n""
      ""    foo    bar\n""));
}","Purpose: This function tests the rendering of multiple contiguous labels placed below the ruler.
Details: It adds two labels that abut but don't overlap, then asserts the rendered output against expected ASCII and Unicode formats."
"// Test for multiple contiguous labels placed above the ruler.
static void
test_multiple_contiguous_above ()
{
  style_manager sm;
  x_ruler r (x_ruler::label_dir::ABOVE);  // Creates a ruler with labels placed above.
  
  // Add two labels to the ruler with ranges and styles.
  r.add_label (canvas::range_t (0, 11), styled_string (sm, ""foo""), style::id_plain);
  r.add_label (canvas::range_t (10, 16), styled_string (sm, ""bar""), style::id_plain);
  
  // Assert the rendered output of the ruler matches the expected result in ASCII theme.
  ASSERT_X_RULER_STREQ
    (r, ascii_theme (), sm, true,
     (""    foo    bar\n""
      ""     |      |\n""
      ""|~~~~+~~~~|~+~~|\n""));
  
  // Assert the rendered output of the ruler matches the expected result in Unicode theme.
  ASSERT_X_RULER_STREQ
    (r, unicode_theme (), sm, true,
     (""    foo    bar\n""
      ""     │      │\n""
      ""├────┴────┼─┴──┤\n""));
}","Purpose: Similar to test_multiple_contiguous, but the labels are placed above the ruler.
Details: The labels are placed above, and the function verifies that the output matches the expected result for both themes."
"// Test for abutting labels that are contiguous but do not overlap.
static void
test_multiple_contiguous_abutting_labels ()
{
  style_manager sm;
  x_ruler r (x_ruler::label_dir::BELOW);
  
  // Add two contiguous labels that abut each other.
  r.add_label (canvas::range_t (0, 11), styled_string (sm, ""12345678""), style::id_plain);
  r.add_label (canvas::range_t (10, 16), styled_string (sm, ""1234678""), style::id_plain);
  
  // Assert the rendered output in Unicode theme for abutting labels.
  ASSERT_X_RULER_STREQ
    (r, unicode_theme (), sm, true,
     (""├────┬────┼─┬──┤\n""
      ""     │      │\n""
      ""     │   1234678\n""
      "" 12345678\n""));
}","Purpose: This tests the case where the labels are placed next to each other, with no overlap but abutting.
Details: The function checks the rendered output for overlapping contiguous labels with abutment at the boundary."
"// Test for overlapping labels, where ranges intersect.
static void
test_multiple_contiguous_overlapping_labels ()
{
  style_manager sm;
  x_ruler r (x_ruler::label_dir::BELOW);
  
  // Add two overlapping labels.
  r.add_label (canvas::range_t (0, 11), styled_string (sm, ""123456789""), style::id_plain);
  r.add_label (canvas::range_t (10, 16), styled_string (sm, ""12346789""), style::id_plain);
  
  // Assert the rendered output in Unicode theme for overlapping labels.
  ASSERT_X_RULER_STREQ
    (r, unicode_theme (), sm, true,
     (""├────┬────┼─┬──┤\n""
      ""     │      │\n""
      ""     │  12346789\n""
      "" 123456789\n""));
}","Purpose: This function checks the scenario where labels overlap with each other.
Details: The function tests if the overlapping labels are handled correctly with a special emphasis on the rendered output for Unicode themes."
"// Test for a label that touches the left border.
static void
test_abutting_left_border ()
{
  style_manager sm;
  x_ruler r (x_ruler::label_dir::BELOW);
  
  // Add a label that starts at position 0.
  r.add_label (canvas::range_t (0, 6), styled_string (sm, ""this is a long label""), style::id_plain);
  
  // Assert the rendered output in Unicode theme for label at left border.
  ASSERT_X_RULER_STREQ
    (r, unicode_theme (), sm, true,
     (""├─┬──┤\n""
      ""  │\n""
      ""this is a long label\n""));
}","Purpose: This tests placing a label starting at the left border of the ruler.
Details: It adds a label that starts at the very beginning of the ruler, ensuring the rendering is correct."
"// Test for labels that are too long to consolidate vertically.
static void
test_too_long_to_consolidate_vertically ()
{
  style_manager sm;
  x_ruler r (x_ruler::label_dir::BELOW);
  
  // Add two labels that are too long to fit vertically.
  r.add_label (canvas::range_t (0, 11), styled_string (sm, ""long string A""), style::id_plain);
  r.add_label (canvas::range_t (10, 16), styled_string (sm, ""long string B""), style::id_plain);
  
  // Assert the rendered output in Unicode theme for too long labels.
  ASSERT_X_RULER_STREQ
    (r, unicode_theme (), sm, true,
     (""├────┬────┼─┬──┤\n""
      ""     │      │\n""
      ""     │long string B\n""
      ""long string A\n""));
}
","Purpose: This tests cases where labels are too long to fit vertically, forcing a different arrangement.
Details: Two long labels are added, and the function ensures they are rendered appropriately when they exceed vertical limits."
"// Test for abutting neighboring labels with long strings.
static void
test_abutting_neighbor ()
{
  style_manager sm;
  x_ruler r (x_ruler::label_dir::BELOW);
  
  // Add two labels that abut but are not overlapping.
  r.add_label (canvas::range_t (0, 11), styled_string (sm, ""very long string A""), style::id_plain);
  r.add_label (canvas::range_t (10, 16), styled_string (sm, ""very long string B""), style::id_plain);
  
  // Assert the rendered output in Unicode theme for abutting neighboring labels.
  ASSERT_X_RULER_STREQ
    (r, unicode_theme (), sm, true,
     (""├────┬────┼─┬──┤\n""
      ""     │      │\n""
      ""     │very long string B\n""
      ""very long string A\n""));
}","Purpose: This tests abutting neighboring labels that are very long.
Details: The function checks if the rendered output accommodates long strings abutting without overlap."
"// Test for labels with gaps between them.
static void
test_gaps ()
{
  style_manager sm;
  x_ruler r (x_ruler::label_dir::BELOW);
  
  // Add two labels with a gap between them.
  r.add_label (canvas::range_t (0, 5), styled_string (sm, ""foo""), style::id_plain);
  r.add_label (canvas::range_t (10, 15), styled_string (sm, ""bar""), style::id_plain);
  
  // Assert the rendered output in ASCII theme for labels with gaps.
  ASSERT_X_RULER_STREQ
    (r, ascii_theme (), sm, true,
     (""|~+~|     |~+~|\n""
      ""  |         |\n""
      "" foo       bar\n""));
}","Purpose: This tests for labels with gaps between them.
Details: Two labels with a gap between them are added, ensuring the correct spacing is respected.
"
"// Test for styled labels with different styles applied.
static void
test_styled ()
{
  style_manager sm;
  style s1, s2;
  
  // Set styles for two labels.
  s1.m_bold = true;
  s1.m_fg_color = style::named_color::YELLOW;
  s2.m_bold = true;
  s2.m_fg_color = style::named_color::BLUE;
  
  // Get style IDs from the style manager.
  style::id_t sid1 = sm.get_or_create_id (s1);
  style::id_t sid2 = sm.get_or_create_id (s2);

  x_ruler r (x_ruler::label_dir::BELOW);
  
  // Add two labels with different styles.
  r.add_label (canvas::range_t (0, 5), styled_string (sm, ""foo""), sid1);
  r.add_label (canvas::range_t (10, 15), styled_string (sm, ""bar""), sid2);
  
  // Assert the rendered output with styled labels in ASCII theme.
  ASSERT_X_RULER_STREQ
    (r, ascii_theme (), sm, true,
     (""[00;01;33m[K|~+~|[00m[K     [00;01;34m[K|~+~|[00m[K\n""
      ""  [00;01;33m[K|[00m[K         [00;01;34m[K|[00m[K\n""
      "" foo       bar\n""));
}","Purpose: This tests how styled labels are rendered.
Details: Two labels are added, each with different styles (bold, colors), and the function asserts the correct rendering of these styles."
"static void
test_borders ()
{
  // Create a style manager object to manage styling for the labels
  style_manager sm;
  
  // Test case where labels are placed below the ruler
  {
    // Create an x_ruler with labels below the ruler
    x_ruler r (x_ruler::label_dir::BELOW);
    
    // Add the first label with a border (label 1)
    r.add_label (canvas::range_t (0, 5),
                 styled_string (sm, ""label 1""),
                 style::id_plain,
                 x_ruler::label_kind::TEXT_WITH_BORDER);
    
    // Add the second label without a border (label 2)
    r.add_label (canvas::range_t (10, 15),
                 styled_string (sm, ""label 2""),
                 style::id_plain);
    
    // Add the third label with a border (label 3)
    r.add_label (canvas::range_t (20, 25),
                 styled_string (sm, ""label 3""),
                 style::id_plain,
                 x_ruler::label_kind::TEXT_WITH_BORDER);
    
    // Assert that the ruler is rendered correctly with ASCII theme
    ASSERT_X_RULER_STREQ
      (r, ascii_theme (), sm, true,
       ""|~+~|     |~+~|     |~+~|\n""
       ""  |         |         |\n""
       ""  |      label 2  +---+---+\n""
       ""+-+-----+         |label 3|\n""
       ""|label 1|         +-------+\n""
       ""+-------+\n"");
    
    // Assert that the ruler is rendered correctly with Unicode theme
    ASSERT_X_RULER_STREQ
      (r, unicode_theme (), sm, true,
       ""├─┬─┤     ├─┬─┤     ├─┬─┤\n""
       ""  │         │         │\n""
       ""  │      label 2  ╭───┴───╮\n""
       ""╭─┴─────╮         │label 3│\n""
       ""│label 1│         ╰───────╯\n""
       ""╰───────╯\n"");
  }
  
  // Test case where labels are placed above the ruler
  {
    // Create an x_ruler with labels above the ruler
    x_ruler r (x_ruler::label_dir::ABOVE);
    
    // Add the first label with a border (label 1)
    r.add_label (canvas::range_t (0, 5),
                 styled_string (sm, ""label 1""),
                 style::id_plain,
                 x_ruler::label_kind::TEXT_WITH_BORDER);
    
    // Add the second label without a border (label 2)
    r.add_label (canvas::range_t (10, 15),
                 styled_string (sm, ""label 2""),
                 style::id_plain);
    
    // Add the third label with a border (label 3)
    r.add_label (canvas::range_t (20, 25),
                 styled_string (sm, ""label 3""),
                 style::id_plain,
                 x_ruler::label_kind::TEXT_WITH_BORDER);
    
    // Assert that the ruler is rendered correctly with ASCII theme
    ASSERT_X_RULER_STREQ
      (r, ascii_theme (), sm, true,
       ""+-------+\n""
       ""|label 1|         +-------+\n""
       ""+-+-----+         |label 3|\n""
       ""  |      label 2  +---+---+\n""
       ""  |         |         |\n""
       ""|~+~|     |~+~|     |~+~|\n"");
    
    // Assert that the ruler is rendered correctly with Unicode theme
    ASSERT_X_RULER_STREQ
      (r, unicode_theme (), sm, true,
       ""╭───────╮\n""
       ""│label 1│         ╭───────╮\n""
       ""╰─┬─────╯         │label 3│\n""
       ""  │      label 2  ╰───┬───╯\n""
       ""  │         │         │\n""
       ""├─┴─┤     ├─┴─┤     ├─┴─┤\n"");
  }
}
","Purpose:
This function tests the rendering of labels with and without borders above and below the ruler.

Details:

Two types of rulers are tested: one with labels placed below the ruler (x_ruler::label_dir::BELOW) and one with labels placed above the ruler (x_ruler::label_dir::ABOVE).
Labels with borders are rendered with a border style (x_ruler::label_kind::TEXT_WITH_BORDER), while others are plain text.
The ASSERT_X_RULER_STREQ assertions check that the rendered output for both ASCII and Unicode themes matches the expected output.
The rulers are tested to ensure borders are properly handled with both themes, displaying labels with and without borders and ensuring correct spacing between them."
"static void
test_emoji ()
{
  // Create a style manager to handle styling for the labels
  style_manager sm;

  // Create a styled string with a warning emoji followed by text
  styled_string s;
  s.append (styled_string (0x26A0, /* U+26A0 WARNING SIGN.  */
                           true)); // Append warning sign emoji
  s.append (styled_string (sm, ""  "")); // Add space between emoji and text
  s.append (styled_string (sm, ""this is a warning"")); // Add the text of the label

  // Create an x_ruler for displaying the label below the ruler
  x_ruler r (x_ruler::label_dir::BELOW);
  r.add_label (canvas::range_t (0, 5),
               std::move (s),
               style::id_plain,
               x_ruler::label_kind::TEXT_WITH_BORDER); // Add label with the emoji

  // Assert that the ruler is rendered correctly with ASCII theme
  ASSERT_X_RULER_STREQ
    (r, ascii_theme (), sm, true,
     ""|~+~|\n""
     ""  |\n""
     ""+-+------------------+\n""
     ""|⚠️  this is a warning|\n""
     ""+--------------------+\n"");
}","Purpose: Tests the handling and rendering of emoji characters in labels.
Details: It adds a warning sign emoji (⚠️) to a label and ensures it is displayed correctly on the ruler with proper alignment and spacing, both with ASCII and Unicode themes."
"void
text_art_ruler_cc_tests ()
{
  // Call each test function defined in this file to verify the correct behavior of the ruler
  test_single ();                        // Test single label
  test_single_above ();                  // Test single label above the ruler
  test_multiple_contiguous ();           // Test multiple contiguous labels
  test_multiple_contiguous_above ();     // Test multiple contiguous labels above the ruler
  test_multiple_contiguous_abutting_labels (); // Test multiple contiguous abutting labels
  test_multiple_contiguous_overlapping_labels (); // Test multiple overlapping labels
  test_abutting_left_border ();          // Test labels abutting the left border
  test_too_long_to_consolidate_vertically (); // Test labels too long to consolidate vertically
  test_abutting_neighbor ();             // Test labels abutting each other
  test_gaps ();                          // Test gaps between labels
  test_styled ();                        // Test styled labels
  test_borders ();                       // Test labels with borders
  test_emoji ();                         // Test labels with emoji
}","Purpose: Runs all the test cases in this file to verify the functionality of the ruler.
Details: This function acts as a test suite, calling each of the individual test functions to ensure that the x_ruler class behaves correctly under various scenarios, such as handling different label placements, styles, borders, and emoji characters."
"/* Run all tests, aborting if any fail.  */
void
selftest::text_art_tests ()
{
  // Run the various text art test functions to ensure that they all pass.
  text_art_style_cc_tests ();                 // Tests related to text art styling
  text_art_styled_string_cc_tests ();         // Tests related to styled strings
  text_art_box_drawing_cc_tests ();            // Tests related to box drawing
  text_art_canvas_cc_tests ();                // Tests related to the canvas functionality
  text_art_ruler_cc_tests ();                 // Tests related to the ruler functionality
  text_art_table_cc_tests ();                 // Tests related to table rendering
  text_art_widget_cc_tests ();                // Tests related to widgets
  text_art_tree_widget_cc_tests ();           // Tests related to tree widget rendering
}
","Purpose: This function runs all the self-tests related to the text art module. If any test fails, the function will abort.
Details: It calls several test functions that cover different aspects of text art, including styles, boxes, canvases, rulers, tables, and widgets."
"/* Implementation detail of ASSERT_CANVAS_STREQ.  
   This function compares the string representation of the canvas
   with an expected string, printing an error message if they do not match. */
void
selftest::assert_canvas_streq (const location &loc,
                               const text_art::canvas &canvas,
                               pretty_printer *pp,
                               const char *expected_str)
{
  // Print the canvas to the pretty printer object
  canvas.print_to_pp (pp);
  
  // If debugging, print the formatted text to stderr (for inspection)
  if (0)
    fprintf (stderr, ""%s\n"", pp_formatted_text (pp));

  // Assert that the formatted text generated from the canvas matches the expected string
  ASSERT_STREQ_AT (loc, pp_formatted_text (pp), expected_str);
}","Purpose: This function compares the actual output of rendering a canvas to the expected output string. It prints the canvas to a pretty_printer object and checks if the formatted string matches the expected_str.
Details: The function uses canvas.print_to_pp to render the canvas, and the formatted result is compared to the expected_str using ASSERT_STREQ_AT, which reports an error if they don’t match."
"/* Implementation detail of ASSERT_CANVAS_STREQ.
   This variant handles styled printing and then compares the output string
   to the expected result. */
void
selftest::assert_canvas_streq (const location &loc,
                               const text_art::canvas &canvas,
                               bool styled,
                               const char *expected_str)
{
  pretty_printer pp;

  // If styled output is requested, enable color formatting
  if (styled)
    {
      pp_show_color (&pp) = true;             // Enable color in the pretty printer
      pp.set_url_format (URL_FORMAT_DEFAULT); // Set default URL format for pretty printing
    }

  // Call the other version of assert_canvas_streq to perform the comparison
  assert_canvas_streq (loc, canvas, &pp, expected_str);
}","Purpose: This function is similar to the previous one but adds support for styled rendering. If styled is true, it enables color formatting and URL formatting for the pretty printer before performing the comparison.
Details: It sets up the pretty_printer to support color and then calls the first assert_canvas_streq function to compare the formatted result with the expected string."
"/* 
 * Handles incoming characters (`ch`) and processes them based on the current state.
 * It manages the parsing of escape sequences, control sequences, and other characters.
 * The function also processes combining characters and emoji variants.
 */
void on_char(cppchar_t ch)
{
    switch (m_state)
    {
    default:
        gcc_unreachable();  // Should not reach this point.
    case state::START:
        if (ch == '\033')
        {
            /* Start of an escape sequence. */
            m_state = state::AFTER_ESC;
            return;
        }
        break;
    case state::AFTER_ESC:
        if (ch == '[')
        {
            /* ESC [ is a Control Sequence Introducer (CSI). */
            m_state = state::CS_PARAMETER_BYTES;
            return;
        }
        else if (ch == ']')
        {
            /* ESC ] is an Operating System Command (OSC). */
            m_state = state::WITHIN_OSC;
            return;
        }
        break;
    case state::CS_PARAMETER_BYTES:
        if (parameter_byte_p(ch))
        {
            /* Add parameter byte to the list. */
            m_parameter_bytes.push_back((char)ch);
            return;
        }
        else if (intermediate_byte_p(ch))
        {
            /* Intermediate byte detected. Switch to CS_INTERMEDIATE_BYTES state. */
            m_intermediate_bytes.push_back((char)ch);
            m_state = state::CS_INTERMEDIATE_BYTES;
            return;
        }
        else if (final_byte_p(ch))
        {
            /* Handle final byte in Control Sequence. */
            on_final_csi_char(ch);
            return;
        }
        break;
    case state::CS_INTERMEDIATE_BYTES:
        /* Handle intermediate bytes, which can be zero or more. */
        if (intermediate_byte_p(ch))
        {
            m_intermediate_bytes.push_back((char)ch);
            return;
        }
        else if (final_byte_p(ch))
        {
            on_final_csi_char(ch);
            return;
        }
        break;
    case state::WITHIN_OSC:
        /* Collect characters for OSC until ST (ESC \) or BEL (BEL character). */
        if (ch == '\\' && m_osc_string.size() > 0 && m_osc_string.back() == '\033')
        {
            /* ESC \ marks the end of an OSC. */
            m_osc_string.pop_back();
            on_final_osc_char();
            return;
        }
        else if (ch == '\a')
        {
            /* BEL (Bell) character terminates the OSC. */
            on_final_osc_char();
            return;
        }
        m_osc_string.push_back(ch);
        return;
    }

    /* Handle the VARIATION SELECTOR-16 character for emoji variant selection. */
    if (ch == 0xFE0F)
    {
        if (m_out.size() > 0)
            m_out.back().set_emoji_variant();
        return;
    }

    /* Handle combining characters. */
    if (cpp_is_combining_char(ch))
    {
        if (m_out.size() > 0)
        {
            m_out.back().add_combining_char(ch);
            return;
        }
    }

    /* By default, add the character to the output list. */
    m_out.push_back(styled_unichar(ch, false, m_cur_style_id));
}
","This function processes a character (ch) by transitioning through various states of a state machine. The states represent different stages of handling an escape sequence, control sequences (e.g., CSI), and operating system commands (OSC). It also manages special characters like variation selectors for emojis and combining characters. Based on the current state, the function accumulates parameter bytes or intermediate bytes, or it processes escape sequences when finalized."
"/* 
 * Handles the final character of a Control Sequence Introducer (CSI).
 * Processes recognized control sequences such as SGR (Select Graphic Rendition) for text styling.
 */
void on_final_csi_char(cppchar_t ch)
{
    switch (ch)
    {
    default:
        /* Unrecognized CSI character. */
        break;
    case 'm':
        {
            /* SGR control sequence (Select Graphic Rendition) for text style. */
            if (m_parameter_bytes.empty())
                reset_style();  // Reset to default style if no parameters are provided.
            std::vector<int> params(params_from_decimal());
            for (auto iter = params.begin(); iter != params.end();)
            {
                const int param = *iter;
                switch (param)
                {
                default:
                    /* Unrecognized SGR parameter. */
                    break;
                case 0:
                    reset_style();  // Reset the style.
                    break;
                case 1:
                    set_style_bold();  // Set the text to bold.
                    break;
                case 4:
                    set_style_underscore();  // Set the text to underlined.
                    break;
                case 5:
                    set_style_blink();  // Set the text to blinking.
                    break;

                /* Named foreground colors. */
                case 30:
                    set_style_fg_color(style::named_color::BLACK);
                    break;
                case 31:
                    set_style_fg_color(style::named_color::RED);
                    break;
                case 32:
                    set_style_fg_color(style::named_color::GREEN);
                    break;
                case 33:
                    set_style_fg_color(style::named_color::YELLOW);
                    break;
                case 34:
                    set_style_fg_color(style::named_color::BLUE);
                    break;
                case 35:
                    set_style_fg_color(style::named_color::MAGENTA);
                    break;
                case 36:
                    set_style_fg_color(style::named_color::CYAN);
                    break;
                case 37:
                    set_style_fg_color(style::named_color::WHITE);
                    break;

                /* 8-bit and 24-bit colors. */
                case 38:
                case 48:
                {
                    const bool fg = (param == 38);
                    iter++;
                    if (iter != params.end())
                        switch (*(iter++))
                        {
                        default:
                            break;
                        case 5:
                            /* 8-bit color. */
                            if (iter != params.end())
                            {
                                const uint8_t col = *(iter++);
                                if (fg)
                                    set_style_fg_color(style::color(col));
                                else
                                    set_style_bg_color(style::color(col));
                            }
                            continue;
                        case 2:
                            /* 24-bit color. */
                            if (iter != params.end())
                            {
                                const uint8_t r = *(iter++);
                                if (iter != params.end())
                                {
                                    const uint8_t g = *(iter++);
                                    if (iter != params.end())
                                    {
                                        const uint8_t b = *(iter++);
                                        if (fg)
                                            set_style_fg_color(style::color(r, g, b));
                                        else
                                            set_style_bg_color(style::color(r, g, b));
                                    }
                                }
                            }
                            continue;
                        }
                    continue;
                }
                break;

                /* Named background colors. */
                case 40:
                    set_style_bg_color(style::named_color::BLACK);
                    break;
                case 41:
                    set_style_bg_color(style::named_color::RED);
                    break;
                case 42:
                    set_style_bg_color(style::named_color::GREEN);
                    break;
                case 43:
                    set_style_bg_color(style::named_color::YELLOW);
                    break;
                case 44:
                    set_style_bg_color(style::named_color::BLUE);
                    break;
                case 45:
                    set_style_bg_color(style::named_color::MAGENTA);
                    break;
                case 46:
                    set_style_bg_color(style::named_color::CYAN);
                    break;
                case 47:
                    set_style_bg_color(style::named_color::WHITE);
                    break;
                }
                ++iter;
            }
        }
        break;
    }
    m_parameter_bytes.clear();  // Clear parameter bytes.
    m_intermediate_bytes.clear();  // Clear intermediate bytes.
    m_state = state::START;  // Reset state back to the initial state.
}
","This function processes the final character of a CSI (Control Sequence Introducer) sequence. It specifically handles the ""m"" character, which is part of the SGR (Select Graphic Rendition) sequence, used for modifying text styles. The function recognizes various styling parameters like bold, underscore, blink, and color settings (both foreground and background). It updates the text styling accordingly based on the recognized parameters and resets the style when necessary."
"void on_final_osc_char ()
{
    if (!m_osc_string.empty ())
    {
        switch (m_osc_string[0])
        {
        default:
            break;
        case '8':
            // Hyperlink support; handles URLs within OSC (Operating System Command) sequences.
            // This supports two cases:
            // (a) ""8;;URL"" to begin a URL (see pp_begin_url).
            // (b) ""8;;"" to end a URL (see pp_end_url).
            if (m_osc_string.size () >= 3 && m_osc_string[1] == ';' && m_osc_string[2] == ';')
            {
                set_style_url(m_osc_string.begin() + 3, m_osc_string.end());
            }
            break;
        }
    }
    m_osc_string.clear ();  // Reset OSC string after processing.
    m_state = state::START;  // Reset the state back to START.
}
","This function processes the final character of an Operating System Command (OSC) sequence. If the OSC string represents a hyperlink (i.e., ""8;;URL""), it calls set_style_url to apply the URL style. It resets the OSC string and the state to START once the sequence is processed."
"std::vector<int> params_from_decimal () const
{
    std::vector<int> result;
    int curr_int = -1;
    
    // Iterate through the parameter bytes and convert them to integers.
    for (auto param_ch : m_parameter_bytes)
    {
        if (param_ch >= '0' && param_ch <= '9')  // Check if character is a digit.
        {
            if (curr_int == -1)
                curr_int = 0;  // Start a new integer.
            else
                curr_int *= 10;  // Update the current integer value.
            curr_int += param_ch - '0';  // Add the digit to the current integer.
        }
        else
        {
            if (curr_int != -1)
            {
                result.push_back(curr_int);  // Add the integer to the result list.
                curr_int = -1;  // Reset for the next integer.
            }
        }
    }
    if (curr_int != -1)
        result.push_back(curr_int);  // Add the last integer to the result.
    return result;
}
","This function converts a sequence of parameter bytes (stored in m_parameter_bytes) from decimal ASCII representation into a vector of integers. It processes each character, accumulating digits into integers, and adds them to the result once the entire parameter is processed.
"
"void refresh_style_id ()
{
    m_cur_style_id = m_sm.get_or_create_id(m_cur_style_obj);  // Refresh the current style ID.
}
",This function updates the current style ID by calling get_or_create_id on the style_manager. It ensures that the m_cur_style_id matches the current style object (m_cur_style_obj).
"void reset_style ()
{
    m_cur_style_obj = style ();  // Reset the current style object to its default state.
    refresh_style_id ();  // Refresh the style ID after resetting the style.
}
",This function resets the current style object (m_cur_style_obj) to its default state and then calls refresh_style_id to update the style ID accordingly.
"void set_style_bold ()
{
    m_cur_style_obj.m_bold = true;  // Set the bold flag on the current style object.
    refresh_style_id ();  // Refresh the style ID after modifying the style.
}
",This function sets the bold property of the current style object to true and updates the style ID to reflect the change.
"void set_style_underscore ()
{
    m_cur_style_obj.m_underscore = true;  // Set the underscore flag on the current style object.
    refresh_style_id ();  // Refresh the style ID after modifying the style.
}
",This function sets the underscore property of the current style object to true and updates the style ID accordingly.
"void set_style_blink ()
{
    m_cur_style_obj.m_blink = true;  // Set the blink flag on the current style object.
    refresh_style_id ();  // Refresh the style ID after modifying the style.
}
",This function sets the blink property of the current style object to true and updates the style ID to reflect the change.
"void set_style_fg_color (style::color color)
{
    m_cur_style_obj.m_fg_color = color;  // Set the foreground color of the current style object.
    refresh_style_id ();  // Refresh the style ID after modifying the style.
}
",This function sets the foreground color of the current style object to the specified color and updates the style ID accordingly.
"void set_style_bg_color (style::color color)
{
    m_cur_style_obj.m_bg_color = color;  // Set the background color of the current style object.
    refresh_style_id ();  // Refresh the style ID after modifying the style.
}
",This function sets the background color of the current style object to the specified color and updates the style ID accordingly.
"void set_style_url (std::vector<cppchar_t>::iterator begin,
                    std::vector<cppchar_t>::iterator end)
{
    // Set the URL for the current style object.
    // The empty string means ""no URL"".
    m_cur_style_obj.m_url = std::vector<cppchar_t>(begin, end);
    refresh_style_id ();  // Refresh the style ID after setting the URL.
}
","This function sets the URL for the current style object. The URL is defined by a range of characters from begin to end. After setting the URL, it updates the style ID."
"static bool parameter_byte_p (cppchar_t ch)
{
    return ch >= 0x30 && ch <= 0x3F;  // Check if the character is within the valid range for parameter bytes.
}
",This static function checks if a character ch is within the valid range for parameter bytes (ASCII values between 0x30 and 0x3F).
"static bool intermediate_byte_p (cppchar_t ch)
{
    return ch >= 0x20 && ch <= 0x2F;  // Check if the character is within the valid range for intermediate bytes.
}
",This static function checks if a character ch is within the valid range for intermediate bytes (ASCII values between 0x20 and 0x2F).
"static bool final_byte_p (cppchar_t ch)
{
    return ch >= 0x40 && ch <= 0x7E;  // Check if the character is within the valid range for final bytes.
}
",This static function checks if a character ch is within the valid range for final bytes (ASCII values between 0x40 and 0x7E).
"// Constructor that takes a style manager and a C-string (UTF-8)
styled_string::styled_string(style_manager &sm, const char *str)
: m_chars() 
{
  // Create an escape code parser to process escape sequences in the string
  escape_code_parser parser(sm, m_chars);

  // Policy for decoding UTF-8 characters with display width computation
  cpp_char_column_policy policy(8, cpp_wcwidth);
  cpp_display_width_computation dw(str, strlen(str), policy);

  // Loop through each codepoint in the string
  while (!dw.done()) 
  {
    cpp_decoded_char decoded_char;
    dw.process_next_codepoint(&decoded_char);

    // Skip invalid UTF-8 characters
    if (!decoded_char.m_valid_ch)
      continue;

    // Decode the character and process it with escape code parser
    cppchar_t ch = decoded_char.m_ch;
    parser.on_char(ch);
  }
}","styled_string(style_manager &sm, const char *str):

This constructor initializes a styled string by decoding the given UTF-8 string (str) and handling any escape sequences that modify the string's styling.
It uses cpp_display_width_computation to decode each character, ensuring it correctly handles the width of characters (e.g., handling multi-byte UTF-8 characters).
The escape_code_parser processes escape sequences like SGR (Select Graphic Rendition) for text styling."
"// Constructor that initializes a styled string with a single character and an optional emoji flag
styled_string::styled_string(cppchar_t cppchar, bool emoji)
{
  // Create a styled unichar (character with style information) and add it to m_chars
  m_chars.push_back(styled_unichar(cppchar, emoji, style::id_plain));
}
",This constructor initializes a styled string with a single character (cppchar) and indicates whether it's an emoji.
"// Static function to create a styled string from a formatted string with variable arguments
styled_string styled_string::from_fmt_va(style_manager &sm, printer_fn format_decoder, const char *fmt, va_list *args)
{
  // Create a text_info object that holds formatted text and arguments
  text_info text(fmt, args, errno);

  // Initialize a pretty_printer to handle formatting options
  pretty_printer pp;
  pp_show_color(&pp) = true;
  pp.set_url_format(URL_FORMAT_DEFAULT);
  pp_format_decoder(&pp) = format_decoder;

  // Apply formatting and store the result in the pretty_printer
  pp_format(&pp, &text);
  pp_output_formatted_text(&pp);

  // Return a styled_string created from the formatted text output
  styled_string result(sm, pp_formatted_text(&pp));
  return result;
}
","Creates a styled_string from a formatted string with variable arguments. This function allows for custom formatting via the format_decoder function, such as those used in printf-like operations."
"// Static function to create a styled string from a formatted string with variable arguments
styled_string styled_string::from_fmt(style_manager &sm, printer_fn format_decoder, const char *fmt, ...)
{
  va_list ap;
  va_start(ap, fmt);
  
  // Use from_fmt_va to create the styled_string with the variable arguments
  styled_string result = from_fmt_va(sm, format_decoder, fmt, &ap);
  
  va_end(ap);
  
  // Return the resulting styled_string
  return result;
}",Similar to from_fmt_va but accepts a variable number of arguments passed via the va_list mechanism. This function is a convenience wrapper for from_fmt_va.
"// Calculates the total canvas width of the styled string, considering character widths
int styled_string::calc_canvas_width() const
{
  int result = 0;

  // Loop through all characters and add up their canvas widths
  for (auto ch : m_chars)
    result += ch.get_canvas_width();

  return result;
}
","Computes the total canvas width of the styled string. It loops through all characters in m_chars, adding up their individual canvas widths, which may vary based on character size."
"// Appends another styled_string (suffix) to the current styled_string
void styled_string::append(const styled_string &suffix)
{
  // Insert characters from the suffix at the end of the current m_chars vector
  m_chars.insert<std::vector<styled_unichar>::const_iterator>(
    m_chars.end(), suffix.begin(), suffix.end());
}
",Appends another styled_string (the suffix) to the current styled_string. It adds the characters from the suffix to the end of the current string.
"// Sets a URL for each character in the styled string
void styled_string::set_url(style_manager &sm, const char *url)
{
  // Iterate through each character in m_chars
  for (auto &ch : m_chars)
  {
    // Get the existing style of the character
    const style &existing_style = sm.get_style(ch.get_style_id());

    // Create a new style based on the existing one and set the URL
    style with_url(existing_style);
    with_url.set_style_url(url);

    // Update the character's style ID with the new style
    ch.m_style_id = sm.get_or_create_id(with_url);
  }
}","Sets a URL for each character in the styled_string. The URL is added to the style of each character, and the style_manager is used to ensure the updated style is applied."
"static void test_combining_chars()
  {
    // Assert that some characters are or are not combining characters
    ASSERT_FALSE(cpp_is_combining_char(0));  // Not a combining character
    ASSERT_FALSE(cpp_is_combining_char('a'));  // Not a combining character
    ASSERT_TRUE(cpp_is_combining_char(0x0306));  // Combining Breve
    ASSERT_FALSE(cpp_is_combining_char(0x5B57));  // Not a combining character (CJK Ideograph)
    ASSERT_FALSE(cpp_is_combining_char(0xFE0F));  // Not a combining character (Variation Selector)
  }","Tests various characters to verify if they are combining characters (e.g., accents or diacritics) using the cpp_is_combining_char function."
"// Function to test an empty string
  static void test_empty()
  {
    style_manager sm;
    styled_string s(sm, """");

    // Assert that the styled string is empty
    ASSERT_EQ(s.size(), 0);
    ASSERT_EQ(s.calc_canvas_width(), 0);
  }",Verifies that an empty string is handled correctly by ensuring its size and canvas width are both zero.
"// Function to test a simple ASCII string with no escape codes
  static void test_simple()
  {
    const char *c_str = ""hello world!"";
    style_manager sm;
    styled_string s(sm, c_str);

    // Assert that the string has the correct size and canvas width
    ASSERT_EQ(s.size(), strlen(c_str));
    ASSERT_EQ(s.calc_canvas_width(), (int)strlen(c_str));

    // Check each character and ensure it has the correct code and style
    for (size_t i = 0; i < strlen(c_str); i++)
    {
      ASSERT_EQ(s[i].get_code(), (cppchar_t)c_str[i]);
      ASSERT_EQ(s[i].get_style_id(), 0);  // No style applied
    }
  }",Tests a simple ASCII string without escape sequences to ensure correct handling of characters and their associated styles. Each character's code and style ID are checked for correctness.
"static void
test_pi_from_utf8 ()
{
  /* U+03C0 ""GREEK SMALL LETTER PI"".  */
  const char * const pi_utf8 = ""\xCF\x80"";  // UTF-8 representation of the Greek letter Pi.

  style_manager sm;  // Create a style manager to manage text styles.
  styled_string s (sm, pi_utf8);  // Create a styled string using the Pi character.
  ASSERT_EQ (s.size (), 1);  // Ensure that the string has only 1 character.
  ASSERT_EQ (s.calc_canvas_width (), 1);  // The canvas width of a single character should be 1.
  ASSERT_EQ (s[0].get_code (), 0x03c0);  // Verify the character code for the Greek Pi (U+03C0).
  ASSERT_EQ (s[0].emoji_variant_p (), false);  // The Pi character is not an emoji variant.
  ASSERT_EQ (s[0].double_width_p (), false);  // Pi is not a double-width character.
  ASSERT_EQ (s[0].get_style_id (), 0);  // The style ID should be 0.
}
","This function tests the handling of a single character, the Greek small letter Pi (U+03C0), from its UTF-8 encoding. It checks properties like the string's size, canvas width, character code, and style properties."
"static void
test_emoji_from_utf8 ()
{
  /* U+1F642 ""SLIGHTLY SMILING FACE"".  */
  const char * const emoji_utf8 = ""\xF0\x9F\x99\x82"";  // UTF-8 encoding for the emoji.

  style_manager sm;  // Create a style manager to manage text styles.
  styled_string s (sm, emoji_utf8);  // Create a styled string using the emoji UTF-8.
  ASSERT_EQ (s.size (), 1);  // The emoji string should contain exactly 1 character.
  ASSERT_EQ (s.calc_canvas_width (), 2);  // The emoji is a double-width character.
  ASSERT_EQ (s[0].get_code (), 0x1f642);  // Verify the emoji code (U+1F642, Slightly Smiling Face).
  ASSERT_EQ (s[0].double_width_p (), true);  // Emojis are generally double-width characters.
  ASSERT_EQ (s[0].get_style_id (), 0);  // The style ID should be 0.
}
","This function tests the handling of the ""Slightly Smiling Face"" emoji (U+1F642). It ensures correct handling of its size, canvas width, and other style properties specific to emojis."
"static void
test_emoji_variant_from_utf8 ()
{
  const char * const emoji_utf8
    = (/* U+26A0 WARNING SIGN.  */
       ""\xE2\x9A\xA0""
       /* U+FE0F VARIATION SELECTOR-16 (emoji variation selector).  */
       ""\xEF\xB8\x8F"");

  style_manager sm;  // Create a style manager.
  styled_string s (sm, emoji_utf8);  // Create a styled string with the emoji and variation selector.
  ASSERT_EQ (s.size (), 1);  // The string should contain exactly 1 character.
  ASSERT_EQ (s.calc_canvas_width (), 1);  // The canvas width for this combined character should be 1.
  ASSERT_EQ (s[0].get_code (), 0x26a0);  // The code for the warning sign (U+26A0) should be the base character.
  ASSERT_EQ (s[0].emoji_variant_p (), true);  // Check if this is an emoji variant.
  ASSERT_EQ (s[0].double_width_p (), false);  // The warning sign is not double-width.
  ASSERT_EQ (s[0].get_style_id (), 0);  // The style ID should be 0.
}
","This function tests the handling of an emoji variant. Specifically, it checks a warning sign (U+26A0) with a variation selector (U+FE0F), ensuring that the emoji variant is correctly processed."
"static void
test_emoji_from_codepoint ()
{
  styled_string s ((cppchar_t)0x1f642);  // Create a styled string from a codepoint (U+1F642).
  ASSERT_EQ (s.size (), 1);  // The string should contain exactly 1 character.
  ASSERT_EQ (s.calc_canvas_width (), 2);  // Emojis are double-width.
  ASSERT_EQ (s[0].get_code (), 0x1f642);  // The character code should be U+1F642 (Slightly Smiling Face).
  ASSERT_EQ (s[0].double_width_p (), true);  // Confirm that this is a double-width character.
  ASSERT_EQ (s[0].get_style_id (), 0);  // The style ID should be 0.
}
","This function tests the creation of a styled string from a codepoint. It ensures the string is properly initialized with the Slightly Smiling Face emoji (U+1F642), and verifies its size, canvas width, and other properties."
"static void
test_from_mixed_width_utf8 ()
{
  /* This UTF-8 string literal contains characters with varying byte widths. */
  const char * const mixed_width_utf8
    = (""before ""
       ""\346\226\207""  // U+6587
       ""\345\255\227""  // U+5B57
       ""\345\214\226""  // U+5316
       ""\343\201\221""  // U+3051
       "" after"");

  style_manager sm;  // Create a style manager.
  styled_string s (sm, mixed_width_utf8);  // Create a styled string with mixed-width UTF-8 characters.
  ASSERT_EQ (s.size (), 6 + 1 + 4 + 1 + 5);  // Total characters count.
  ASSERT_EQ (s.calc_canvas_width (), 6 + 1 + (2 * 4) + 1 + 5);  // Correct canvas width accounting for double-width characters.

  // Verify individual character codes and their respective width properties.
  ASSERT_EQ (s[7].get_code (), 0x6587);  // Verify the first CJK character.
  ASSERT_EQ (s[7].double_width_p (), true);  // Ensure it's double-width.
  ASSERT_EQ (s[8].get_code (), 0x5B57);  // Verify the second CJK character.
  ASSERT_EQ (s[9].get_code (), 0x5316);  // Verify the third CJK character.
  ASSERT_EQ (s[10].get_code (), 0x3051);  // Verify the fourth CJK character.
}
","This function tests a string with mixed-width UTF-8 characters. It includes both single-byte characters (""before"" and ""after"") and multi-byte characters (CJK ideographs). The function verifies that the canvas width is correctly calculated and checks whether the CJK characters are correctly treated as double-width."
"static void
assert_style_urleq (const location &loc,
                    const style &s,
                    const char *expected_str)
{
  ASSERT_EQ_AT (loc, s.m_url.size (), strlen (expected_str));  // Check if the URL size matches the expected string.
  for (size_t i = 0; i < s.m_url.size (); i++)
    ASSERT_EQ_AT (loc, s.m_url[i], (cppchar_t)expected_str[i]);  // Compare each character of the URL.
}
",This helper function checks if the URL stored in a style matches the expected string. It compares the size and individual characters of the URL to ensure they are correct.
"static void
test_url ()
{
  // Test URL_FORMAT_ST
  {
    style_manager sm;
    styled_string s
      (sm, ""\33]8;;http://example.com\33\\This is a link\33]8;;\33\\"");
    const char *expected = ""This is a link"";
    ASSERT_EQ (s.size (), strlen (expected));  // Ensure the link text matches.
    ASSERT_EQ (s.calc_canvas_width (), (int)strlen (expected));  // Canvas width matches text length.
    ASSERT_EQ (sm.get_num_styles (), 2);  // There should be two styles: one for the URL and one for the text.
    for (size_t i = 0; i < strlen (expected); i++)
      {
        ASSERT_EQ (s[i].get_code (), (cppchar_t)expected[i]);
        ASSERT_EQ (s[i].get_style_id (), 1);  // The link style ID should be 1.
      }
    ASSERT_STYLE_URLEQ (sm.get_style (1), ""http://example.com"");  // Verify the URL matches the expected string.
  }

  // Test URL_FORMAT_BOLD
  {
    style_manager sm;
    styled_string s
      (sm, ""\33]8;;http://example.com\33\\\33[1mThis is bold\33[0m\33]8;;\33\\"");
    const char *expected = ""This is bold"";
    ASSERT_EQ (s.size (), strlen (expected));  // Ensure the bold text matches.
    ASSERT_EQ (s.calc_canvas_width (), (int)strlen (expected));  // Canvas width matches text length.
    ASSERT_EQ (sm.get_num_styles (), 2);  // There should be two styles: one for the URL and one for the text.
    for (size_t i = 0; i < strlen (expected); i++)
      {
        ASSERT_EQ (s[i].get_code (), (cppchar_t)expected[i]);
        ASSERT_EQ (s[i].get_style_id (), 1);  // The bold style ID should be 1.
      }
    ASSERT_STYLE_URLEQ (sm.get_style (1), ""http://example.com"");  // Verify the URL matches the expected string.
  }
}
","This function tests the handling of URLs in a styled string. It checks two cases: one where the URL is used as plain text and another where the URL text is styled as bold. It verifies the correct size, canvas width, and style IDs."
"// Test for correctly formatting a string with smart quotes around it using %qs.
static void test_from_fmt_qs() {
    auto_fix_quotes fix_quotes;  // Ensures that the quotes are fixed correctly.
    open_quote = ""\xe2\x80\x98""; // Left single quotation mark (Unicode U+2018)
    close_quote = ""\xe2\x80\x99""; // Right single quotation mark (Unicode U+2019)

    style_manager sm;  // Manager for tracking the styles.
    styled_string s(styled_string::from_fmt(sm, NULL, ""%qs"", ""msg""));  // Format the string with quotes around it.
    
    // Assertions to ensure that the smart quotes are applied correctly and that the rest of the string is properly styled.
    ASSERT_EQ(sm.get_num_styles(), 2);  // Check if two styles (quote and regular text) are applied.
    ASSERT_EQ(s[0].get_code(), 0x2018);  // Left quote character (Unicode U+2018).
    ASSERT_EQ(s[0].get_style_id(), 0);  // Style ID for the quote.
    ASSERT_EQ(s[1].get_code(), 'm');  // First character of the word.
    ASSERT_EQ(s[1].get_style_id(), 1);  // Style ID for the regular text.
    ASSERT_EQ(s[2].get_code(), 's');
    ASSERT_EQ(s[2].get_style_id(), 1);
    ASSERT_EQ(s[3].get_code(), 'g');
    ASSERT_EQ(s[3].get_style_id(), 1);
    ASSERT_EQ(s[4].get_code(), 0x2019);  // Right quote character (Unicode U+2019).
    ASSERT_EQ(s[4].get_style_id(), 0);  // Style ID for the quote.
    ASSERT_EQ(s.size(), 5);  // Verify that the total size is 5 characters.
}
","Description: This test verifies the proper formatting of a string with smart quotes. It ensures that the correct quote characters (‘ and ’) are applied around the string msg and that the rest of the string is properly styled.
Test Steps:
It initializes a styled string with the format %qs and checks if the quote styles are correctly applied.
The test ensures the styled string has the right size and correct code points and style IDs for each character."
"// Test for parsing SGR codes and bold formatting.
static void test_from_str_with_bold() {
    style_manager sm;  // Manager for tracking styles.
    styled_string s(sm, ""`\33[01m\33[Kfoo\33[m\33[K'"");  // String with bold formatting.

    // Assertions to verify the characters are correctly styled.
    ASSERT_EQ(s[0].get_code(), '`');
    ASSERT_EQ(s[0].get_style_id(), 0);
    ASSERT_EQ(s[1].get_code(), 'f');
    ASSERT_EQ(s[1].get_style_id(), 1);  // Bold style.
    ASSERT_EQ(s[2].get_code(), 'o');
    ASSERT_EQ(s[2].get_style_id(), 1);
    ASSERT_EQ(s[3].get_code(), 'o');
    ASSERT_EQ(s[3].get_style_id(), 1);
    ASSERT_EQ(s[4].get_code(), '\'');
    ASSERT_EQ(s[4].get_style_id(), 0);
    ASSERT_EQ(s.size(), 5);  // Total number of characters.
    ASSERT_TRUE(sm.get_style(1).m_bold);  // Verify that the bold style is set.
}
","Description: This test checks the parsing of SGR (Select Graphic Rendition) codes for bold text. The styled string has a sequence where the foo text is bolded using the SGR code for bold (\33[01m).
Test Steps:
The string is parsed and the individual characters are checked to ensure the bold style is correctly applied to the text.
It verifies that the style ID for the bold text is correct and that the style has the bold property set."
"// Test for parsing underscore formatting (SGR code 04).
static void test_from_str_with_underscore() {
    style_manager sm;
    styled_string s(sm, ""\33[04m\33[KA"");  // String with underscore formatting.

    ASSERT_EQ(s[0].get_code(), 'A');  // Check character.
    ASSERT_EQ(s[0].get_style_id(), 1);  // Check if style ID matches.
    ASSERT_TRUE(sm.get_style(1).m_underscore);  // Verify that the underscore style is set.
}","Description: This test checks the parsing of text with an underscore style applied via the SGR code (\33[04m).
Test Steps:
It parses the string with the underscore style and verifies that the character 'A' has the correct style and the underscore property set."
"// Test for parsing blink formatting (SGR code 05).
static void test_from_str_with_blink() {
    style_manager sm;
    styled_string s(sm, ""\33[05m\33[KA"");  // String with blink formatting.

    ASSERT_EQ(s[0].get_code(), 'A');
    ASSERT_EQ(s[0].get_style_id(), 1);
    ASSERT_TRUE(sm.get_style(1).m_blink);  // Verify that the blink style is set.
}","Description: This test checks the parsing of text with a blink style applied (\33[05m).
Test Steps:
Similar to the other tests, it checks if the blink style is correctly applied to the character 'A' and verifies that the blink property is set in the style.
"
"// Test for parsing foreground colors.
static void test_from_str_with_color() {
    style_manager sm;
    
    // String with red and green foreground color applied.
    styled_string s(sm,
                    (""0""
                     SGR_SEQ(COLOR_FG_RED)
                     ""R""
                     SGR_RESET
                     ""2""
                     SGR_SEQ(COLOR_FG_GREEN)
                     ""G""
                     SGR_RESET
                     ""4""));
    
    // Verify string size and character styles.
    ASSERT_EQ(s.size(), 5);
    ASSERT_EQ(sm.get_num_styles(), 3);  // Three styles (default, red, green).
    ASSERT_EQ(s[0].get_code(), '0');
    ASSERT_EQ(s[0].get_style_id(), 0);  // Default style.
    ASSERT_EQ(s[1].get_code(), 'R');
    ASSERT_EQ(s[1].get_style_id(), 1);  // Red color.
    ASSERT_EQ(s[2].get_code(), '2');
    ASSERT_EQ(s[2].get_style_id(), 0);  // Default style.
    ASSERT_EQ(s[3].get_code(), 'G');
    ASSERT_EQ(s[3].get_style_id(), 2);  // Green color.
    ASSERT_EQ(s[4].get_code(), '4');
    ASSERT_EQ(s[4].get_style_id(), 0);  // Default style.
    ASSERT_EQ(sm.get_style(1).m_fg_color, style::named_color::RED);  // Red foreground color.
    ASSERT_EQ(sm.get_style(2).m_fg_color, style::named_color::GREEN);  // Green foreground color.
}
","Description: This test verifies the correct application of foreground colors (RED, GREEN) through SGR sequences (\33[38;5;m).
Test Steps:
The string is parsed and the colors for each character are checked.
The test ensures that the appropriate color codes (RED, GREEN) are applied correctly to the styled string."
"// Test for parsing named foreground and background colors.
static void test_from_str_with_named_color() {
    style_manager sm;
    
    // String with different named foreground and background colors applied.
    styled_string s(sm,
                    (""F""
                     SGR_SEQ(COLOR_FG_BLACK) ""F""
                     SGR_SEQ(COLOR_FG_RED) ""F""
                     SGR_SEQ(COLOR_FG_GREEN) ""F""
                     SGR_SEQ(COLOR_FG_YELLOW) ""F""
                     SGR_SEQ(COLOR_FG_BLUE) ""F""
                     SGR_SEQ(COLOR_FG_MAGENTA) ""F""
                     SGR_SEQ(COLOR_FG_CYAN) ""F""
                     SGR_SEQ(COLOR_FG_WHITE) ""F""
                     SGR_SEQ(COLOR_FG_BRIGHT_BLACK) ""F""
                     SGR_SEQ(COLOR_FG_BRIGHT_RED) ""F""
                     SGR_SEQ(COLOR_FG_BRIGHT_GREEN) ""F""
                     SGR_SEQ(COLOR_FG_BRIGHT_YELLOW) ""F""
                     SGR_SEQ(COLOR_FG_BRIGHT_BLUE) ""F""
                     SGR_SEQ(COLOR_FG_BRIGHT_MAGENTA) ""F""
                     SGR_SEQ(COLOR_FG_BRIGHT_CYAN) ""F""
                     SGR_SEQ(COLOR_FG_BRIGHT_WHITE) ""F""
                     SGR_SEQ(COLOR_BG_BLACK) ""B""
                     SGR_SEQ(COLOR_BG_RED) ""B""
                     SGR_SEQ(COLOR_BG_GREEN) ""B""
                     SGR_SEQ(COLOR_BG_YELLOW) ""B""
                     SGR_SEQ(COLOR_BG_BLUE) ""B""
                     SGR_SEQ(COLOR_BG_MAGENTA) ""B""
                     SGR_SEQ(COLOR_BG_CYAN) ""B""
                     SGR_SEQ(COLOR_BG_WHITE) ""B""
                     SGR_SEQ(COLOR_BG_BRIGHT_BLACK) ""B""
                     SGR_SEQ(COLOR_BG_BRIGHT_RED) ""B""
                     SGR_SEQ(COLOR_BG_BRIGHT_GREEN) ""B""
                     SGR_SEQ(COLOR_BG_BRIGHT_YELLOW) ""B""
                     SGR_SEQ(COLOR_BG_BRIGHT_BLUE) ""B""
                     SGR_SEQ(COLOR_BG_BRIGHT_MAGENTA) ""B""
                     SGR_SEQ(COLOR_BG_BRIGHT_CYAN) ""B""
                     SGR_SEQ(COLOR_BG_BRIGHT_WHITE) ""B""));

    // Verify the total number of characters and styles applied.
    ASSERT_EQ(s.size(), 33);
    for (size_t i = 0; i < s.size(); i++)
        ASSERT_EQ(s[i].get_style_id(), i);  // Each character should have a unique style ID.
    for (size_t i = 0; i < 17; i++)
        ASSERT_EQ(s[i].get_code(), 'F');  // First 17 are foreground 'F' with colors.
    for (size_t i = 17; i < 33; i++)
        ASSERT_EQ(s[i].get_code(), 'B');  // Last 16 are background 'B' with colors.
}","Description: This test checks the parsing of various named foreground and background colors, such as BLACK, RED, GREEN, etc.
Test Steps:
It parses a string that includes multiple color codes for both foreground and background colors.
The test ensures that each character has the correct color style ID and color assigned."
"// Test for parsing 8-bit colors (foreground and background).
static void test_from_str_with_8_bit_color() {
    // Test 8-bit foreground color.
    style_manager sm;
    styled_string s(sm, ""[38;5;232m[KF"");  // Foreground color 232.

    ASSERT_EQ(s.size(), 1);
    ASSERT_EQ(s[0].get_code(), 'F');
    ASSERT_EQ(s[0].get_style_id(), 1);  // Style ID for 8-bit color.
    ASSERT_EQ(sm.get_style(1).m_fg_color, style::color(232));  // Verify 8-bit color value.

    // Test 8-bit background color.
    styled_string s_bg(sm, ""[48;5;231m[KB"");  // Background color 231.

    ASSERT_EQ(s_bg.size(), 1);
    ASSERT_EQ(s_bg[0].get_code(), 'B');
    ASSERT_EQ(s_bg[0].get_style_id(), 1);  // Style ID for 8-bit color.
    ASSERT_EQ(sm.get_style(1).m_bg_color, style::color(231));  // Verify 8-bit color value.
}
","Description: This test checks the parsing of 8-bit colors using the \33[38;5;XXm and \33[48;5;XXm sequences for foreground and background colors.
Test Steps:
It checks that the 8-bit color codes are correctly assigned to the styled string and that the colors match the expected values (e.g., 232 for foreground)."
"// Test for parsing 24-bit colors (RGB).
static void test_from_str_with_24_bit_color() {
    style_manager sm;
    styled_string s(sm, ""\33[38;2;255;0;0m\33[KA"");  // 24-bit red color.

    ASSERT_EQ(s[0].get_code(), 'A');
    ASSERT_EQ(s[0].get_style_id(), 1);  // Style ID for 24-bit color.
    ASSERT_EQ(sm.get_style(1).m_fg_color, style::color(255, 0, 0));  // Verify red color (RGB).

    styled_string s_bg(sm, ""\33[48;2;0;255;0m\33[KB"");  // 24-bit green background color.

    ASSERT_EQ(s_bg[0].get_code(), 'B');
    ASSERT_EQ(s_bg[0].get_style_id(), 1);  // Style ID for 24-bit background color.
    ASSERT_EQ(sm.get_style(1).m_bg_color, style::color(0, 255, 0));  // Verify green color (RGB).
}","Description: This test ensures that 24-bit colors (RGB colors) are parsed correctly, checking the SGR sequences for setting foreground and background colors with 24-bit RGB values.
Test Steps:
The test checks that the correct 24-bit RGB color values are applied to the string's characters."
"// Test for handling combining characters (e.g., accent marks).
static void test_from_str_combining_characters() {
    style_manager sm;
    styled_string s(sm, ""Ф\u0306"");  // Cyrillic character with a combining breve (Unicode U+0306).

    ASSERT_EQ(s[0].get_code(), 'Ф');
    ASSERT_EQ(s[1].get_code(), '\u0306');  // Combining character.
    ASSERT_EQ(s[0].get_style_id(), 0);  // Default style for the base character.
    ASSERT_EQ(s[1].get_style_id(), 0);  // Default style for the combining character.
}","Description: This test verifies the handling of combining characters in Unicode. It checks that a combining character (like a breve) can be correctly applied to a base character (like a Cyrillic letter).
Test Steps:
It checks that the combining character is attached correctly to the base character in the styled string."
"// Constructor for table_cell_content that initializes the string and its size.
table_cell_content::table_cell_content (styled_string &&s)
: m_str (std::move (s)),  // Move the passed styled_string to m_str.
  /* We assume here that the content occupies a single canvas row. */
  m_size (m_str.calc_canvas_width (), 1)  // Calculate the width of the string and set height to 1.
{
}",Initializes a table cell's content using a styled string and calculates its canvas size. The content is assumed to fit in a single row of the canvas.
"// Paints the content of the table cell to the canvas at the specified position.
void
table_cell_content::paint_to_canvas (canvas &canvas,
                                     canvas::coord_t top_left) const
{
  // Paint the styled string onto the canvas at the given coordinates.
  canvas.paint_text (top_left, m_str);
}",Paints the content of the table cell onto a canvas at the specified top-left position.
"// Paints the contents of a table cell to the canvas with the appropriate alignment and padding.
void
table::cell_placement::paint_cell_contents_to_canvas(canvas &canvas,
                                                     canvas::coord_t offset,
                                                     const table_geometry &tg) const
{
  const canvas::size_t req_canvas_size = get_min_canvas_size ();  // Get the required canvas size.
  const canvas::size_t alloc_canvas_size = tg.get_canvas_size (m_rect);  // Get the allocated canvas size for the cell.
  
  // Ensure the required size fits within the allocated size.
  gcc_assert (req_canvas_size.w <= alloc_canvas_size.w);
  gcc_assert (req_canvas_size.h <= alloc_canvas_size.h);

  // Calculate the horizontal and vertical padding.
  const int x_padding = alloc_canvas_size.w - req_canvas_size.w;
  const int y_padding = alloc_canvas_size.h - req_canvas_size.h;

  const table::coord_t table_top_left = m_rect.m_top_left;  // Get the top-left coordinates of the table.
  const canvas::coord_t canvas_top_left = tg.table_to_canvas (table_top_left);  // Convert table coordinates to canvas coordinates.

  // Ensure padding is non-negative and compute the alignment offsets.
  gcc_assert (x_padding >= 0);
  int x_align_offset;
  switch (m_x_align)
    {
    default:
      gcc_unreachable ();
    case x_align::LEFT:
      x_align_offset = 0;
      break;
    case x_align::CENTER:
      x_align_offset = x_padding / 2;
      break;
    case x_align::RIGHT:
      x_align_offset = x_padding;
      break;
    }

  gcc_assert (y_padding >= 0);
  int y_align_offset;
  switch (m_y_align)
    {
    default:
      gcc_unreachable ();
    case y_align::TOP:
      y_align_offset = 0;
      break;
    case y_align::CENTER:
      y_align_offset = y_padding / 2;
      break;
    case y_align::BOTTOM:
      y_align_offset = y_padding;
      break;
    }

  // Compute the relative coordinates for the content and paint it to the canvas.
  const canvas::coord_t content_rel_coord
    (canvas_top_left.x + 1 + x_align_offset,
     canvas_top_left.y + 1 + y_align_offset);
  m_content.paint_to_canvas (canvas, offset + content_rel_coord);
}","Paints the content of a specific table cell onto the canvas, accounting for alignment and padding based on the cell’s allocated size."
"// Constructor for table that initializes the table's size, placements, and occupancy.
table::table (size_t size)
: m_size (size),  // Set the size of the table.
  m_placements (),  // Initialize the placements list as empty.
  m_occupancy (size)  // Initialize occupancy to a table of 'size' filled with -1 (indicating unoccupied).
{
  m_occupancy.fill (-1);  // Set all table positions as unoccupied.
}","Initializes a table with a specified size, setting up the table's placements and occupancy."
"// Sets the content of a specific cell in the table.
void
table::set_cell (coord_t coord,
                 table_cell_content &&content,
                 enum x_align x_align,
                 enum y_align y_align)
{
  // Set a cell with a single-unit span and specified content and alignment.
  set_cell_span (rect_t (coord, table::size_t (1, 1)),
                 std::move (content), x_align, y_align);
}",Sets the content of a specific cell in the table.
"// Sets the content of a cell spanning multiple rows and columns.
void
table::set_cell_span (rect_t span,
                      table_cell_content &&content,
                      enum x_align x_align,
                      enum y_align y_align)
{
  gcc_assert (span.m_size.w > 0);  // Ensure the span has positive width.
  gcc_assert (span.m_size.h > 0);  // Ensure the span has positive height.

  int placement_idx = m_placements.size ();  // Get the current size of placements, which will be the index for the new placement.
  m_placements.emplace_back (cell_placement (span, std::move (content), x_align, y_align));  // Add the new cell placement.

  // Mark the occupied cells in the occupancy grid.
  for (int y = span.get_min_y (); y < span.get_next_y (); y++)
    for (int x = span.get_min_x (); x < span.get_next_x (); x++)
      {
        // Ensure the cell is unoccupied before setting it.
        gcc_assert (m_occupancy.get (coord_t (x, y)) == -1);
        m_occupancy.set (coord_t (x, y), placement_idx);  // Mark the cell as occupied by this placement.
      }
}","Sets the content of a cell that spans multiple rows and columns, marking the affected cells as occupied."
"// Tries to set the content of a cell span, but only if the span is unoccupied.
void
table::maybe_set_cell_span (rect_t span,
                            table_cell_content &&content,
                            enum x_align x_align,
                            enum y_align y_align)
{
  gcc_assert (span.m_size.w > 0);  // Ensure the span has positive width.
  gcc_assert (span.m_size.h > 0);  // Ensure the span has positive height.

  // Check if any cell in the span is occupied.
  for (int y = span.get_min_y (); y < span.get_next_y (); y++)
    for (int x = span.get_min_x (); x < span.get_next_x (); x++)
      {
        // If the cell is occupied, discard the content and do not set the span.
        if (m_occupancy.get (coord_t (x, y)) != -1)
          return;
      }

  // If the span is unoccupied, set the content and update occupancy.
  set_cell_span (span, std::move (content), x_align, y_align);
}
","Attempts to set content in a span of cells, but only if the span is unoccupied."
"// Converts the table into a canvas with the given theme and style manager.
canvas
table::to_canvas (const theme &theme, const style_manager &sm) const
{
  table_dimension_sizes col_widths (m_size.w);  // Initialize column widths.
  table_dimension_sizes row_heights (m_size.h);  // Initialize row heights.
  table_cell_sizes cell_sizes (col_widths, row_heights);  // Initialize cell sizes with the column and row sizes.

  // Pass 1 and 2 to calculate the final cell sizes.
  cell_sizes.pass_1 (*this);
  cell_sizes.pass_2 (*this);

  table_geometry tg (*this, cell_sizes);  // Create the table geometry with the calculated cell sizes.

  // Create the canvas with the calculated size and the provided style manager.
  canvas canvas (tg.get_canvas_size (), sm);
  paint_to_canvas (canvas, canvas::coord_t (0, 0), tg, theme);  // Paint the table content to the canvas.
  
  return canvas;  // Return the generated canvas.
}",Converts the table into a canvas with the specified theme and style manager.
"// Paints the entire table onto the canvas with borders and contents.
void
table::paint_to_canvas (canvas &canvas,
                        canvas::coord_t offset,
                        const table_geometry &tg,
                        const theme &theme) const
{
  // Fill the canvas with spaces to represent empty cells.
  canvas.fill (canvas::rect_t (offset, tg.get_canvas_size ()),
               styled_unichar (' '));

  // Paint the cell borders and contents.
  paint_cell_borders_to_canvas (canvas, offset, tg, theme);
  paint_cell_contents_to_canvas (canvas, offset, tg);
}","Paints the table onto a canvas, including filling empty spaces, painting cell borders, and rendering cell contents."
" void
table::debug () const
{
  // Use a temporary style manager to disable styling.
  style_manager sm;
  canvas canvas (to_canvas (unicode_theme (), sm));  // Create a canvas with the current theme and style manager.
  canvas.debug (false);  // Print the canvas to stderr without styling.
}","Prints the table to stderr for debugging purposes, rendering it without styling.






"
"// Constructor for table_dimension_sizes that initializes the table's size with a specified number of elements.
table_dimension_sizes::table_dimension_sizes (unsigned num)
: m_requirements (num, 0)  // Initialize the requirements array with 'num' elements set to 0.
{
}","Initializes the dimension sizes for a table, specifically the requirements for the number of rows or columns, with all values initially set to 0."
"void
table::add_other_table (table &&other,
                        table::coord_t offset)
{
  // Iterate over all placements in the other table
  for (auto &&placement : other.m_placements)
    {
      // Set the content and positioning for each cell in the other table, offset by the specified position
      set_cell_span (placement.m_rect + offset,
                     std::move (placement.m_content),
                     placement.m_x_align,
                     placement.m_y_align);
    }
}
","This function is used to add the contents of another table (other) to the current table (this). The cells in the other table are placed at a specified offset relative to the current table's coordinates. It iterates over each cell placement in the other table, and for each, it calls set_cell_span to place the content in the new position in the current table.

Parameters:
other: An r-value reference to another table to be added.
offset: The position to offset the contents of other when placing them into this.
Returns: Void.
Purpose: To merge another table's content into the current table at a specified location."
"const table::cell_placement *
table::get_placement_at (coord_t coord) const
{
  // Get the index of the placement at the given coordinate
  const int placement_idx = m_occupancy.get (coord);
  
  // If no placement is found at the coordinate, return nullptr
  if (placement_idx == -1)
    return nullptr;
  
  // Return the placement at the index found
  return &m_placements[placement_idx];
}
","This function returns the placement of a table cell at a specific coordinate. It checks whether the given coordinate has an associated cell placement by using m_occupancy.get. If a placement is found, it returns the corresponding placement from m_placements, otherwise, it returns nullptr.

Parameters:
coord: The coordinate of the table cell for which placement is requested.
Returns: A pointer to the cell_placement at the specified coordinate, or nullptr if no placement exists.
Purpose: To retrieve the placement information for a given coordinate in the table."
"int
table::get_occupancy_safe (coord_t coord) const
{
  // Check if the coordinate is out of bounds in the table
  if (coord.x < 0)
    return -1;
  if (coord.x >= m_size.w)
    return -1;
  if (coord.y < 0)
    return -1;
  if (coord.y >= m_size.h)
    return -1;
  
  // Return the occupancy for the coordinate if it's within bounds
  return m_occupancy.get (coord);
}
","This function safely retrieves the occupancy status of a table cell at a given coordinate, ensuring that the coordinate is within the bounds of the table. If the coordinate is out of bounds, it returns -1, indicating no placement exists. Otherwise, it retrieves the occupancy value using m_occupancy.get.

Parameters:
coord: The coordinate of the table cell whose occupancy is being checked.
Returns: The occupancy value (an index) of the cell, or -1 if the coordinate is out of bounds.
Purpose: To check whether a table cell at a specific coordinate is occupied, while ensuring the coordinate is within valid bounds."
"directions
table::get_connections (int table_x, int table_y) const
{
  // Retrieve the occupancy values for the cells around the current table cell
  int cell_a = get_occupancy_safe (coord_t (table_x - 1, table_y - 1));
  int cell_b = get_occupancy_safe (coord_t (table_x, table_y - 1));
  int cell_c = get_occupancy_safe (coord_t (table_x - 1, table_y));
  int cell_d = get_occupancy_safe (coord_t (table_x, table_y));
  
  // Determine if there are connections between the cells in the up, down, left, and right directions
  const bool up = (cell_a != cell_b);
  const bool down = (cell_c != cell_d);
  const bool left = (cell_a != cell_c);
  const bool right = (cell_b != cell_d);
  
  // Return a directions object representing the connections
  return directions (up, down, left, right);
}
","This function checks the neighboring cells of a specific table cell at (table_x, table_y) to determine if there are connections in the up, down, left, and right directions. It compares the occupancy values of adjacent cells to identify these connections.

Parameters:
table_x: The x-coordinate of the cell in the table.
table_y: The y-coordinate of the cell in the table.
Returns: A directions object indicating whether there are connections in the up, down, left, and right directions.
Purpose: To determine the directional relationships between a table cell and its neighbors."
"void
table::paint_cell_borders_to_canvas (canvas &canvas,
                                     canvas::coord_t offset,
                                     const table_geometry &tg,
                                     const theme &theme) const
{
  // Define the left and top borders of a cell using the theme's line art
  const canvas::cell_t left_border
    = theme.get_line_art (directions (true, /* up */
                                      true, /* down */
                                      false, /* left */
                                      false /* right */));
  const canvas::cell_t top_border
    = theme.get_line_art (directions (false, /* up */
                                      false, /* down */
                                      true, /* left */
                                      true)); /* right */

  // Loop through each row of the table
  for (int table_y = 0; table_y < m_size.h; table_y++)
    {
      // Convert the table's y-coordinate to the corresponding canvas y-coordinate
      const int canvas_y = tg.table_y_to_canvas_y (table_y);

      // Loop through each column of the table
      for (int table_x = 0; table_x < m_size.w; table_x++)
        {
          // Convert the table's (x, y) coordinate to the canvas coordinate
          canvas::coord_t canvas_top_left
            = tg.table_to_canvas(table::coord_t (table_x, table_y));

          // Get the connection directions for the current cell
          const directions c (get_connections (table_x, table_y));

          // Paint the top-left corner of the border, if needed
          canvas.paint (offset + canvas_top_left,
                        theme.get_line_art (c));

          // Paint the left border of the cell, if necessary
          if (c.m_down)
            canvas.paint (offset + canvas::coord_t (canvas_top_left.x,
                                                    canvas_y + 1),
                          left_border);

          // Paint the top border of the cell, if necessary
          if (c.m_right)
            {
              const int col_width = tg.get_col_width (table_x);
              for (int x_offset = 0; x_offset < col_width; x_offset++)
                {
                  const int canvas_x = canvas_top_left.x + 1 + x_offset;
                  canvas.paint (offset + canvas::coord_t (canvas_x, canvas_y),
                                top_border);
                }
            }
        }

      // Paint the right-hand border of the row
      const int table_x = m_size.w;
      const int canvas_x = tg.table_x_to_canvas_x (table_x);
      const directions c (get_connections (m_size.w, table_y));
      canvas.paint(offset + canvas::coord_t (canvas_x, canvas_y),
                   theme.get_line_art (directions (c.m_up,
                                                   c.m_down,
                                                   c.m_left,
                                                   false))); // right border

      // Paint the bottom right corner of the table cell, if needed
      canvas.paint(offset + canvas::coord_t (canvas_x, canvas_y + 1),
                   theme.get_line_art (directions (c.m_down, /* up */
                                                   c.m_down, /* down */
                                                   false, /* left */
                                                   false))); // right border
    }

  // Draw the bottom border of the table
  {
    const int canvas_y = tg.get_canvas_size ().h - 1;
    for (int table_x = 0; table_x < m_size.w; table_x++)
      {
        // Get the connection directions for the current cell in the last row
        const directions c (get_connections (table_x, m_size.h));
        const int left_canvas_x = tg.table_x_to_canvas_x (table_x);

        // Paint the bottom-left corner of the table row
        canvas.paint (offset + canvas::coord_t (left_canvas_x, canvas_y),
                      theme.get_line_art (directions (c.m_up,
                                                      false, /* down */
                                                      c.m_left,
                                                      c.m_right)));

        // Paint the horizontal span of the bottom border
        const int col_width = tg.get_col_width (table_x);
        for (int x_offset = 0; x_offset < col_width; x_offset++)
          {
            const int canvas_x = left_canvas_x + 1 + x_offset;
            canvas.paint(offset + canvas::coord_t (canvas_x, canvas_y),
                         theme.get_line_art (directions (false, // up
                                                         false, // down
                                                         c.m_right, // left
                                                         c.m_right))); // right
          }
      }

    // Paint the bottom-right corner of the table
    const int table_x = m_size.w;
    const int canvas_x = tg.table_x_to_canvas_x (table_x);
    const directions c (get_connections (m_size.w, m_size.h));
    canvas.paint (offset + canvas::coord_t (canvas_x, canvas_y),
                  theme.get_line_art (directions (c.m_up, // up
                                                  false, // down
                                                  c.m_left, // left
                                                  false))); // right
  }
}
","This function is responsible for painting the borders of each table cell to a canvas. It considers the per-table-cell connections (up, down, left, right) and uses a theme to apply  appropriate line art to represent these borders. The function also handles painting the right and  bottom borders of the table and cell content boundaries."
"void
table::paint_cell_contents_to_canvas(canvas &canvas,
                                     canvas::coord_t offset,
                                     const table_geometry &tg) const
{
  // Iterate through all placements in the table and paint the content for each cell
  for (auto &placement : m_placements)
    placement.paint_cell_contents_to_canvas (canvas, offset, tg);
}
",This function paints the content inside each cell to the canvas. It iterates through each placement (which represents where a cell is located in the table) and calls the method that paints the content inside that cell. This ensures the table's content is visually represented.
"void
table_cell_sizes::pass_1 (const table &table)
{
  // Loop through all placements in the table
  for (auto &placement : table.m_placements)
    if (placement.one_by_one_p ())
      {
        // For 1x1 cells, update the column width and row height requirements
        canvas::size_t canvas_size (placement.get_min_canvas_size ());
        table::coord_t table_coord (placement.m_rect.m_top_left);
        m_col_widths.require (table_coord.x, canvas_size.w);
        m_row_heights.require (table_coord.y, canvas_size.h);
      }
}","This function calculates the minimum canvas size for cells that are 1x1 in the table. It updates the column widths and row heights to accommodate the size of these cells. Each 1x1 cell is examined, and the corresponding row and column dimensions are adjusted."
"// Function: table_cell_sizes::pass_2
// Description: This function handles the second pass of calculating cell sizes for cells that span 
// multiple rows or columns. It ensures that the table's columns and rows are adjusted to fit 
// larger cell spans. The required canvas size is compared with the current canvas size, and 
// the deficit is spread across the corresponding rows and columns.
void
table_cell_sizes::pass_2 (const table &table)
{
  // Loop through all placements in the table
  for (auto &placement : table.m_placements)
    if (!placement.one_by_one_p ())
      {
        // Calculate the required canvas size for the current cell
        const canvas::size_t req_canvas_size (placement.get_min_canvas_size ());
        const canvas::size_t current_canvas_size
          = get_canvas_size (placement.m_rect);

        // Grow columns as necessary
        if (req_canvas_size.w > current_canvas_size.w)
          {
            int deficit = req_canvas_size.w - current_canvas_size.w;
            const int per_col = deficit / placement.m_rect.m_size.w;
            // Distribute the deficit across the columns
            for (int table_x = placement.m_rect.get_min_x ();
                 table_x < placement.m_rect.get_next_x ();
                 table_x++)
            {
              m_col_widths.m_requirements[table_x] += per_col;
              deficit -= per_col;
            }
            // Ensure all of the deficit is allocated
            if (deficit > 0)
              {
                const int table_x = placement.m_rect.get_max_x ();
                m_col_widths.m_requirements[table_x] += deficit;
              }
          }

        // Grow rows as necessary
        if (req_canvas_size.h > current_canvas_size.h)
          {
            int deficit = req_canvas_size.h - current_canvas_size.h;
            const int per_row = deficit / placement.m_rect.m_size.h;
            // Distribute the deficit across the rows
            for (int table_y = placement.m_rect.get_min_y ();
                 table_y < placement.m_rect.get_next_y ();
                 table_y++)
            {
              m_row_heights.m_requirements[table_y] += per_row;
              deficit -= per_row;
            }
            // Ensure all of the deficit is allocated
            if (deficit > 0)
              {
                const int table_y = placement.m_rect.get_max_y ();
                m_row_heights.m_requirements[table_y] += deficit;
              }
          }
      }
}","This function handles cells that span multiple rows or columns. It checks whether the current size of the cell is adequate and, if not, distributes the necessary additional space across the rows or columns affected by the cell's span. This ensures that the table's layout can accommodate larger, multi-cell placements."
"canvas::size_t
table_cell_sizes::get_canvas_size (const table::rect_t &rect) const
{
  canvas::size_t result (0, 0); // Initialize the result size to 0, 0
  // Loop through each column in the specified rectangle and accumulate the column widths
  for (int table_x = rect.get_min_x (); table_x < rect.get_next_x (); table_x++)
    result.w += m_col_widths.m_requirements[table_x];
  
  // Loop through each row in the specified rectangle and accumulate the row heights
  for (int table_y = rect.get_min_y (); table_y < rect.get_next_y (); table_y++)
    result.h += m_row_heights.m_requirements[table_y];
  
  // Add space for borders (subtracting 1 because we don't want extra space beyond the borders)
  result.w += rect.m_size.w - 1;
  result.h += rect.m_size.h - 1;
  
  return result; // Return the calculated canvas size
}
","This function calculates the total canvas size required to fit a given table rectangle, including column widths, row heights, and space for borders. It loops through the columns and rows of the specified rectangle to accumulate the required size for each, then adds space for the borders (subtracted by 1 to avoid extra space)."
"table_geometry::table_geometry (const table &table, table_cell_sizes &cell_sizes)
: m_cell_sizes (cell_sizes),
  m_canvas_size (canvas::size_t (0, 0)),
  m_col_start_x (table.get_size ().w),
  m_row_start_y (table.get_size ().h)
{
  recalc_coords (); // Recalculate coordinates after initialization
}","This constructor initializes the table geometry, setting up the table's cell sizes, canvas size, and start positions for columns and rows. It then calls recalc_coords() to calculate the positions based on column widths and row heights."
"void
table_geometry::recalc_coords ()
{
  // Clear the previous column start positions
  m_col_start_x.clear ();
  int iter_canvas_x = 0; // Variable to accumulate the x-coordinate positions of columns
  // Loop through each column width requirement and calculate the start positions for each column
  for (auto w : m_cell_sizes.m_col_widths.m_requirements)
    {
      m_col_start_x.push_back (iter_canvas_x); // Store the start position of the current column
      iter_canvas_x += w + 1; // Move to the next x-coordinate, adding 1 for the border
    }

  // Clear the previous row start positions
  m_row_start_y.clear ();
  int iter_canvas_y = 0; // Variable to accumulate the y-coordinate positions of rows
  // Loop through each row height requirement and calculate the start positions for each row
  for (auto h : m_cell_sizes.m_row_heights.m_requirements)
    {
      m_row_start_y.push_back (iter_canvas_y); // Store the start position of the current row
      iter_canvas_y += h + 1; // Move to the next y-coordinate, adding 1 for the border
    }

  // Calculate the overall canvas size
  m_canvas_size = canvas::size_t (iter_canvas_x + 1, iter_canvas_y + 1); 
}
","This function recalculates the starting positions of each column and row based on the column widths and row heights, updating the m_col_start_x and m_row_start_y vectors. It also calculates the overall canvas size by summing the total space required for all rows and columns, accounting for borders."
"// Function: table_geometry::table_to_canvas
// Description: Converts a table coordinate (row, column) to its corresponding canvas coordinate 
// (including the border), by combining the results of the table_x_to_canvas_x and table_y_to_canvas_y functions.
canvas::coord_t
table_geometry::table_to_canvas (table::coord_t table_coord) const
{
  return canvas::coord_t (table_x_to_canvas_x (table_coord.x),
                          table_y_to_canvas_y (table_coord.y));
}
","This function converts a table coordinate (given by table_coord, a table::coord_t object representing a specific table position) into the corresponding canvas coordinate. It uses table_x_to_canvas_x and table_y_to_canvas_y to calculate the position."
"// Function: table_geometry::table_x_to_canvas_x
// Description: Converts a table column coordinate to the corresponding canvas x-coordinate, 
// accounting for the column start positions and including space for borders.
int
table_geometry::table_x_to_canvas_x (int table_x) const
{
  // If the column is beyond the last column, return the right-hand border of the table
  if (table_x == (int)m_col_start_x.size ())
    return m_canvas_size.w - 1;
  return m_col_start_x[table_x]; // Return the start position for the specified column
}","This function calculates the x-coordinate on the canvas for a given table column (table_x). It checks whether the column is at the end and returns the right border, or it returns the calculated start position based on the column's width."
"// Function: table_geometry::table_y_to_canvas_y
// Description: Converts a table row coordinate to the corresponding canvas y-coordinate, 
// accounting for the row start positions and including space for borders.
int
table_geometry::table_y_to_canvas_y (int table_y) const
{
  // If the row is beyond the last row, return the bottom border of the table
  if (table_y == (int)m_row_start_y.size ())
    return m_canvas_size.h - 1;
  return m_row_start_y[table_y]; // Return the start position for the specified row
}","This function calculates the y-coordinate on the canvas for a given table row (table_y). Like table_x_to_canvas_x, it checks if the row is at the end and returns the bottom border or returns the calculated start position based on the row's height."
"simple_table_geometry::simple_table_geometry (const table &table)
: m_col_widths (table.get_size ().w),
  m_row_heights (table.get_size ().h),
  m_cell_sizes (m_col_widths, m_row_heights),
  m_tg (table, m_cell_sizes)
{
  m_cell_sizes.pass_1 (table); // Perform the first pass to calculate cell sizes
  m_cell_sizes.pass_2 (table); // Perform the second pass to adjust cell sizes
  m_tg.recalc_coords (); // Recalculate the table's coordinates
}","This constructor sets up the table's simple geometry, initializing column widths, row heights, and cell sizes. It performs two passes over the table to adjust the sizes based on the content and then recalculates the coordinates for the entire table layout."
"// Function to test the Tic-Tac-Toe board rendering.
static void test_tic_tac_toe () {
  style_manager sm; // Initialize the style manager
  table t (table::size_t (3, 3)); // Create a 3x3 table for the Tic-Tac-Toe board

  // Setting up the table cells with X and O
  t.set_cell (table::coord_t (0, 0), styled_string (sm, ""X"")); // Set X in the top-left corner
  t.set_cell (table::coord_t (1, 0), styled_string (sm, """"));  // Set empty in the second row, first column
  t.set_cell (table::coord_t (2, 0), styled_string (sm, """"));  // Set empty in the third row, first column
  t.set_cell (table::coord_t (0, 1), styled_string (sm, ""O"")); // Set O in the top-middle cell
  t.set_cell (table::coord_t (1, 1), styled_string (sm, ""O"")); // Set O in the middle-middle cell
  t.set_cell (table::coord_t (2, 1), styled_string (sm, """"));  // Set empty in the third row, middle column
  t.set_cell (table::coord_t (0, 2), styled_string (sm, ""X"")); // Set X in the top-right corner
  t.set_cell (table::coord_t (1, 2), styled_string (sm, """"));  // Set empty in the second row, right column
  t.set_cell (table::coord_t (2, 2), styled_string (sm, ""O"")); // Set O in the bottom-right cell

  // Render and verify the board in ASCII theme
  {
    canvas canvas (t.to_canvas (ascii_theme (), sm)); // Convert table to canvas using ASCII theme
    ASSERT_CANVAS_STREQ
      (canvas, false,
       (""+-+-+-+\n""
        ""|X| | |\n""
        ""+-+-+-+\n""
        ""|O|O| |\n""
        ""+-+-+-+\n""
        ""|X| |O|\n""
        ""+-+-+-+\n""));
  }

  // Render and verify the board in Unicode theme
  {
    canvas canvas (t.to_canvas (unicode_theme (), sm)); // Convert table to canvas using Unicode theme
    ASSERT_CANVAS_STREQ
      (canvas, false,
       (""┌─┬─┬─┐\n""
        ""│X│ │ │\n""
        ""├─┼─┼─┤\n""
        ""│O│O│ │\n""
        ""├─┼─┼─┤\n""
        ""│X│ │O│\n""
        ""└─┴─┴─┘\n""));
  }
}
","This function tests the rendering of a Tic-Tac-Toe game board. The table is set up with X and O in different cells, and then it's rendered twice: once in an ASCII theme and once in a Unicode theme. Assertions are made to check if the rendered output matches the expected output."
"// Helper function to create a 3x3 table with textual content.
static table make_text_table () {
  style_manager sm; // Initialize the style manager
  table t (table::size_t (3, 3)); // Create a 3x3 table

  // Set the text content in the table cells
  t.set_cell (table::coord_t (0, 0), styled_string (sm, ""top left""));
  t.set_cell (table::coord_t (1, 0), styled_string (sm, ""top middle""));
  t.set_cell (table::coord_t (2, 0), styled_string (sm, ""top right""));
  t.set_cell (table::coord_t (0, 1), styled_string (sm, ""middle left""));
  t.set_cell (table::coord_t (1, 1), styled_string (sm, ""middle middle""));
  t.set_cell (table::coord_t (2, 1), styled_string (sm, ""middle right""));
  t.set_cell (table::coord_t (0, 2), styled_string (sm, ""bottom left""));
  t.set_cell (table::coord_t (1, 2), styled_string (sm, ""bottom middle""));
  t.set_cell (table::coord_t (2, 2), styled_string (sm, ""bottom right""));

  return t; // Return the table
}",This helper function creates a 3x3 table and sets specific text in each cell. It returns the created table which will be used in tests.
"// Function to test rendering of the table with text data.
static void test_text_table () {
  style_manager sm; // Initialize the style manager
  table table = make_text_table (); // Create the text table

  // Render and verify the table in ASCII theme
  {
    canvas canvas (table.to_canvas (ascii_theme(), sm)); // Convert table to canvas using ASCII theme
    ASSERT_CANVAS_STREQ
      (canvas, false,
       (""+-----------+-------------+------------+\n""
        ""| top left  | top middle  | top right  |\n""
        ""+-----------+-------------+------------+\n""
        ""|middle left|middle middle|middle right|\n""
        ""+-----------+-------------+------------+\n""
        ""|bottom left|bottom middle|bottom right|\n""
        ""+-----------+-------------+------------+\n""));
  }

  // Render and verify the table in Unicode theme
  {
    canvas canvas (table.to_canvas (unicode_theme(), sm)); // Convert table to canvas using Unicode theme
    ASSERT_CANVAS_STREQ
      (canvas, false,
       (""┌───────────┬─────────────┬────────────┐\n""
        ""│ top left  │ top middle  │ top right  │\n""
        ""├───────────┼─────────────┼────────────┤\n""
        ""│middle left│middle middle│middle right│\n""
        ""├───────────┼─────────────┼────────────┤\n""
        ""│bottom left│bottom middle│bottom right│\n""
        ""└───────────┴─────────────┴────────────┘\n""));
  }
}",This function tests rendering of the text table created by make_text_table(). It renders the table using both ASCII and Unicode themes and compares the generated output with the expected one.
"// Function to test offset table rendering.
static void test_offset_table () {
  style_manager sm; // Initialize the style manager
  table table = make_text_table (); // Create the text table
  simple_table_geometry stg (table); // Create simple table geometry

  // Get the canvas size of the table
  const canvas::size_t tcs = stg.m_tg.get_canvas_size();
  
  // Render and verify the table with offset in ASCII theme
  {
    canvas canvas (canvas::size_t (tcs.w + 5, tcs.h + 5), sm); // Create a canvas with extra space for offset
    canvas.debug_fill (); // Fill the canvas with debug colors
    table.paint_to_canvas (canvas, canvas::coord_t (3, 3),
                           stg.m_tg, ascii_theme()); // Paint the table onto the canvas
    ASSERT_CANVAS_STREQ
      (canvas, false,
       (""*********************************************\n""
        ""*********************************************\n""
        ""*********************************************\n""
        ""***+-----------+-------------+------------+**\n""
        ""***| top left  | top middle  | top right  |**\n""
        ""***+-----------+-------------+------------+**\n""
        ""***|middle left|middle middle|middle right|**\n""
        ""***+-----------+-------------+------------+**\n""
        ""***|bottom left|bottom middle|bottom right|**\n""
        ""***+-----------+-------------+------------+**\n""
        ""*********************************************\n""
        ""*********************************************\n""));
  }

  // Render and verify the table with offset in Unicode theme
  {
    canvas canvas (canvas::size_t (tcs.w + 5, tcs.h + 5), sm); // Create a canvas with extra space for offset
    canvas.debug_fill (); // Fill the canvas with debug colors
    table.paint_to_canvas (canvas, canvas::coord_t (3, 3),
                           stg.m_tg, unicode_theme()); // Paint the table onto the canvas
    ASSERT_CANVAS_STREQ
      (canvas, false,
       (""*********************************************\n""
        ""*********************************************\n""
        ""*********************************************\n""
        ""***┌───────────┬─────────────┬────────────┐**\n""
        ""***│ top left  │ top middle  │ top right  │**\n""
        ""***├───────────┼─────────────┼────────────┤**\n""
        ""***│middle left│middle middle│middle right│**\n""
        ""***├───────────┼─────────────┼────────────┤**\n""
        ""***│bottom left│bottom middle│bottom right│**\n""
        ""***└───────────┴─────────────┴────────────┘**\n""
        ""*********************************************\n""
        ""*********************************************\n""));
  }
}","This function tests the offset rendering of the table, ensuring that the table can be rendered with an offset on a larger canvas. The table is painted with extra space around it, and the result is checked against expected values in both ASCII and Unicode themes."
"static void test_spans() {
  style_manager sm;
  // Create a 3x3 table
  table table(table::size_t(3, 3));

  // Span cells across different rows and columns with values
  table.set_cell_span(table::rect_t(table::coord_t(0, 0), table::size_t(3, 1)), styled_string(sm, ""ABC""));
  table.set_cell_span(table::rect_t(table::coord_t(0, 1), table::size_t(2, 1)), styled_string(sm, ""DE""));
  table.set_cell_span(table::rect_t(table::coord_t(2, 1), table::size_t(1, 1)), styled_string(sm, ""F""));
  table.set_cell(table::coord_t(0, 2), styled_string(sm, ""G""));
  table.set_cell(table::coord_t(1, 2), styled_string(sm, ""H""));
  table.set_cell(table::coord_t(2, 2), styled_string(sm, ""I""));

  // Test for ASCII rendering
  {
    canvas canvas(table.to_canvas(ascii_theme(), sm));
    ASSERT_CANVAS_STREQ(canvas, false, 
      (""+-----+\n""
       ""| ABC |\n""
       ""+---+-+\n""
       ""|DE |F|\n""
       ""+-+-+-+\n""
       ""|G|H|I|\n""
       ""+-+-+-+\n""));
  }

  // Test for Unicode rendering
  {
    canvas canvas(table.to_canvas(unicode_theme(), sm));
    ASSERT_CANVAS_STREQ(canvas, false,
      (""┌─────┐\n""
       ""│ ABC │\n""
       ""├───┬─┤\n""
       ""│DE │F│\n""
       ""├─┬─┼─┤\n""
       ""│G│H│I│\n""
       ""└─┴─┴─┘\n""));
  }
}
","This test function verifies the table rendering when cells are merged (spanned) across multiple rows and columns. It creates a table and assigns cell spans with specific values.

Description:
Setting up the table:
A 3x3 table is created.
The function spans several cells in different patterns (rows and columns) and fills them with styled_string values (""ABC"", ""DE"", ""F"", ""G"", ""H"", ""I"").
Rendering in ASCII and Unicode themes:
After setting the spans, the table is rendered using two themes (ASCII and Unicode).
It checks whether the rendered output matches the expected output."
"static void test_spans_2() {
  style_manager sm;
  // Create a 5x5 table
  table table(table::size_t(5, 5));

  // Span various cells across rows and columns
  table.set_cell_span(table::rect_t(table::coord_t(0, 0), table::size_t(3, 3)), styled_string(sm, ""A""));
  table.set_cell_span(table::rect_t(table::coord_t(3, 0), table::size_t(1, 1)), styled_string(sm, ""B""));
  table.set_cell_span(table::rect_t(table::coord_t(4, 0), table::size_t(1, 2)), styled_string(sm, ""C""));
  table.set_cell_span(table::rect_t(table::coord_t(3, 1), table::size_t(1, 1)), styled_string(sm, ""D""));
  table.set_cell_span(table::rect_t(table::coord_t(3, 2), table::size_t(1, 1)), styled_string(sm, ""E""));
  table.set_cell_span(table::rect_t(table::coord_t(4, 2), table::size_t(1, 1)), styled_string(sm, ""F""));
  table.set_cell_span(table::rect_t(table::coord_t(0, 3), table::size_t(2, 2)), styled_string(sm, ""G""));
  table.set_cell_span(table::rect_t(table::coord_t(2, 3), table::size_t(1, 2)), styled_string(sm, ""H""));
  table.set_cell_span(table::rect_t(table::coord_t(3, 3), table::size_t(2, 1)), styled_string(sm, ""I""));
  table.set_cell_span(table::rect_t(table::coord_t(3, 4), table::size_t(2, 1)), styled_string(sm, ""J""));

  // Verify that each coordinate contains the expected value
  ASSERT_TABLE_CELL_STREQ(table, 0, 0, ""A"");
  ASSERT_TABLE_CELL_STREQ(table, 1, 0, ""A"");
  ASSERT_TABLE_CELL_STREQ(table, 2, 0, ""A"");
  ASSERT_TABLE_CELL_STREQ(table, 3, 0, ""B"");
  ASSERT_TABLE_CELL_STREQ(table, 4, 0, ""C"");

  ASSERT_TABLE_CELL_STREQ(table, 0, 1, ""A"");
  ASSERT_TABLE_CELL_STREQ(table, 1, 1, ""A"");
  ASSERT_TABLE_CELL_STREQ(table, 2, 1, ""A"");
  ASSERT_TABLE_CELL_STREQ(table, 3, 1, ""D"");
  ASSERT_TABLE_CELL_STREQ(table, 4, 1, ""C"");

  ASSERT_TABLE_CELL_STREQ(table, 0, 2, ""A"");
  ASSERT_TABLE_CELL_STREQ(table, 1, 2, ""A"");
  ASSERT_TABLE_CELL_STREQ(table, 2, 2, ""A"");
  ASSERT_TABLE_CELL_STREQ(table, 3, 2, ""E"");
  ASSERT_TABLE_CELL_STREQ(table, 4, 2, ""F"");

  ASSERT_TABLE_CELL_STREQ(table, 0, 3, ""G"");
  ASSERT_TABLE_CELL_STREQ(table, 1, 3, ""G"");
  ASSERT_TABLE_CELL_STREQ(table, 2, 3, ""H"");
  ASSERT_TABLE_CELL_STREQ(table, 3, 3, ""I"");
  ASSERT_TABLE_CELL_STREQ(table, 4, 3, ""I"");

  ASSERT_TABLE_CELL_STREQ(table, 0, 4, ""G"");
  ASSERT_TABLE_CELL_STREQ(table, 1, 4, ""G"");
  ASSERT_TABLE_CELL_STREQ(table, 2, 4, ""H"");
  ASSERT_TABLE_CELL_STREQ(table, 3, 4, ""J"");
  ASSERT_TABLE_CELL_STREQ(table, 4, 4, ""J"");

  // Test rendering in ASCII theme
  {
    canvas canvas(table.to_canvas(ascii_theme(), sm));
    ASSERT_CANVAS_STREQ(canvas, false, 
      (""+---+-+-+\n""
       ""|   |B| |\n""
       ""|   +-+C|\n""
       ""| A |D| |\n""
       ""|   +-+-+\n""
       ""|   |E|F|\n""
       ""+-+-+-+-+\n""
       ""| | | I |\n""
       ""|G|H+---+\n""
       ""| | | J |\n""
       ""+-+-+---+\n""));
  }

  // Test rendering in Unicode theme
  {
    canvas canvas(table.to_canvas(unicode_theme(), sm));
    ASSERT_CANVAS_STREQ(canvas, false, 
      (""┌───┬─┬─┐\n""
       ""│   │B│ │\n""
       ""│   ├─┤C│\n""
       ""│ A │D│ │\n""
       ""│   ├─┼─┤\n""
       ""│   │E│F│\n""
       ""├─┬─┼─┴─┤\n""
       ""│ │ │ I │\n""
       ""│G│H├───┤\n""
       ""│ │ │ J │\n""
       ""└─┴─┴───┘\n""));
  }
}
","This function tests a 5x5 table with various cell spans. It spans cells across multiple rows and columns, testing both the ability to span large areas and the correctness of cell occupancy in each table coordinate.

Description:
Creating the table:
A 5x5 table is created.
Several cell spans are set across the table (spanning rows and columns with various string values).
Verifying cell contents:
After spanning the cells, the table is checked for the correct content at each position using ASSERT_TABLE_CELL_STREQ to ensure proper occupation.
Rendering in ASCII and Unicode themes:
The table is rendered in both ASCII and Unicode themes and compared against expected output to ensure correct rendering."
"static void test_spans_3() {
  style_manager sm;
  // Create a table
  table table(table::size_t(3, 3));

  // Span cells with a string exceeding buffer size
  table.set_cell_span(table::rect_t(table::coord_t(0, 0), table::size_t(3, 3)), styled_string(sm, ""hello world!""));

  // Test rendering in ASCII theme
  {
    canvas canvas(table.to_canvas(ascii_theme(), sm));
    ASSERT_CANVAS_STREQ(canvas, false, 
      (""+-----+\n""
       ""|hello|\n""
       ""+---+-+\n""
       ""|world!|\n""
       ""+-----+\n""));
  }

  // Test rendering in Unicode theme
  {
    canvas canvas(table.to_canvas(unicode_theme(), sm));
    ASSERT_CANVAS_STREQ(canvas, false, 
      (""┌─────┐\n""
       ""│hello│\n""
       ""├─────┤\n""
       ""│world!│\n""
       ""└─────┘\n""));
  }
}
","This function tests handling a buffer overflow scenario. It creates a table to simulate a situation where a string exceeds a predefined buffer size.

Description:
Setting up the table:

A string ""hello world!"" is split across a table with a buffer size of 10.
The table spans the string across the first row and checks the overflow beyond the buffer.
Rendering:

The table is rendered using both ASCII and Unicode themes, and the output is checked to ensure proper formatting."
"// Test case to display IPv4 header layout in a table format
static void test_ipv4_header ()
{
  style_manager sm;  // Create a style manager instance for styling the table
  table table (table::size_t (34, 10));  // Create a table with 34 columns and 10 rows

  // Set the header labels for the table
  table.set_cell (table::coord_t (0, 0), styled_string (sm, ""Offsets""));
  table.set_cell (table::coord_t (1, 0), styled_string (sm, ""Octet""));
  table.set_cell (table::coord_t (0, 1), styled_string (sm, ""Octet""));
  
  // Set the octet values across the table header (0 to 3)
  for (int octet = 0; octet < 4; octet++)
    table.set_cell_span (table::rect_t (table::coord_t (2 + (octet * 8), 0),
                                       table::size_t (8, 1)),
                         styled_string::from_fmt (sm, nullptr, ""%i"", octet));
  
  // Set the bit labels across the second row (0 to 31)
  table.set_cell (table::coord_t (1, 1), styled_string (sm, ""Bit""));
  for (int bit = 0; bit < 32; bit++)
    table.set_cell (table::coord_t (bit + 2, 1),
                    styled_string::from_fmt (sm, nullptr, ""%i"", bit));

  // Set word offsets for the IPv4 header
  for (int word = 0; word < 6; word++)
  {
    table.set_cell (table::coord_t (0, word + 2),
                    styled_string::from_fmt (sm, nullptr, ""%i"", word * 4));
    table.set_cell (table::coord_t (1, word + 2),
                    styled_string::from_fmt (sm, nullptr, ""%i"", word * 32));
  }

  // Set placeholders for '...' for the table to show optional fields (options)
  table.set_cell (table::coord_t (0, 8), styled_string (sm, ""...""));
  table.set_cell (table::coord_t (1, 8), styled_string (sm, ""...""));
  table.set_cell (table::coord_t (0, 9), styled_string (sm, ""56""));
  table.set_cell (table::coord_t (1, 9), styled_string (sm, ""448""));

  // Macro to set the bits of various fields in the IPv4 header
  #define SET_BITS(FIRST, LAST, NAME)           \
  do {                                          \
    const int first = (FIRST);                  \
    const int last = (LAST);                    \
    const char *name = (NAME);                  \
    const int row = first / 32;                 \
    gcc_assert (last / 32 == row);              \
    table::rect_t rect (table::coord_t ((first % 32) + 2, row + 2), \
                        table::size_t (last + 1 - first , 1)); \
    table.set_cell_span (rect, styled_string (sm, name)); \
  } while (0)

  // Set various fields in the IPv4 header by using the macro
  SET_BITS (0, 3, ""Version"");
  SET_BITS (4, 7, ""IHL"");
  SET_BITS (8, 13, ""DSCP"");
  SET_BITS (14, 15, ""ECN"");
  SET_BITS (16, 31, ""Total Length"");

  SET_BITS (32 +  0, 32 + 15, ""Identification"");
  SET_BITS (32 + 16, 32 + 18, ""Flags"");
  SET_BITS (32 + 19, 32 + 31, ""Fragment Offset"");

  SET_BITS (64 +  0, 64 +  7, ""Time To Live"");
  SET_BITS (64 +  8, 64 + 15, ""Protocol"");
  SET_BITS (64 + 16, 64 + 31, ""Header Checksum"");

  SET_BITS (96 +  0, 96 + 31, ""Source IP Address"");
  SET_BITS (128 +  0, 128 + 31, ""Destination IP Address"");

  // Set the 'Options' section of the header as a placeholder
  table.set_cell_span(table::rect_t (table::coord_t (2, 7),
                                     table::size_t (32, 3)),
                      styled_string (sm, ""Options""));

  // Convert the table to canvas using ASCII theme and compare with expected output
  canvas canvas (table.to_canvas (ascii_theme(), sm));
  ASSERT_CANVAS_STREQ
    (canvas, false,
     (""+-------+-----+---------------+---------------------+-----------------------+-----------------------+\n""
      ""|Offsets|Octet|       0       |          1          |           2           |           3           |\n""
      ""+-------+-----+-+-+-+-+-+-+-+-+-+-+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n""
      ""| Octet | Bit |0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|\n""
      ""+-------+-----+-+-+-+-+-+-+-+-+-+-+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n""
      ""|   0   |  0  |Version|  IHL  |     DSCP      | ECN |                 Total Length                  |\n""
      ""+-------+-----+-------+-------+---------------+-----+--------+--------------------------------------+\n""
      ""|   4   | 32  |           Identification            | Flags  |           Fragment Offset            |\n""
      ""+-------+-----+---------------+---------------------+--------+--------------------------------------+\n""
      ""|   8   | 64  | Time To Live  |      Protocol       |                Header Checksum                |\n""
      ""+-------+-----+---------------+---------------------+-----------------------------------------------+\n""
      ""|  12   | 96  |                                  Source IP Address                                  |\n""
      ""+-------+-----+-------------------------------------------------------------------------------------+\n""
      ""|  16   | 128 |                               Destination IP Address                                |\n""
      ""+-------+-----+-------------------------------------------------------------------------------------+\n""
      ""|  20   | 160 |                                                                                     |\n""
      ""+-------+-----+                                                                                     |\n""
      ""|  ...  | ... |                                       Options                                       |\n""
      ""+-------+-----+                                                                                     |\n""
      ""|  56   | 448 |                                                                                     |\n""
      ""+-------+-----+-------------------------------------------------------------------------------------+\n""));
  
  // Convert the table to canvas using Unicode theme and compare with expected output
  canvas canvas (table.to_canvas (unicode_theme(), sm));
  ASSERT_CANVAS_STREQ
    (canvas, false,
     (""┌───────┬─────┬───────────────┬─────────────────────┬───────────────────────┬───────────────────────┐\n""
      ""│Offsets│Octet│       0       │          1          │           2           │           3           │\n""
      ""├───────┼─────┼─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬──┬──┬──┬──┬──┬──┼──┬──┬──┬──┬──┬──┬──┬──┼──┬──┬──┬──┬──┬──┬──┬──┤\n""
      ""│ Octet │ Bit │0│1│2│3│4│5│6│7│8│9│10│11│12│13│14│15│16│17│18│19│20│21│22│23│24│25│26│27│28│29│30│31│\n""
      ""├───────┼─────┼─┴─┴─┴─┼─┴─┴─┴─┼─┴─┴──┴──┴──┴──┼──┴──┼──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┤\n""
      ""│   0   │  0  │Version│  IHL  │     DSCP      │ ECN │                 Total Length                  │\n""
      ""├───────┼─────┼───────┴───────┴───────────────┴─────┼────────┬──────────────────────────────────────┤\n""
      ""│   4   │  32 │           Identification            │ Flags │           Fragment Offset            │\n""
      ""├───────┼─────┼──────────────────┼──────────────────┼──────┬────────┬──────────────────────────────────────┤\n""
      ""│   8   │  64 │ Time To Live   │      Protocol     │     │           Header Checksum             │\n""
      ""├───────┼─────┼────────┼──────────┼──────────────────┼──────┼────────────────────────┬────────────┘\n""
      ""│  12   │  96 │                                  Source IP Address                                  │\n""
      ""├───────┼─────┼─────────────────────────────────────────────────────────────────────────────┐\n""
      ""│  16   │ 128 │                               Destination IP Address                                │\n""
      ""└───────┴─────┴────────────────────────────────────────────────────────────────────────────────┘""));
}
}","Creates a table representing the IPv4 header structure, with fields like Version, IHL, DSCP, etc.
The test includes assertions to ensure the correct placement and representation of each field and its corresponding bits in the header.
The canvas generated from this table is compared using ASSERT_CANVAS_STREQ, ensuring the correct rendering in ASCII and Unicode formats."
"// Test case to verify handling of missing (empty) cells in the table
static void test_missing_cells () {
  // Create a style manager object to manage styling
  style_manager sm;

  // Create a 3x3 table object (3 rows, 3 columns)
  table table (table::size_t (3, 3));

  // Set values in some of the table cells, while others remain empty (missing)
  table.set_cell (table::coord_t (1, 0), styled_string (sm, ""A""));  // Cell (1, 0) set to ""A""
  table.set_cell (table::coord_t (0, 1), styled_string (sm, ""B""));  // Cell (0, 1) set to ""B""
  table.set_cell (table::coord_t (1, 1), styled_string (sm, ""C""));  // Cell (1, 1) set to ""C""
  table.set_cell (table::coord_t (2, 1), styled_string (sm, ""D""));  // Cell (2, 1) set to ""D""
  table.set_cell (table::coord_t (1, 2), styled_string (sm, ""E""));  // Cell (1, 2) set to ""E""

  // Assertions to check the values and missing cells in the table
  ASSERT_TABLE_NULL_CELL (table, 0, 0);  // Cell (0, 0) should be NULL (empty)
  ASSERT_TABLE_CELL_STREQ (table, 1, 0, ""A"");  // Cell (1, 0) should be ""A""
  ASSERT_TABLE_NULL_CELL (table, 2, 0);  // Cell (2, 0) should be NULL (empty)

  ASSERT_TABLE_CELL_STREQ (table, 0, 1, ""B"");  // Cell (0, 1) should be ""B""
  ASSERT_TABLE_CELL_STREQ (table, 1, 1, ""C"");  // Cell (1, 1) should be ""C""
  ASSERT_TABLE_CELL_STREQ (table, 2, 1, ""D"");  // Cell (2, 1) should be ""D""

  ASSERT_TABLE_NULL_CELL (table, 0, 2);  // Cell (0, 2) should be NULL (empty)
  ASSERT_TABLE_CELL_STREQ (table, 1, 2, ""E"");  // Cell (1, 2) should be ""E""
  ASSERT_TABLE_NULL_CELL (table, 2, 2);  // Cell (2, 2) should be NULL (empty)

  // Testing the rendering of the table in ASCII format on a canvas
  {
    // Convert the table to a canvas with ASCII theme and verify its output
    canvas canvas (table.to_canvas (ascii_theme(), sm));
    ASSERT_CANVAS_STREQ
      (canvas, false,
       (""  +-+\n""  // Representing a table with ASCII characters
        ""  |A|\n""
        ""+-+-+-+\n""
        ""|B|C|D|\n""
        ""+-+-+-+\n""
        ""  |E|\n""
        ""  +-+\n""));
  }

  // Testing the rendering of the table in Unicode format on a canvas
  {
    // Convert the table to a canvas with Unicode theme and verify its output
    canvas canvas (table.to_canvas (unicode_theme(), sm));
    ASSERT_CANVAS_STREQ
      (canvas, false,
       (""  ┌─┐\n""  // Representing a table with Unicode characters
        ""  │A│\n""
        ""┌─┼─┼─┐\n""
        ""│B│C│D│\n""
        ""└─┼─┼─┘\n""
        ""  │E│\n""
        ""  └─┘\n""));
  }
}
","This test verifies the handling of missing cells in the table. It checks that cells with missing values are properly represented as null in both canvas formats.
It also validates that cells with actual values (""A"", ""B"", ""C"", etc.) are correctly displayed."
"// Test case to verify the functionality of adding rows to the table
static void test_add_row () {
  // Create a style manager object to manage styling
  style_manager sm;

  // Create a table with 3 columns and 0 rows (initially empty)
  table table (table::size_t (3, 0));

  // Loop to add 5 rows to the table
  for (int i = 0; i < 5; i++) {
    // Add a new row to the table and get its row index
    const int y = table.add_row ();

    // For each column (x = 0, 1, 2), set the cell at (x, y) with formatted string
    for (int x = 0; x < 3; x++) {
      // The formatted string contains the values of x and y, e.g., ""x, y""
      table.set_cell (table::coord_t (x, y),
                      styled_string::from_fmt (sm, nullptr,
                                               ""%i, %i"", x, y));
    }
  }

  // Convert the table to a canvas with ASCII theme and verify its output
  canvas canvas (table.to_canvas (ascii_theme(), sm));
  ASSERT_CANVAS_STREQ
    (canvas, false,
     (""+----+----+----+\n""  // Representing the table with ASCII characters
      ""|0, 0|1, 0|2, 0|\n""
      ""+----+----+----+\n""
      ""|0, 1|1, 1|2, 1|\n""
      ""+----+----+----+\n""
      ""|0, 2|1, 2|2, 2|\n""
      ""+----+----+----+\n""
      ""|0, 3|1, 3|2, 3|\n""
      ""+----+----+----+\n""
      ""|0, 4|1, 4|2, 4|\n""
      ""+----+----+----+\n""));
}
","This test checks the ability to add rows to the table and populate them with data.
It asserts that after adding rows, the cells contain the expected formatted string values (e.g., ""0, 0"", ""1, 0"", etc.)."
"// Test case to verify the alignment of cell spans in the table
static void test_alignment () {
  // Create a style manager object to handle cell styling
  style_manager sm;

  // Create a table with 9 columns and 9 rows (empty initially)
  table table (table::size_t (9, 9));

  // Set a span of cells from (0, 0) to (3, 3) with the text ""left top"" 
  // aligned to the left (x) and top (y)
  table.set_cell_span (table::rect_t (table::coord_t (0, 0),
                                      table::size_t (3, 3)),
                       styled_string (sm, ""left top""),
                       x_align::LEFT, y_align::TOP);

  // Set a span of cells from (3, 0) to (3, 3) with the text ""center top"" 
  // aligned to the center (x) and top (y)
  table.set_cell_span (table::rect_t (table::coord_t (3, 0),
                                      table::size_t (3, 3)),
                       styled_string (sm, ""center top""),
                       x_align::CENTER, y_align::TOP);

  // Set a span of cells from (6, 0) to (3, 3) with the text ""right top"" 
  // aligned to the right (x) and top (y)
  table.set_cell_span (table::rect_t (table::coord_t (6, 0),
                                      table::size_t (3, 3)),
                       styled_string (sm, ""right top""),
                       x_align::RIGHT, y_align::TOP);

  // Set a span of cells from (0, 3) to (3, 3) with the text ""left center"" 
  // aligned to the left (x) and center (y)
  table.set_cell_span (table::rect_t (table::coord_t (0, 3),
                                      table::size_t (3, 3)),
                       styled_string (sm, ""left center""),
                       x_align::LEFT, y_align::CENTER);

  // Set a span of cells from (3, 3) to (3, 3) with the text ""center center"" 
  // aligned to the center (x) and center (y)
  table.set_cell_span (table::rect_t (table::coord_t (3, 3),
                                      table::size_t (3, 3)),
                       styled_string (sm, ""center center""),
                       x_align::CENTER, y_align::CENTER);

  // Set a span of cells from (6, 3) to (3, 3) with the text ""right center"" 
  // aligned to the right (x) and center (y)
  table.set_cell_span (table::rect_t (table::coord_t (6, 3),
                                      table::size_t (3, 3)),
                       styled_string (sm, ""right center""),
                       x_align::RIGHT, y_align::CENTER);

  // Set a span of cells from (0, 6) to (3, 3) with the text ""left bottom"" 
  // aligned to the left (x) and bottom (y)
  table.set_cell_span (table::rect_t (table::coord_t (0, 6),
                                      table::size_t (3, 3)),
                       styled_string (sm, ""left bottom""),
                       x_align::LEFT, y_align::BOTTOM);

  // Set a span of cells from (3, 6) to (3, 3) with the text ""center bottom"" 
  // aligned to the center (x) and bottom (y)
  table.set_cell_span (table::rect_t (table::coord_t (3, 6),
                                      table::size_t (3, 3)),
                       styled_string (sm, ""center bottom""),
                       x_align::CENTER, y_align::BOTTOM);

  // Set a span of cells from (6, 6) to (3, 3) with the text ""right bottom"" 
  // aligned to the right (x) and bottom (y)
  table.set_cell_span (table::rect_t (table::coord_t (6, 6),
                                      table::size_t (3, 3)),
                       styled_string (sm, ""right bottom""),
                       x_align::RIGHT, y_align::BOTTOM);

  // Convert the table to a canvas with ASCII theme and verify its output
  canvas canvas (table.to_canvas (ascii_theme(), sm));
  ASSERT_CANVAS_STREQ
    (canvas, false,
     (""+-----------+-------------+------------+\n""  // Representing the table with ASCII characters
      ""|left top   | center top  |   right top|\n""
      ""|           |             |            |\n""
      ""+-----------+-------------+------------+\n""
      ""|left center|center center|right center|\n""
      ""|           |             |            |\n""
      ""+-----------+-------------+------------+\n""
      ""|           |             |            |\n""
      ""|left bottom|center bottom|right bottom|\n""
      ""+-----------+-------------+------------+\n""));
}
","The test checks different alignment options (LEFT, CENTER, RIGHT, TOP, CENTER, BOTTOM) for multi-cell spans in the table.
It ensures that the cells are aligned correctly in both directions (X and Y).
The canvas output is validated to match the expected formatting for the given alignments."
"void
theme::paint_y_arrow (canvas &canvas,
                      int canvas_x,
                      canvas::range_t y_range,
                      y_arrow_dir dir,
                      style::id_t style_id) const
{
  int canvas_y;
  int delta_y;

  // Select the arrow head and tail characters based on the direction of the arrow
  const canvas::cell_t head (get_cppchar (dir == y_arrow_dir::UP
                                          ? cell_kind::Y_ARROW_UP_HEAD
                                          : cell_kind::Y_ARROW_DOWN_HEAD),
                             false, style_id);
  const canvas::cell_t tail (get_cppchar (dir == y_arrow_dir::UP
                                          ? cell_kind::Y_ARROW_UP_TAIL
                                          : cell_kind::Y_ARROW_DOWN_TAIL),
                             false, style_id);

  // Determine the starting position and step direction for the arrow based on the direction
  if (dir == y_arrow_dir::UP)
    {
      canvas_y = y_range.get_max ();  // Set the initial position to the top of the range
      delta_y = -1;  // Move upwards (decrease y-coordinate)
    }
  else
    {
      canvas_y = y_range.get_min ();  // Set the initial position to the bottom of the range
      delta_y = 1;  // Move downwards (increase y-coordinate)
    }

  // Loop through the range and paint the arrow on the canvas
  for (int len = y_range.get_size (); len; len--)
    {
      // If we're at the last position, paint the head of the arrow; otherwise, paint the tail
      const canvas::cell_t cell = (len > 1) ? tail : head;
      canvas.paint (canvas::coord_t (canvas_x, canvas_y), cell);  // Paint the current cell
      canvas_y += delta_y;  // Move to the next y position
    }
}
","Purpose: This function paints a vertical arrow (either pointing up or down) on the given canvas within a specific range of y-coordinates (y_range). It uses a given style_id to determine the visual styling of the arrow.
Parameters:
canvas: The canvas on which the arrow will be painted.
canvas_x: The x-coordinate on the canvas where the arrow is to be drawn.
y_range: The vertical range (min and max y-coordinates) within which the arrow is drawn.
dir: The direction of the arrow (UP or DOWN).
style_id: The style used for the arrow's appearance.
Logic: The function determines whether the arrow is pointing up or down, selects the appropriate arrowhead and tail characters, and then iterates over the y-range, painting the tail of the arrow (for all positions except the last) and the head of the arrow (for the last position). It moves the painting position vertically based on the arrow's direction.
"
"canvas::cell_t
ascii_theme::get_line_art (directions line_dirs) const
{
  // Return a vertical line if only 'up' and 'down' directions are set
  if (line_dirs.m_up
      && line_dirs.m_down
      && !(line_dirs.m_left || line_dirs.m_right))
    return canvas::cell_t ('|');
  
  // Return a horizontal line if only 'left' and 'right' directions are set
  if (line_dirs.m_left
      && line_dirs.m_right
      && !(line_dirs.m_up || line_dirs.m_down))
    return canvas::cell_t ('-');
  
  // Return a cross ('+') if all directions are set
  if (line_dirs.m_up
      || line_dirs.m_down
      || line_dirs.m_left
      || line_dirs.m_right)
    return canvas::cell_t ('+');
  
  // Return an empty space if no direction is set
  return canvas::cell_t (' ');
}
","Purpose: This function returns the appropriate ASCII character to represent a line based on the directions provided in the line_dirs object. It is typically used for drawing box-like structures or graphs.
Parameters:
line_dirs: A directions object that indicates the directions (up, down, left, right) where the line segments should be drawn.
Logic: The function checks which directions are set and returns the corresponding character:
Vertical line (|) for up and down directions.
Horizontal line (-) for left and right directions.
Cross (+) when all four directions are set.
Space (' ') when no direction is set."
"cppchar_t
ascii_theme::get_cppchar (enum cell_kind kind) const
{
  switch (kind)
    {
    default:
      gcc_unreachable ();  // Ensures that no undefined 'kind' value is passed

    // Return corresponding ASCII character for each cell kind
    case cell_kind::X_RULER_LEFT_EDGE:
      return '|';
    case cell_kind::X_RULER_MIDDLE:
      return '~';
    case cell_kind::X_RULER_INTERNAL_EDGE:
      return '|';
    case cell_kind::X_RULER_CONNECTOR_TO_LABEL_BELOW:
    case cell_kind::X_RULER_CONNECTOR_TO_LABEL_ABOVE:
      return '+';
    case cell_kind::X_RULER_RIGHT_EDGE:
      return '|';
    case cell_kind::X_RULER_VERTICAL_CONNECTOR:
      return '|';

    case cell_kind::TEXT_BORDER_HORIZONTAL:
      return '-';
    case cell_kind::TEXT_BORDER_VERTICAL:
      return '|';
    case cell_kind::TEXT_BORDER_TOP_LEFT:
    case cell_kind::TEXT_BORDER_TOP_RIGHT:
    case cell_kind::TEXT_BORDER_BOTTOM_LEFT:
    case cell_kind::TEXT_BORDER_BOTTOM_RIGHT:
      return '+';

    case cell_kind::Y_ARROW_UP_HEAD: return '^';
    case cell_kind::Y_ARROW_DOWN_HEAD: return 'v';

    case cell_kind::Y_ARROW_UP_TAIL:
    case cell_kind::Y_ARROW_DOWN_TAIL:
      return '|';

    // Handle various procedural and control flow symbols
    case cell_kind::INTERPROCEDURAL_PUSH_FRAME_LEFT:
      return '+';
    case cell_kind::INTERPROCEDURAL_PUSH_FRAME_MIDDLE:
      return '-';
    case cell_kind::INTERPROCEDURAL_PUSH_FRAME_RIGHT:
      return '>';
    case cell_kind::INTERPROCEDURAL_DEPTH_MARKER:
      return '|';
    case cell_kind::INTERPROCEDURAL_POP_FRAMES_LEFT:
      return '<';
    case cell_kind::INTERPROCEDURAL_POP_FRAMES_MIDDLE:
      return '-';
    case cell_kind::INTERPROCEDURAL_POP_FRAMES_RIGHT:
      return '+';

    // Handle CFG and tree structure symbols
    case cell_kind::CFG_RIGHT:
      return '-';
    case cell_kind::CFG_FROM_RIGHT_TO_DOWN:
      return '+';
    case cell_kind::CFG_DOWN:
      return '|';
    case cell_kind::CFG_FROM_DOWN_TO_LEFT:
      return '+';
    case cell_kind::CFG_LEFT:
      return '-';
    case cell_kind::CFG_FROM_LEFT_TO_DOWN:
      return '+';
    case cell_kind::CFG_FROM_DOWN_TO_RIGHT:
      return '+';

    case cell_kind::TREE_CHILD_NON_FINAL:
      return '+';
    case cell_kind::TREE_CHILD_FINAL:
      return '`';
    case cell_kind::TREE_X_CONNECTOR:
      return '-';
    case cell_kind::TREE_Y_CONNECTOR:
      return '|';
    }
}
","Purpose: This function maps each cell_kind enum value to its corresponding ASCII character. This is used to return appropriate characters for drawing cells, borders, arrows, etc., in a text-based canvas.
Parameters:
kind: An enumeration value from cell_kind that represents the type of cell.
Logic: The function uses a switch statement to return specific ASCII characters based on the kind of the cell. If an unsupported or undefined kind is encountered, the function ensures a runtime error via gcc_unreachable()."
"canvas::cell_t
unicode_theme::get_line_art (directions line_dirs) const
{
  return canvas::cell_t (get_box_drawing_char (line_dirs));
}
","Purpose: This function returns the appropriate Unicode character for drawing lines based on the directions provided. It is similar to ascii_theme::get_line_art, but uses Unicode box-drawing characters for higher-quality graphical representation.
Parameters:
line_dirs: A directions object that indicates the directions (up, down, left, right) where the line segments should be drawn.
Logic: It calls get_box_drawing_char with the given directions and returns the corresponding Unicode character."
"cppchar_t
unicode_theme::get_cppchar (enum cell_kind kind) const
{
  switch (kind)
    {
    default:
      gcc_unreachable ();  // Ensures that no undefined 'kind' value is passed

    // Return corresponding Unicode character for each cell kind
    case cell_kind::X_RULER_LEFT_EDGE:
      return 0x250c;  // ┌
    case cell_kind::X_RULER_MIDDLE:
      return 0x253c;  // ┼
    case cell_kind::X_RULER_INTERNAL_EDGE:
      return 0x2500;  // ─
    case cell_kind::X_RULER_CONNECTOR_TO_LABEL_BELOW:
    case cell_kind::X_RULER_CONNECTOR_TO_LABEL_ABOVE:
      return 0x252c;  // ┬
    case cell_kind::X_RULER_RIGHT_EDGE:
      return 0x2510;  // ┐
    case cell_kind::X_RULER_VERTICAL_CONNECTOR:
      return 0x2502;  // │

    case cell_kind::TEXT_BORDER_HORIZONTAL:
      return 0x2500;  // ─
    case cell_kind::TEXT_BORDER_VERTICAL:
      return 0x2502;  // │
    case cell_kind::TEXT_BORDER_TOP_LEFT:
    case cell_kind::TEXT_BORDER_TOP_RIGHT:
    case cell_kind::TEXT_BORDER_BOTTOM_LEFT:
    case cell_kind::TEXT_BORDER_BOTTOM_RIGHT:
      return 0x253c;  // ┼

    case cell_kind::Y_ARROW_UP_HEAD:
      return 0x2191;  // ↑
    case cell_kind::Y_ARROW_DOWN_HEAD:
      return 0x2193;  // ↓

    case cell_kind::Y_ARROW_UP_TAIL:
    case cell_kind::Y_ARROW_DOWN_TAIL:
      return 0x2502;  // │

    case cell_kind::INTERPROCEDURAL_PUSH_FRAME_LEFT:
      return 0x251c;  // ├
    case cell_kind::INTERPROCEDURAL_PUSH_FRAME_MIDDLE:
      return 0x2500;  // ─
    case cell_kind::INTERPROCEDURAL_PUSH_FRAME_RIGHT:
      return 0x2524;  // ┤
    case cell_kind::INTERPROCEDURAL_DEPTH_MARKER:
      return 0x2502;  // │
    case cell_kind::INTERPROCEDURAL_POP_FRAMES_LEFT:
      return 0x2514;  // └
    case cell_kind::INTERPROCEDURAL_POP_FRAMES_MIDDLE:
      return 0x2500;  // ─
    case cell_kind::INTERPROCEDURAL_POP_FRAMES_RIGHT:
      return 0x2518;  // ┘

    case cell_kind::CFG_RIGHT:
      return 0x2500;  // ─
    case cell_kind::CFG_FROM_RIGHT_TO_DOWN:
      return 0x2510;  // ┐
    case cell_kind::CFG_DOWN:
      return 0x2502;  // │
    case cell_kind::CFG_FROM_DOWN_TO_LEFT:
      return 0x251c;  // ├
    case cell_kind::CFG_LEFT:
      return 0x2500;  // ─
    case cell_kind::CFG_FROM_LEFT_TO_DOWN:
      return 0x2524;  // ┤
    case cell_kind::CFG_FROM_DOWN_TO_RIGHT:
      return 0x252c;  // ┬

    case cell_kind::TREE_CHILD_NON_FINAL:
      return 0x251c;  // ├
    case cell_kind::TREE_CHILD_FINAL:
      return 0x2514;  // └
    case cell_kind::TREE_X_CONNECTOR:
      return 0x2500;  // ─
    case cell_kind::TREE_Y_CONNECTOR:
      return 0x2502;  // │
    }
}
","Purpose: This function maps cell_kind enum values to corresponding Unicode characters for advanced graphical elements such as box-drawing, arrows, and connectors.
Parameters:
kind: An enumeration value from cell_kind that represents the type of cell.
Logic: Similar to the ASCII version, but uses Unicode box-drawing characters for a higher-quality graphical output, supporting more complex and visually appealing structures."
"// Function to create a tree widget with a styled string
std::unique_ptr<tree_widget>
tree_widget::make (styled_string str, const theme &theme, style::id_t style_id)
{
  // Creating and returning a new tree_widget object, initialized with a text_widget
  return ::make_unique <tree_widget>
    (::make_unique <text_widget> (std::move (str)),
     theme,
     style_id);
}","Description: This function creates a tree_widget instance that uses a text_widget as its core element. It takes a styled_string (which contains the text to display), a theme (for visual styling), and a style_id (for specific style application). The function then returns a unique pointer to the newly created tree_widget.
Parameters:
str: The text to be displayed within the tree widget, formatted as a styled_string.
theme: The theme that defines the visual styling of the widget.
style_id: An ID representing the style to be applied to the widget.
Returns: A std::unique_ptr<tree_widget> that points to the newly created tree_widget."
"// Function to create a tree widget from a dump_widget_info object and a pretty printer
std::unique_ptr<tree_widget>
tree_widget::make (const dump_widget_info &dwi, pretty_printer *pp)
{
  // Using dump_widget_info to extract a styled string, theme, and style ID, and returning a new tree_widget
  return tree_widget::make (styled_string (dwi.m_sm, pp_formatted_text (pp)),
                            dwi.m_theme,
                            dwi.get_tree_style_id ());
}","Description: This function creates a tree_widget from a dump_widget_info object. It extracts the theme and style ID from dwi and uses a pretty printer to format the text. It then returns a new tree_widget initialized with this information.
Parameters:
dwi: A dump_widget_info object that contains styling information and theme for the widget.
pp: A pointer to a pretty_printer object, which is used to format the text to be displayed.
Returns: A std::unique_ptr<tree_widget> that points to the newly created tree_widget."
"// Function to create a tree widget from a dump_widget_info object and a raw string
std::unique_ptr<tree_widget>
tree_widget::make (const dump_widget_info &dwi, const char *str)
{
  // Using dump_widget_info to extract a styled string, theme, and style ID, and returning a new tree_widget
  return tree_widget::make (styled_string (dwi.m_sm, str),
                            dwi.m_theme,
                            dwi.get_tree_style_id ());
}","Description: Similar to the previous function, this one creates a tree_widget using the dump_widget_info for styling and theme, but instead of using a pretty printer, it directly takes a raw string (const char*), which is wrapped into a styled_string.
Parameters:
dwi: A dump_widget_info object containing theme and style information.
str: A raw C-string that represents the text to be displayed in the widget.
Returns: A std::unique_ptr<tree_widget> pointing to the newly created tree_widget."
"// Function to create a tree widget from a formatted string using a format decoder
std::unique_ptr<tree_widget>
tree_widget::from_fmt (const dump_widget_info &dwi,
                       printer_fn format_decoder,
                       const char *fmt, ...)
{
  va_list ap;
  va_start (ap, fmt);
  
  // Create a styled string by decoding the formatted string
  styled_string styled_str
    (styled_string::from_fmt_va (dwi.m_sm, format_decoder, fmt, &ap));
  
  va_end (ap);
  
  // Return a tree_widget created from the formatted styled string, theme, and style ID
  return make (std::move (styled_str), dwi.m_theme, dwi.get_tree_style_id ());
}
","Description: This function creates a tree_widget from a formatted string using a format_decoder function. The formatted string is passed as a const char* along with a variable argument list, which is then processed by the format_decoder function to create a styled_string. This formatted string is then used to initialize the tree_widget.
Parameters:
dwi: A dump_widget_info object containing theme and style information.
format_decoder: A function pointer (printer_fn) used to decode the formatted string into a styled_string.
fmt: A const char* format string.
...: A variable argument list that corresponds to the format string.
Returns: A std::unique_ptr<tree_widget> pointing to the newly created tree_widget."
"// Function to return a description of the tree widget
const char *
tree_widget::get_desc () const
{
  return ""tree_widget"";
}","Description: This function returns a string description of the tree_widget object. It is used for debugging or informational purposes to identify the widget type.
Returns: A const char* string that describes the type of the widget, which in this case is ""tree_widget""."
"// Function to calculate the required size for the tree widget
canvas::size_t
tree_widget::calc_req_size ()
{
  canvas::size_t result (0, 0);
  
  // If the node exists, add its required size to the result
  if (m_node)
    {
      canvas::size_t node_req_size = m_node->get_req_size ();
      result.h += node_req_size.h;
      result.w = std::max (result.w, node_req_size.w);
    }
  
  // Iterate over each child, adding their required sizes and adjusting the width and height
  for (auto &child : m_children)
    {
      canvas::size_t child_req_size = child->get_req_size ();
      result.h += child_req_size.h;
      result.w = std::max (result.w, child_req_size.w + margin_width);
    }
  
  // Return the total required size for the tree widget
  return result;
}
","Description: This function calculates the required size for the tree_widget. It considers the size of the main node and its children. The width of the tree widget is the maximum width among the node and its children, while the height is the sum of the heights of the node and all of its children.
Returns: A canvas::size_t structure that represents the required width (w) and height (h) of the tree_widget."
"// Function to update the allocated rectangles for each child in the tree widget
void
tree_widget::update_child_alloc_rects ()
{
  const int x = get_min_x ();  // Get the minimum x-coordinate
  int y = get_min_y ();        // Get the minimum y-coordinate
  
  // If the node exists, allocate its rectangle and adjust the y-coordinate
  if (m_node)
    {
      m_node->set_alloc_rect
        (canvas::rect_t (canvas::coord_t (x, y),
                         canvas::size_t (get_alloc_w (),
                                         m_node->get_req_h ())));
      y += m_node->get_req_h ();  // Update y to account for the node's height
    }
  
  // Iterate over each child, allocating their rectangles and adjusting the y-coordinate
  for (auto &child : m_children)
    {
      child->set_alloc_rect
        (canvas::rect_t (canvas::coord_t (x + margin_width, y),
                         canvas::size_t (get_alloc_w () - margin_width,
                                         child->get_req_h ())));
      y += child->get_req_h ();  // Update y to account for the child's height
    }
}","Description: This function updates the allocated rectangular areas (bounding boxes) for each child in the tree widget. It calculates the positions of the node and its children based on the widget's layout and stores their positions and sizes.
Side Effects: Modifies the position and size of each child widget in the tree.
Returns: This function does not return any value; it updates the internal state of the tree_widget by adjusting the allocated rectangles of the node and its children."
"// Function to paint the tree widget to a canvas
void
tree_widget::paint_to_canvas (canvas &canvas)
{
  // Paint the node if it exists
  if (m_node)
    m_node->paint_to_canvas (canvas);
  
  const int min_x = get_min_x ();  // Get the minimum x-coordinate
  const canvas::cell_t cell_child_non_final
    (m_theme.get_cell (theme::cell_kind::TREE_CHILD_NON_FINAL, m_style_id));
  const canvas::cell_t cell_child_final
    (m_theme.get_cell (theme::cell_kind::TREE_CHILD_FINAL, m_style_id));
  const canvas::cell_t cell_x_connector
    (m_theme.get_cell (theme::cell_kind::TREE_X_CONNECTOR, m_style_id));
  const canvas::cell_t cell_y_connector
    (m_theme.get_cell (theme::cell_kind::TREE_Y_CONNECTOR, m_style_id));
  
  size_t idx = 0;
  
  // Iterate over each child and paint it along with connectors
  for (auto &child : m_children)
    {
      child->paint_to_canvas (canvas);

      const bool last_child = (++idx == m_children.size ());
      
      // Paint the x and y connectors between parent and child
      canvas.paint (canvas::coord_t (min_x + 1, child->get_min_y ()),
                    cell_x_connector);
      canvas.paint (canvas::coord_t (min_x, child->get_min_y ()),
                    last_child ? cell_child_final : cell_child_non_final);
      
      // If not the last child, paint vertical connectors
      if (!last_child)
        for (int y = child->get_min_y () + 1; y <= child ->get_max_y (); y++)
          canvas.paint (canvas::coord_t (min_x, y), cell_y_connector);
    }
}
","Description: This function is responsible for rendering the tree_widget and its children onto a given canvas. It draws the node (if it exists) and all child nodes, including connectors between the parent and child nodes. The connectors are drawn based on whether the child is the last in the list (final or non-final).
Parameters:
canvas: The canvas object where the tree widget and its children will be drawn.
Returns: This function does not return any value; it directly paints the tree widget on the provided canvas."
"// Function to create a test tree widget for self-testing
static std::unique_ptr<tree_widget>
make_test_tree_widget (const dump_widget_info &dwi)
{
  std::unique_ptr<tree_widget> w
    (tree_widget::from_fmt (dwi, nullptr, ""Root""));
  
  // Create and add child widgets with grandchild widgets
  for (int i = 0; i < 3; i++)
    {
      std::unique_ptr<tree_widget> c
        (tree_widget::from_fmt (dwi, nullptr, ""Child %i"", i));
      for (int j = 0; j < 3; j++)
        c->add_child (tree_widget::from_fmt (dwi, nullptr,
                                             ""Grandchild %i %i"", i, j));
      w->add_child (std::move (c));
    }
  
  // Return the constructed tree widget
  return w;
}","Description: This function is used to create a sample tree_widget structure for testing purposes. It creates a root node with several child nodes, each of which has its own set of grandchild nodes. It returns the root tree_widget containing the full tree structure.
Parameters:
dwi: A dump_widget_info object containing styling and theme information.
Returns: A std::unique_ptr<tree_widget> that points to the root of the test tree widget."
"// Function to test the functionality of the tree widget
static void
test_tree_widget ()
{
  style_manager sm;

  style::id_t default_style_id (sm.get_or_create_id (style ()));

  {
    ascii_theme theme;
    dump_widget_info dwi (sm, theme, default_style_id);
    canvas c (make_test_tree_widget (dwi)->to_canvas (sm));
    
    // Check the output of the tree widget against the expected ASCII tree structure
    ASSERT_CANVAS_STREQ
      (c, false,
       (""Root\n""
        ""+- Child 0\n""
        ""|  +- Grandchild 0 0\n""
        ""|  +- Grandchild 0 1\n""
        ""|  `- Grandchild 0 2\n""
        ""+- Child 1\n""
        ""|  +- Grandchild 1 0\n""
        ""|  +- Grandchild 1 1\n""
        ""|  `- Grandchild 1 2\n""
        ""`- Child 2\n""
        ""   +- Grandchild 2 0\n""
        ""   +- Grandchild 2 1\n""
        ""   `- Grandchild 2 2\n""));
  }

  {
    unicode_theme theme;
    dump_widget_info dwi (sm, theme, default_style_id);
    canvas c (make_test_tree_widget (dwi)->to_canvas (sm));
    
    // Check the output of the tree widget against the expected Unicode tree structure
    ASSERT_CANVAS_STREQ
      (c, false,
       (""Root\n""
        ""├─ Child 0\n""
        ""│  ├─ Grandchild 0 0\n""
        ""│  ├─ Grandchild 0 1\n""
        ""│  ╰─ Grandchild 0 2\n""
        ""├─ Child 1\n""
        ""│  ├─ Grandchild 1 0\n""
        ""│  ├─ Grandchild 1 1\n""
        ""│  ╰─ Grandchild 1 2\n""
        ""╰─ Child 2\n""
        ""   ├─ Grandchild 2 0\n""
        ""   ├─ Grandchild 2 1\n""
        ""   ╰─ Grandchild 2 2\n""));
  }
}","Description: This function is a self-test for the tree_widget. It uses the make_test_tree_widget function to create a test tree and renders it to a canvas. It then verifies that the rendered output matches an expected ASCII or Unicode tree structure. It uses assertions to check if the canvas output matches the expected output.
Side Effects: If the test fails, an assertion error is triggered. If the test passes, there is no output.
Returns: This function does not return any value; it is used purely for testing purposes."
"/**
 * Converts the widget into a canvas representation.
 *
 * @param style_mgr A reference to the style manager for managing canvas styles.
 * @return A canvas object representing the widget's visual state.
 */
canvas
widget::to_canvas(const style_manager &style_mgr)
{
  // Get the required size for the widget based on its content and layout needs.
  const canvas::size_t req_size = get_req_size();

  /**
   * Allocate space for the widget. For now, this allocation is not constrained,
   * meaning the widget is granted the full size it requested. This implies
   * that widgets assume they always receive their requested size.
   */
  const canvas::size_t alloc_size = req_size;

  // Define the allocation rectangle for the widget starting at (0,0).
  set_alloc_rect(canvas::rect_t(canvas::coord_t(0, 0), alloc_size));

  // Create a canvas object with the allocated size and style manager.
  canvas c(alloc_size, style_mgr);

  // Render the widget onto the canvas.
  paint_to_canvas(c);

  // Return the rendered canvas to the caller.
  return c;
}
","Purpose: Converts a widget into a canvas object, accommodating its required size for rendering.
Key Steps:
Determines the required size of the widget using get_req_size.
Allocates a rectangular area (alloc_size) equal to the required size.
Initializes a canvas object of the allocated size and delegates the rendering process to the paint_to_canvas function.
Returns: A canvas object representing the widget’s visual representation"
"/**
 * Retrieves a description of the `vbox_widget`.
 *
 * @return A constant string describing the widget type.
 */
const char *
vbox_widget::get_desc() const
{
  // Return a fixed description identifying the widget as ""vbox_widget"".
  return ""vbox_widget"";
}
","Returns a description of the widget type (""vbox_widget"")."
"/**
 * Calculates the required size of the `vbox_widget`.
 *
 * @return The aggregated size of the widget based on its children's dimensions.
 */
canvas::size_t
vbox_widget::calc_req_size()
{
  // Initialize the result size with zero height and width.
  canvas::size_t result(0, 0);

  // Iterate over all child widgets to calculate the total required size.
  for (auto &child : m_children)
  {
    // Retrieve the required size of the current child.
    canvas::size_t child_req_size = child->get_req_size();

    // Accumulate the heights of all children to compute the total height.
    result.h += child_req_size.h;

    // Update the width to the maximum width among all children.
    result.w = std::max(result.w, child_req_size.w);
  }

  // Return the computed size of the `vbox_widget`.
  return result;
}","Purpose: Calculates the required size of the vertical box widget by aggregating its children.
Key Steps:
Loops through all child widgets.
Accumulates the heights of all children and determines the maximum width.
Returns: The total size (height and width) needed for the widget."
"/**
 * Updates the allocated rectangles for all child widgets in the `vbox_widget`.
 *
 * This function sets the position and size of each child widget within the
 * vertical box layout, aligning them sequentially based on their required height.
 */
void
vbox_widget::update_child_alloc_rects()
{
  // Get the minimum x-coordinate for the allocation rectangle of this widget.
  const int x = get_min_x();

  // Start the y-coordinate from the minimum y value of this widget.
  int y = get_min_y();

  // Iterate through all child widgets in the vertical box.
  for (auto &child : m_children)
  {
    // Set the allocated rectangle for the current child widget.
    // The rectangle starts at (x, y) with a width equal to the allocation width of the parent
    // and a height equal to the required height of the child widget.
    child->set_alloc_rect(
      canvas::rect_t(
        canvas::coord_t(x, y),
        canvas::size_t(get_alloc_w(), child->get_req_h())
      ));

    // Move the y-coordinate downward by the height of the current child widget.
    y += child->get_req_h();
  }
}
","Purpose: Updates the allocated rectangles for each child widget within the vertical box.
Key Steps:
Starts from the widget’s minimum x and y coordinates.
Assigns a rectangle to each child based on its required height and the full width of the vertical box.
Adjusts the y-coordinate for subsequent children."
"/**
 * Retrieves a description of the `text_widget`.
 *
 * @return A constant string describing the widget type.
 */
const char *
text_widget::get_desc() const
{
  // Return a fixed description identifying the widget as ""text_widget"".
  return ""text_widget"";
}","Purpose: Returns a description of the widget type (""text_widget"").
"
"/**
 * Calculates the required size of the `text_widget`.
 *
 * The required size is determined by the length of the string to be displayed
 * and the fixed height of 1 row.
 *
 * @return A `canvas::size_t` object representing the width and height.
 */
canvas::size_t
text_widget::calc_req_size()
{
  // The width is the size of the string, and the height is fixed to 1 row.
  return canvas::size_t(m_str.size(), 1);
}
",Determines the size of the widget based on the length of the string (width) and a fixed height of 1.
"/**
 * Renders the `text_widget` onto the given canvas.
 *
 * @param canvas A reference to the canvas where the text will be painted.
 */
void
text_widget::paint_to_canvas(canvas &canvas)
{
  // Paint the stored string onto the canvas starting at the widget's top-left position.
  canvas.paint_text(get_top_left(), m_str);
}",Renders the text string onto the canvas at the widget’s top-left position.
"/**
 * Retrieves a description of the `canvas_widget`.
 *
 * @return A constant string describing the widget type.
 */
const char *
canvas_widget::get_desc() const
{
  // Return a fixed description identifying the widget as ""canvas_widget"".
  return ""canvas_widget"";
}","Returns a description of the widget type (""canvas_widget"")."
"/**
 * Calculates the required size of the `canvas_widget`.
 *
 * The required size is based on the size of the internal canvas.
 *
 * @return A `canvas::size_t` object representing the width and height of the canvas.
 */
canvas::size_t
canvas_widget::calc_req_size()
{
  // Return the size of the internal canvas managed by this widget.
  return m_canvas.get_size();
}",Calculates the required size based on the internal canvas dimensions.
"/**
 * Paints the content of the `canvas_widget` onto the provided canvas.
 *
 * This function iterates over all the cells of the internal canvas managed
 * by the widget and paints them onto the given canvas, offset by the
 * widget's top-left position.
 *
 * @param canvas A reference to the `canvas` object where the content will be painted.
 */
void
canvas_widget::paint_to_canvas(canvas &canvas)
{
  // Loop through each row of the internal canvas.
  for (int y = 0; y < m_canvas.get_size().h; y++)
  {
    // Loop through each column of the current row in the internal canvas.
    for (int x = 0; x < m_canvas.get_size().w; x++)
    {
      // Create a coordinate object representing the relative position within the internal canvas.
      canvas::coord_t rel_xy(x, y);

      // Paint the cell at the relative position onto the given canvas.
      // The paint operation uses the widget's top-left position as the offset.
      canvas.paint(
        get_top_left() + rel_xy, // The absolute position on the destination canvas.
        m_canvas.get(rel_xy)     // The value of the cell from the internal canvas.
      );
    }
  }
}
",Renders the internal canvas onto the provided canvas by copying each cell to its corresponding position.
"/**
 * Constructor for the `test_widget` class.
 *
 * Initializes a `test_widget` instance with a specified size and character.
 *
 * @param size The size of the widget as a `canvas::size_t` object.
 * @param ch The character used to fill the widget's allocated area.
 */
test_widget::test_widget(canvas::size_t size, char ch)
  : m_test_size(size),  // Initialize the widget's requested size.
    m_ch(ch)            // Initialize the character used for painting.
{}",Initializes the widget with the provided size (m_test_size) and character (m_ch).
"/**
 * Provides a description of the `test_widget` class.
 *
 * @return A constant C-string describing the widget type.
 */
const char *test_widget::get_desc() const final override
{
  return ""test_widget""; // Return a string identifier for this widget type.
}","Returns a descriptive string for the widget, used for identification purposes."
"/**
 * Calculates and returns the requested size of the `test_widget`.
 *
 * @return The size of the widget as a `canvas::size_t` object.
 */
canvas::size_t test_widget::calc_req_size() final override
{
  return m_test_size; // Return the size specified during construction.
}
",Provides the size of the widget as specified during its creation. This requested size is used by the parent container to allocate space.
"void test_widget::paint_to_canvas(canvas &canvas) final override
{
  // Fill the widget's allocated rectangle on the canvas with the specified character.
  canvas.fill(
    get_alloc_rect(),   // The allocated rectangle of the widget.
    canvas::cell_t(m_ch) // The character to fill with, wrapped in a canvas cell.
  );
}","Fills the canvas area allocated to the widget with the specified character.
Fills the widget's allocated rectangle on the canvas with the character (m_ch).
The canvas.fill method ensures that the entire allocated space is painted with the same character."
"/**
 * Tests the behavior of the `test_widget` class.
 *
 * Creates a 3x3 `test_widget` filled with the character 'A',
 * renders it to a canvas, and verifies the output.
 */
static void test_test_widget()
{
  style_manager sm; // Initialize a style manager.
  test_widget w(canvas::size_t(3, 3), 'A'); // Create a 3x3 test_widget filled with 'A'.
  canvas c(w.to_canvas(sm)); // Render the widget to a canvas.
  
  // Assert that the canvas contains the expected content.
  ASSERT_CANVAS_STREQ(
    c, false,
    (""AAA\n""
     ""AAA\n""
     ""AAA\n""));
}
",Verifies the rendering of a test_widget by creating a 3x3 widget filled with the character 'A' and checking the canvas output.
"/**
 * Tests the behavior of the `text_widget` class.
 *
 * Creates a `text_widget` containing ""hello world"",
 * renders it to a canvas, and verifies the output.
 */
static void test_text_widget()
{
  style_manager sm; // Initialize a style manager.
  text_widget w(styled_string(sm, ""hello world"")); // Create a text_widget with ""hello world"".
  canvas c(w.to_canvas(sm)); // Render the widget to a canvas.
  
  // Assert that the canvas contains the expected content.
  ASSERT_CANVAS_STREQ(
    c, false,
    (""hello world\n""));
}
","Tests the text_widget by rendering the string ""hello world"" and asserting that the output matches the expected text representation."
"/**
 * Tests the behavior of the `wrapper_widget` class.
 *
 * Wraps a 3x3 `test_widget` filled with 'B', renders it to a canvas,
 * and verifies the output.
 */
static void test_wrapper_widget()
{
  style_manager sm; // Initialize a style manager.
  wrapper_widget w(::make_unique<test_widget>(canvas::size_t(3, 3), 'B')); // Wrap a test_widget.
  canvas c(w.to_canvas(sm)); // Render the wrapper widget to a canvas.
  
  // Assert that the canvas contains the expected content.
  ASSERT_CANVAS_STREQ(
    c, false,
    (""BBB\n""
     ""BBB\n""
     ""BBB\n""));
}
","This test examines the functionality of the vbox_widget class when handling multiple child widgets. The vbox_widget is populated with five text_widget children, each containing a line of text with an incrementing number. The vbox_widget is rendered to a canvas, and the test verifies that the output contains the expected vertical arrangement of lines. This confirms that vbox_widget correctly stacks its children vertically and adjusts its required size accordingly."
"/**
 * Tests the behavior of the `vbox_widget` with multiple `text_widget` children.
 *
 * Adds five `text_widget` children with incrementing line numbers,
 * renders the `vbox_widget` to a canvas, and verifies the output.
 */
static void test_vbox_1()
{
  style_manager sm; // Initialize a style manager.
  vbox_widget w; // Create a vertical box widget.

  // Add five text_widget children to the vbox.
  for (int i = 0; i < 5; i++)
    w.add_child(
      ::make_unique<text_widget>(
        styled_string::from_fmt(sm, nullptr, ""this is line %i"", i)));

  canvas c(w.to_canvas(sm)); // Render the vbox widget to a canvas.
  
  // Assert that the canvas contains the expected content.
  ASSERT_CANVAS_STREQ(
    c, false,
    (""this is line 0\n""
     ""this is line 1\n""
     ""this is line 2\n""
     ""this is line 3\n""
     ""this is line 4\n""));
}
","This test examines the functionality of the vbox_widget class when handling multiple child widgets. The vbox_widget is populated with five text_widget children, each containing a line of text with an incrementing number. The vbox_widget is rendered to a canvas, and the test verifies that the output contains the expected vertical arrangement of lines. This confirms that vbox_widget correctly stacks its children vertically and adjusts its required size accordingly."
"/**
 * Tests the behavior of the `vbox_widget` with mixed child widgets.
 *
 * Adds a variety of `test_widget` children with different sizes,
 * renders the `vbox_widget` to a canvas, and verifies the output.
 */
static void test_vbox_2()
{
  style_manager sm; // Initialize a style manager.
  vbox_widget w; // Create a vertical box widget.

  // Add test_widget children of different sizes and characters.
  w.add_child(::make_unique<test_widget>(canvas::size_t(1, 3), 'A'));
  w.add_child(::make_unique<test_widget>(canvas::size_t(4, 1), 'B'));
  w.add_child(::make_unique<test_widget>(canvas::size_t(1, 2), 'C'));

  canvas c(w.to_canvas(sm)); // Render the vbox widget to a canvas.
  
  // Assert that the canvas contains the expected content.
  ASSERT_CANVAS_STREQ(
    c, false,
    (""AAAA\n""
     ""AAAA\n""
     ""AAAA\n""
     ""BBBB\n""
     ""CCCC\n""
     ""CCCC\n""));
}
","This test evaluates the vbox_widget class when managing child widgets of varying sizes. The vbox_widget is populated with three test_widget children: a 1x3 widget filled with 'A', a 4x1 widget filled with 'B', and a 1x2 widget filled with 'C'. The rendered canvas is checked to ensure the widgets are stacked vertically with their respective sizes and characters. This test validates the layout and allocation logic of the vbox_widget.

"
"/**
 * Tests the behavior of the `canvas_widget` class.
 *
 * Creates a `canvas_widget` with a filled inner canvas,
 * renders it to the outer canvas, and verifies the output.
 */
static void test_canvas_widget()
{
  style_manager sm; // Initialize a style manager.

  // Create an inner canvas of size 5x3 and fill it with 'a'.
  canvas inner_canvas(canvas::size_t(5, 3), sm);
  inner_canvas.fill(
    canvas::rect_t(canvas::coord_t(0, 0), canvas::size_t(5, 3)),
    canvas::cell_t('a'));

  canvas_widget cw(std::move(inner_canvas)); // Create a canvas_widget with the inner canvas.
  canvas c(cw.to_canvas(sm)); // Render the canvas_widget to an outer canvas.

  // Assert that the canvas contains the expected content.
  ASSERT_CANVAS_STREQ(
    c, false,
    (""aaaaa\n""
     ""aaaaa\n""
     ""aaaaa\n""));
}
","This test verifies the behavior of the canvas_widget class. A 5x3 canvas_widget is initialized with an inner canvas filled with the character 'a'. The canvas_widget is rendered to an outer canvas, and the output is checked to confirm it contains a 5x3 grid of the character 'a'. This test ensures that the canvas_widget correctly integrates and renders its inner canvas content."